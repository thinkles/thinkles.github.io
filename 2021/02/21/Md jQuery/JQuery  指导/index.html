

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yangsir">
  <meta name="keywords" content="">
  <title>jQuery 基础 - Yangsir&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Yangsir-Zone</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/images/bag.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="jQuery 基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-21 11:41" pubdate>
        2021年2月21日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">jQuery 基础</h1>
            
            <div class="markdown-body">
              <h1 id="jQuery-实践"><a href="#jQuery-实践" class="headerlink" title="jQuery 实践"></a>jQuery 实践</h1><ul>
<li><p>抽象jQuery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax </p>
</li>
<li><p>jQuery 总是面向对象,对节点集合可能会进行隐式迭代操作</p>
</li>
<li><p>编写程序时要尊重渐进增强,和平稳退化</p>
</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li><p>使用jQuery选择器就算获取不到元素也不会报错,传统Dom在获取之前要加上if判断是否存在,需要注意</p>
<blockquote>
<p>$()获取的永远是一个对象,就算不存在该元素,所以jQuery通过对象的长度大小.length 属性进行判断是否存在</p>
</blockquote>
</li>
</ul>
<h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ul>
<li>id 标签名 类名 层次选择器(+ ~ &gt; 后代…)</li>
<li>表单选择器  :表单标签名字</li>
</ul>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul>
<li><p> element[attr] 选中拥有attr属性的元素,可以多选属性 </p>
</li>
<li><blockquote>
<p>可以利用正则表达式进行判断属性 <code>a[href^=&quot;mailto:&quot;]</code> 判断href属性开头含有mailto的元素</p>
</blockquote>
</li>
</ul>
<h4 id="过滤选择器-自定义选择器"><a href="#过滤选择器-自定义选择器" class="headerlink" title="过滤选择器(自定义选择器)"></a>过滤选择器(自定义选择器)</h4><ul>
<li><p>过滤选择器又被成为<strong>自定义选择器</strong>, 隶属于jQuery独有的选择器</p>
</li>
<li><p>基本过滤器:</p>
<blockquote>
<p>  <code>:first </code>选取第一个元素（单个元素）,<code>:last</code><br>  <code>:not(selector)</code> 去除所有与给定选择器匹配的元素,<br>  <code>:even :odd </code>索引从零开始<br> <code> :eq（index）</code> 选取索引等于index的元素,</p>
<p><code>:gt(index)</code>  大于index <code>:lt(index)：</code>小于<br>  <code>:header</code>  选取所有的标题元素<br>  <code>:animated：</code>选取当前正在执行动画的所有元素<br>  <code>:focus：</code>选取当前获得焦点的元素</p>
<p>  <code>nth-child() </code>参数可以为数字<br><code> even/odd</code> 表达式  索引从1开始<br>  <code>first-child last-child only-child</code></p>
</blockquote>
</li>
<li><p>内容过滤器 </p>
<blockquote>
<p><code>:contains(text)</code> 选取(直接)含有text文本内容的元素,(子元素含有并不算)<br><code> :empty</code>选取内容为空的元素(没有元素节点 没有文本节点)<br><code>:has(selector) </code>选取<strong>含有</strong>指定选择器选定的元素的元素  </p>
<p> <code> :parent</code> 选取有子元素的元素<br> <code> :visible</code>  选取所有可见的元素<br><code> :hidden</code></p>
</blockquote>
</li>
<li><p>表单选择符</p>
<blockquote>
<p><code>:checked :selected :enabled :disabled</code></p>
</blockquote>
</li>
</ul>
<ul>
<li>只要可能，jQuery就会使用浏览器原生的DOM选择符引擎去查找元素。但在<br> 使用自定义选择符的时候，就无法使用速度最快的原生方法了。</li>
</ul>
<h4 id="Dom遍历方法"><a href="#Dom遍历方法" class="headerlink" title="Dom遍历方法"></a>Dom遍历方法</h4><ul>
<li>遍历方法提供了筛选 元素的另一种角度, 结合选择器操作可以更好的互补</li>
</ul>
<ul>
<li><blockquote>
<p><code>find(selector )</code>  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。</p>
<p><code>.filter()</code> 它除了以上参数,可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中</p>
</blockquote>
</li>
<li><blockquote>
<p><code>next([selector ]) nextAll()</code> 获得匹配元素集合后面同级的所有元素 ,…all() 返回结果都不包含自己,       </p>
<p> 对应方法: <code>.prev()和.prevAll()</code></p>
<p><em>如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。</em></p>
<p><code>.siblings()</code>  能够选择处于相同DOM层次的所有其他元素</p>
</blockquote>
</li>
<li><blockquote>
<p><code>.parent( [selector ] )  </code> 取得匹配元素集合中，每个元素的父元素</p>
<p><code>.children([selector ]) </code>   获得匹配元素集合中每个元素的子元素, 返回结果只包含子元素不包括后代元素</p>
<p> <code>.contents()</code>  获得元素的子元素包括文字注释节点</p>
</blockquote>
</li>
<li><blockquote>
<p><code>each()方法</code> 就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次</p>
<p><code>end() </code>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.</p>
</blockquote>
</li>
<li><blockquote>
<p>jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]</p>
</blockquote>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="ready-事件处理程序"><a href="#ready-事件处理程序" class="headerlink" title=".ready()事件处理程序"></a>.ready()事件处理程序</h3><ul>
<li><p>通过使用$(document).ready()方法，jQuery支持我们预定在DOM加载完毕后调用某个函<br>数，而不必等待页面中的图像加载</p>
<blockquote>
<p>简写模式 : $(function(){})</p>
<p>不使用该方法也可以,但是ready()方法为我们提供了很好的跨浏览器解决方法</p>
</blockquote>
</li>
<li><p>jQuery提供了一个<code>jQuery.noConflict()</code>方法，把对$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,</p>
<blockquote>
<p>jQuery(document).ready(function($) {正常使用符号} )  </p>
<p>简写 : jQuery(function($){})  </p>
</blockquote>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li><p>在事件处理中常用内容:</p>
<blockquote>
<p><code>addClass()</code>  为每个匹配的元素添加指定的样式类名</p>
<p><code>hasClass()</code>   确定任何一个匹配元素是否有被分配给定的类,返回Boolean值</p>
<p><code>removeClass()</code>  移除集合中每个匹配元素上 一个，多个或全部样式</p>
<p><code>toggleClass(&quot;类名&quot;)</code> 能够根据相应的类是否存在而添加或删除类</p>
</blockquote>
</li>
</ul>
<pre><code><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">当触发任何事件处理程序时，关键字<span class="hljs-keyword">this</span>引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象<br><br><span class="hljs-keyword">is</span>() 判断是否为一个选择器 DOM元素...  例如:  .<span class="hljs-keyword">is</span>(<span class="hljs-string">&#x27;:hidden&#x27;</span>) 判断元素是否是可见的<br><br></code></pre></td></tr></table></figure></code></pre>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><ul>
<li><p><code>.on(&quot;click&quot;,fn)</code>   参数可以是函数引用或者匿名函数, 还可以用事件名函数绑定  例如.click()  .change()</p>
<blockquote>
<p>on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jQuery隐式迭代机制</p>
</blockquote>
</li>
<li><p><code>.one()   </code>处理函数在每个元素上每种事件类型最多执行一次,然后删除自己</p>
</li>
<li><blockquote>
<p><code>trigger()</code>  一次模拟事件的触发  </p>
<p><code>triggerHandler()</code> 与 .trigger() 相似,不会触发默认行为,不会事件冒泡, 只会对匹配到的第一个元素生效 </p>
</blockquote>
</li>
<li><p>早期版本使用 <code>bind()</code> 进行事件绑定</p>
<h5 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h5></li>
<li><p><code>.off(&quot;事件名&quot;)</code>方法移除</p>
</li>
<li><p>对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.</p>
<blockquote>
<p>例如:  .on(‘click.collapse’,fn);  .off(‘click.collapse’); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的</p>
</blockquote>
</li>
</ul>
<h5 id="事件传播-冒泡"><a href="#事件传播-冒泡" class="headerlink" title="事件传播(冒泡)"></a>事件传播(冒泡)</h5><ul>
<li><p>DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,</p>
</li>
<li><p>jQuery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。</p>
</li>
<li><p>避免事件传播的事件处理</p>
<blockquote>
<p><code>hover(fn,fn)</code>函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播<br><code>mouseenter()和mouseleave()</code>，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。</p>
</blockquote>
</li>
<li><p>事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡</p>
</li>
</ul>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><ul>
<li><p>jQuery对事件对象进行了必要的扩展，从而在任何浏览器中都能够使用这个属性,jQuery提升了兼容性</p>
</li>
<li><p>如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false</p>
<blockquote>
<p>对于Dom 中 返回 false 只是阻止默认行为</p>
</blockquote>
</li>
</ul>
<h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><ul>
<li>某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素</li>
</ul>
<h2 id="样式与动画"><a href="#样式与动画" class="headerlink" title="样式与动画"></a>样式与动画</h2><h3 id="CSS属性操作"><a href="#CSS属性操作" class="headerlink" title="CSS属性操作"></a>CSS属性操作</h3><ul>
<li><p>.CSS()方法,用来获取计算后的样式,设置内联样式.</p>
<blockquote>
<p><code>获取</code>使用:<br>单个样式属性   传递一个<strong>字符串形式</strong>的属性名，获取字符串形式的属性值,<br>多个样式属性   可以传入属性名的<strong>数组</strong>，得到的则是属性和值构成的对象,对于属性名的格式,可以是驼峰命名或者连字符  </p>
</blockquote>
<blockquote>
<p><code>设置</code>使用:<br>CSS()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值</p>
<p>另一种是为它传递一个由属性—值对构成的对象</p>
</blockquote>
</li>
<li><p>浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性</p>
</li>
</ul>
<h3 id="效果和时长"><a href="#效果和时长" class="headerlink" title="效果和时长"></a>效果和时长</h3><ul>
<li><p>隐藏/显示元素:  <code>.hide() .show()</code>   相当于设置display的值   默认是不带动画效果的.</p>
<blockquote>
<p>.hide()方法会将匹配的元素集合的内联style属性设置为 display:none。</p>
<p>但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局</p>
</blockquote>
</li>
<li><p>带动画效果: .hide(‘duration’)   duration:毫秒级   </p>
<blockquote>
<p>动画效果-&gt;会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,<br>动画效果有两种预设的速度参数：’slow’和’fast’。也可以自定义指定显示速度. 以下动画效果都可以适用</p>
</blockquote>
</li>
<li><p>淡入和淡出, <code>fadeIn(),fadeOut()</code>  :</p>
<blockquote>
<p>改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。</p>
</blockquote>
</li>
<li><p>滑入和滑下, <code>slideDown()和.slideUp() :</code>  改变高度和display的值  </p>
<blockquote>
<p>元素本来就处在文档流中,适合使用滑入滑出</p>
</blockquote>
</li>
<li><p>复合效果方法,  <code>slideToggle()</code> ,动画和<code>slideDown(),slideUp()</code>一样   </p>
<blockquote>
<p>toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见</p>
</blockquote>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3></li>
<li><p>.animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式</p>
<blockquote>
<p>第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:</p>
<p><code>.animate(&#123;property1: &#39;value1&#39;, property2: &#39;value2&#39;&#125;, duration, easing, function() &#123;&#125;)</code></p>
<p>第二种形式接受两个参数，一个属性对象和一个选项对象:</p>
<p><code>.animate(&#123; property1: &#39;value1&#39;, property2: &#39;value2&#39; &#125;, </code></p>
<p><code>&#123; duration: &#39;value&#39;, easing: &#39;value&#39;,</code></p>
<p><code>specialEasing: &#123; property1: &#39;easing1&#39;, property2: &#39;easing2&#39; &#125;, </code></p>
<p><code>complete: function() &#123;&#125;, queue: true, step: callback &#125;);</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>animate()方法最少要有两个参数,属性对象和duration</p>
<blockquote>
<p>.animate()方法针对CSS属性提供了方便简写值：<code>&#39;show&#39;、&#39;hide&#39;和&#39;toggle&#39;</code></p>
<p>例如 : .animate({height: ‘toggle’}, ‘slow’);</p>
</blockquote>
</li>
<li><p>animate()方法中,属性对象中的值如果是 {“height” :”+=value” }表示在原来的基础上再加上value,而不是变化到value</p>
<h5 id="并发与排队"><a href="#并发与排队" class="headerlink" title="并发与排队"></a>并发与排队</h5></li>
<li><p>同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.</p>
<blockquote>
<p>需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式</p>
</blockquote>
</li>
<li><p>想要同时触发效果,要在一个方法内写多个属性</p>
</li>
</ul>
<ul>
<li><p>多个元素,应用效果时,这些效果会同时发生,</p>
<blockquote>
<p>为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数</p>
<p>$clickedItem.next().slideDown(‘slow’, function() { $clickedItem.slideUp(‘slow’); }); 先执行外层,在执行回调函数</p>
</blockquote>
</li>
</ul>
<h5 id="越过队列"><a href="#越过队列" class="headerlink" title="越过队列"></a>越过队列</h5><ul>
<li>第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始</li>
<li>对于非效果方法,如.CSS()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序<blockquote>
<p>解决方法</p>
<p>1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({background Color:’#f00’});next();}) </p>
<p>传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>2:利用效果方法中的回调函数,在回调函数中书写.CSS(), 在外层函数完成时执行CSS,不需要调用next()</p>
</blockquote>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><h5 id="HTML-特性操作"><a href="#HTML-特性操作" class="headerlink" title="HTML 特性操作"></a>HTML 特性操作</h5><ul>
<li><p><code>.attr()</code> 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值</p>
</li>
<li><p><code>.removeAttr()方法</code>  删除<em>一个</em>属性</p>
<blockquote>
<p>可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:</p>
<ul>
<li><pre><code>$(&#39;div.chapter a&#39;).attr(&#123;  
title: &#39;Learn more at Wikipedia&#39;,
id: function(index, oldValue)
&#123; return &#39;wikilink-&#39; + index; &#125;
&#125;);
这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用</code></pre>
</li>
</ul>
</blockquote>
<h5 id="DOM-属性"><a href="#DOM-属性" class="headerlink" title="DOM 属性"></a>DOM 属性</h5></li>
<li><p>在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同</p>
</li>
<li><blockquote>
<p>从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。</p>
</blockquote>
</li>
<li><p>DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性</p>
<blockquote>
<p>差别最大的地方是表单控件的属性,不要使用attr(),要使用Val() 获取/设置属性 </p>
<p> 或者是prop操作DOM属性(这个是要分情况的)</p>
</blockquote>
</li>
<li><p>与.attr()和.prop()一样，.val()方法也可以接受一个函数作为其setter参数</p>
</li>
</ul>
<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul>
<li><p>创建节点 :  使用$(“”)函数创建节点</p>
</li>
<li><p>插入(添加) / 移动节点: </p>
<blockquote>
<p><code>内容.insertBefore(&quot;目标&quot;)</code> 在现有元素外部、之前添加内容；</p>
<p><code>.insertAfter() </code>在现有元素外部、之后添加内容。</p>
<p><code>.prependTo() </code>  在现有元素内部、之前添加内容；<br><code>.appendTo() </code>     在现有元素内部、之后添加内容；<br>使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了<br>在隐式迭代添加多个节点时,插入顺序<strong>预定义</strong>的,不管是after before,从上到下顺序都是迭代顺序</p>
</blockquote>
</li>
<li><p>反向插入方法 :内容目标的位置颠倒,名字更换了一下</p>
<blockquote>
<p><code>append()  prepend()   before()   after()</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>包裹节点</p>
<blockquote>
<p>被包裹的节点 <code>.wrap(&quot;节点&quot;) .wrapAll(&quot;节点&quot;)</code><br>区别:后者在多个节点时,只包裹一次(最外面的节点), 而wrap每个节点都会包装一次</p>
<p><code>wrapInner()</code>包裹匹配元素的子元素</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>复制节点</p>
<blockquote>
<p><code>.clone()</code>  在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件</p>
<p>通过 clone(true) 复制事件处理函数</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>删除节点 </p>
<blockquote>
<p>从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件</p>
<p><code>remove(),detach()</code>  两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null </p>
<p>两者区别: 使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除</p>
</blockquote>
</li>
<li><p><code> empty()</code> 清空节点里的内容(文本 元素节点),</p>
<blockquote>
<p><em>注意是节点里的,不是节点本身</em> , 返回一个已经清空的元素</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>替换节点(文本/元素)</p>
<blockquote>
<p>.html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容</p>
<p>.text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本<br>.replaceAll(“目标”) 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动<br>.replaceWith(“内容”)   替换集合中所有匹配的元素,返回被删除元素的集合</p>
</blockquote>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h5 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h5><ul>
<li><p>jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。</p>
<pre><code>  &gt; `.ajaxStart()和.ajaxStop()`方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个
  &gt; 当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数 
  &gt; 当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.</code></pre>
</li>
<li><p>错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 </p>
<h5 id="ajax中的常见问题"><a href="#ajax中的常见问题" class="headerlink" title="ajax中的常见问题"></a>ajax中的常见问题</h5></li>
<li><p>通过Ajax生成页面内容时的一个常见问题:事件绑定丢失</p>
<blockquote>
<p>事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。</p>
<p>解决方法: 每次页面内容更新重新绑定事件      使用事件委托</p>
</blockquote>
</li>
<li><p><code>$.ajaxSetup()</code> 函数可以修改调用Ajax方法时每个选项的默认值。之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，</p>
</li>
<li><p>取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式</p>
</li>
</ul>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><ul>
<li><p>添加新的全局函数, 即jQuery对象的方法</p>
<blockquote>
<p><code>$.funcname = func()   </code></p>
<p><code>$.extend(&#123;funcame:func()&#123;&#125;&#125;)</code></p>
<p>添加全局函数</p>
<p>为了避免冲突，最好的办法是把属于一个插件的全局函数都封装到一个对象中</p>
</blockquote>
</li>
<li><p>扩展jQuery对象的方法</p>
<blockquote>
<p><code> jQuery.fn.myMethod = function()&#123;&#125;</code> </p>
<p> jQuery.fn对象是jQuery.prototype的别名</p>
</blockquote>
</li>
<li><p>开发插件注意的问题</p>
<blockquote>
<ul>
<li><p>考虑方法的隐式迭代问题 :  jQuery的选择符表达式可能会匹配零、一或多个元素,</p>
<blockquote>
<p>调用.each()方法；这样就会执行隐式迭代 (在调用的.each()方法内部，this依次引用每个DOM元素)</p>
</blockquote>
</li>
<li><p>考虑方法的连缀问题:  函数的返回值要是一个jQuery对象</p>
</li>
<li><p>默认参数值, 灵活的参数(传递对象参数) , </p>
</li>
</ul>
</blockquote>
</li>
<li><p>利用QUnit等测试框架为自己的插件维护一组自动的单元测试</p>
</li>
</ul>
<h2 id="jQuery进阶内容"><a href="#jQuery进阶内容" class="headerlink" title="jQuery进阶内容"></a>jQuery进阶内容</h2><h5 id="高级遍历"><a href="#高级遍历" class="headerlink" title="高级遍历"></a>高级遍历</h5><ul>
<li><p>Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。</p>
<blockquote>
<p>使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异</p>
</blockquote>
</li>
<li><p>选择符优化问题 自定义选择符</p>
<blockquote>
<p>如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器</p>
</blockquote>
</li>
<li><p>DOM遍历背后的原理</p>
<blockquote>
<p>向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关</p>
<p>addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑</p>
</blockquote>
</li>
</ul>
<ul>
<li>DOM 遍历的性能问题 : 多使用连缀,和缓存jQuery对象,来最低限度的重复使用选择符和遍历方法</li>
</ul>
<h5 id="高级事件处理"><a href="#高级事件处理" class="headerlink" title="高级事件处理"></a>高级事件处理</h5><ul>
<li><p>早委托 : 选择document作为委托作用域,不必等待Dom完全加载后才进行绑定事件, 通过早委托实现早绑定</p>
</li>
<li><p>自定义事件: 通过 on()注册自定义事件, 使用trigger方法进行手动调用, 它只能手动调用</p>
<blockquote>
<p>在触发自定义事件时，我们也可以给任何注册的事件处理程序传入额外的信息。这种技术就叫做自定义事件参数, 在trigger调用处理程序时传入参数</p>
</blockquote>
</li>
<li><p>节流事件: 浏览器中有几个原生事件都会频繁触发。最常见的事件有scroll、resize和mousemove。为了解决这个问题，就需要节流事件</p>
<blockquote>
<p> 这个技术会限制一些无谓的计算，即不是每次事件发生都计算</p>
<ol>
<li>通过定时器,函数的调用只会在计时器结束时调用, 那么多次触发事件只有一次调用</li>
<li>通过定时器进行轮询检查,调用函数</li>
</ol>
</blockquote>
</li>
<li><p>在频繁重复的事件发生期间限制处理次数的第三种技术叫消除抖动</p>
</li>
<li><p>扩展事件: 利用这些事件扩展API，可以创建出与原生DOM事件非常类似的新事件。具备默认行为….</p>
</li>
</ul>
<h5 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h5><ul>
<li><p>如果在两次事件发生后调用动画, 如果时间很多的情况下,那么图像会在最后一次事件出发后反复的运行动画</p>
<blockquote>
<p>原因: 元素的动画逐一的添加进队列,它会依次运行直到队列为空</p>
</blockquote>
</li>
<li><p>使用jQuery自定义的<code>:animated</code>, is(‘:animated’)判断是否在动画中,但是还不够,还需要<strong>终止运行中的动画</strong></p>
<blockquote>
<p><code>.stop()</code>，它能在动画运行过程中让动画立即停止。这里的关键是在处理新动画之前先停止当前动画, .stop()方法可以接收两个布尔值,第二个参数 <code>gotoend</code></p>
<p><code>.finish() </code>  清除队列中的动画,并使当前动画跳转到最终值,和.stop(true,true)相似</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在1.7之前版本中,   在动画之前，这些简写的动画方法(<strong>slidedown fadein..</strong>.)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。</p>
</blockquote>
<ul>
<li><p>全局效果属性 :<code>$.fx</code>对象  </p>
<blockquote>
<p>禁用所有动画效果  <code>$.fx.off=true;</code><br>定义效果时长 <code>$.fx.speeds= ...  </code>可以改变预设值的效果速度,可以自定义一个速度选项</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>多属性缓动  </p>
<blockquote>
<p>通过动画方法中,<code>specialEasing</code>选项可以为每个要应用动画的属性设置不同的加速度曲线。 默认的是 swing函数</p>
</blockquote>
</li>
<li><p>延迟对象(promise)</p>
<blockquote>
<p>每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。</p>
</blockquote>
<blockquote>
<p>通过在jQuery对象上调用.promise()方法,获得延迟对象</p>
<p><code>.done()</code>方法添加的处理程序会在延迟对象被成功解决之后调用。<br><code> .fail()</code>方法添加的处理程序会在延迟对象被拒绝之后调用。<br><code> .always()</code>方法添加的处理程序会在延迟对象完成其任务（无论解决或拒绝）时<br> 调用。</p>
</blockquote>
</li>
<li><blockquote>
<p>通过延迟对象可以使动画在某个操作结束后调用函数, 取代了回调函数</p>
</blockquote>
</li>
<li><p>.animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  </p>
<blockquote>
<p>jQuery动画系统最底层的方法是$.Animation()和$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面</p>
</blockquote>
</li>
</ul>
<hr>
<p>本文档参考                   &lt;  jQuery 基础教程第四版  2020 6.30 &gt;</p>

            </div>
            <div><a href="https://github.com/thinkles/thinkles.github.io/blob/myblog/source/_posts/Md jQuery/JQuery  指导.md" target="_blank">编辑</a></div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/jQuery/">jQuery</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/jQuery%E5%9F%BA%E7%A1%80/">jQuery基础</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/21/Md%20jQuery/jquery%20%E6%8B%BE%E5%BF%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">jQuery API</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/21/Md%20HTML5/HTML%E8%A1%A8%E5%8D%95/">
                        <span class="hidden-mobile">HTML表单</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'thinkles/Utterances-comment-blog');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
