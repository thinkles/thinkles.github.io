<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>路由</title>
    <link href="/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><ul><li><p>Web 最基本的功能是允许用户从一个页面导航到另一个页面 ，毕竟它是一个相互关联的文档网络。当您点击此网站上的链接时，您的浏览器会与服务器通信，并获取要显示的新内容。因此，地址栏中的 URL 会发生变化。您可以保存此新 URL，稍后返回该页面，或与他人共享，以便他们轻松找到同一页面。您的浏览器会记住您的导航历史记录，并允许您来回导航。这称为<strong>服务器端路由</strong>。</p></li><li><p>现代 Web 应用程序通常不提取和呈现新的 HTML 文件 - 它们加载单个 HTML 外壳，并不断更新其内部的 DOM（称为<strong>单页应用程序</strong>或<strong>SCA），</strong>而无需将用户导航到 Web 上的新地址。每个新的伪网页通常称为<em>视图</em>，默认情况下，不进行路由。但是当 SPA 足够复杂可以呈现很多视图的情况下，将路由功能引入应用程序非常重要。人们习惯于能够链接到应用程序中的特定页面，在导航历史记录中向前和向后旅行等，当这些标准 Web 功能被破坏时，他们的经验会受到影响。当路由由客户端应用程序以这种方式处理时，它恰如其分<strong>地称为客户端路由</strong>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发overview</title>
    <link href="/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/Web%E5%BC%80%E5%8F%91overview/"/>
    <url>/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/Web%E5%BC%80%E5%8F%91overview/</url>
    
    <content type="html"><![CDATA[<h3 id="web开发工具系统"><a href="#web开发工具系统" class="headerlink" title="web开发工具系统"></a>web开发工具系统</h3><ul><li><p>从高层次来看，客户端工具分为三大类</p><blockquote><p>前期开发工具—-开发期间的工具</p><p>后期开发工具 —- 开发后的工具, 如测试和部署工具</p><p>转换工具 —  转换语言,以便更好的开发</p></blockquote></li></ul><ul><li><p><strong>前期开发工具</strong></p></li><li><p>帮助你更容易生成稳定可靠的代码的任何内容。</p></li><li><p>Linters 是检查您的代码并告诉您存在任何错误的工具  例如 eslint csslint…通常linters 包括指定编程样式的功能</p></li><li><p>对于代码检测工具来说,有几种方法使用他们 :</p><blockquote><p>在npm安装后 调用内置的命令行</p><p>在编辑代码阶段 在VScode安装插件 </p><p>在git hook 运行小脚本使用 代码检测工具</p></blockquote></li><li><p>代码格式化工具: prettier </p></li><li><p>源代码控制</p><blockquote><p>也称为版本控制系统(VCS)，源代码控制对于备份工作和在团队中工作至关重要。Git 是现在大多数人使用的源代码控制系统</p></blockquote></li><li><p>打包工具</p><blockquote><p>这些工具让你的代码准备生产,例如，通过tree-shaking来确保只有实际使用的代码库的部分被放到最终的生产代码中,或“缩减”删除所有空格在生产代码中,使其尽可能小之前上传到服务器。</p><p>例如: Parcel   Webpack  rollup</p></blockquote></li><li><p><strong>转换工具:</strong></p></li><li><blockquote><p>使用语言的新特性,但是这些特性可能还没有得到浏览器的本地支持，或者完全使用另一种语言编写代码，(例如 TypeScript. 转换工具将为您生成与浏览器兼容的代码)</p></blockquote></li></ul><ol><li><p>能够使用最新的语言特性编写代码，并将其转换为可在日常设备上使用的代码。</p><blockquote><p>Babel:一个JavaScript编译器，允许开发人员使用最前沿的JavaScript编写代码，然后Babel将其转换为老式的JavaScript，</p><p>PostCSS:和Babel做同样的事情，但是有先进的CSS特性</p></blockquote></li><li><p>选择用一种完全不同的语言编写代码，并将其转换为与web兼容的语言</p><blockquote><p>Sass 这个CSS扩展允许您使用变量、嵌套规则、混合、函数和许多其他特性</p><p>TypeScript:是JavaScript的一个超集，它提供了一堆额外的特性。</p><p>VUE React 通过自定义语法开发</p></blockquote></li></ol><ul><li><p><strong>后期开发工具:</strong></p></li><li><blockquote><p>开发后阶段工具可以确保您的软件能够访问web并继续运行。这包括部署流程、测试框架、审计工具等等。</p></blockquote></li><li><p>测试工具:</p><blockquote><p>框架包括编写测试Jest, Mocha, 和 .</p><p>自动测试运行和通知系统包括Travis CI, Jenkins, Circle CI, 和 others.</p></blockquote></li><li><p>配置工具:</p><blockquote><p>配置系统允许您发布网站，可用于静态和动态站点，通常与测试系统一起工作。</p><p>Netlify 是目前最流行的部署工具之一，但其他包括Vercel 和 Github Pages.</p></blockquote></li><li><p>其他:</p><blockquote><p>包括 Code Climate 对于收集代码质量度量， webhint browser extension 用于执行跨浏览器兼容性的运行时分析和其他检查, Github bots 提供更强大的GitHub功能, Updown 提供应用程序运行时间监控等等。</p></blockquote></li></ul><h3 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h3><ul><li><p>基本的内置终端命令</p></li><li><p>导航计算机的文件系统以及基本级别的任务，如创建、复制、重命名和删除</p><blockquote><p>移动您的目录结构 : <code>cd</code></p><p>建立目录: <code>mkdir</code></p><p>创建文件（修改他们的原数据）: <code>touch</code></p><p>复制文件: <code>cp</code></p><p>移动文件: <code>mv</code></p><p>删除文件或目录: <code>rm</code></p><p>下载在特定的 url 找到的文件: <code>curl</code></p><p>在较大的文件体中寻找特定的片段: <code>grep</code></p><p>主页查看文件的内容: <code>less</code>, <code>cat</code></p><p>操作和转换文本流（例如，讲 HTML 文件中 <div> 的所有实例改为 &lt; article&gt;）: <code>awk</code>, <code>tr</code>, <code>sed</code></p></blockquote></li></ul><ul><li><p>所有的操作系统(假设是默认设置) 都将在您的 “home” 目录中启动它们的终端程序，从那里您可能想要移动到另一个地方。</p><blockquote><p>一个非常有用的终端快捷方式是使用 tab 键自动完成你知道的名字，而不是必须键入整个东西。</p></blockquote></li><li><p>请注意，在路径上包含一个前斜线将使路径成为绝对路径 <code>/Users/your-user-name/Desktop</code>. 像我们上面做的那样，省略前导斜杠可以使路径相对于当前的工作目录。</p><blockquote><p>这与您在 web 浏览器中看到的 url 完全相同。前面的斜杠意味着 “在网站的根”，而省略斜杠意味着 “这个 URL 是相对于我当前页面的”。</p></blockquote></li><li><p>在 windows 中，你使用反斜杠而不是正斜杠。<code>cd Desktop\project\src</code></p></li></ul><ul><li><p>另一个内置的 Unix 命令是 ls (list 的缩写)，它列出当前所在目录的内容。注意，这不会工作，如果你使用默认的 Windows 命令提示符 (cmd)，相当于 dir。</p></li><li><p>大多数终端命令都有选项，这些选项是您添加到命令末尾的修饰符，它们使命令的行为略有不同。它们通常由命令名后的空格、后接破折号、后接一个或多个字母组成。</p><blockquote><p>确切地了解每个命令有哪些可用选项，您可以查看它 <a href="https://en.wikipedia.org/wiki/Man_page">man page</a>. 通过键入 <code>man</code> 命令，后跟要查找的命令的名称，例如<code>man ls</code></p></blockquote><blockquote><p><code>mkdir</code> —这将在您所在的当前目录中创建一个新目录，名称是您在命令名之后提供的。</p><p>例如<code>mkdir my-awesome-website将创建一个新目录叫``my-awesome-website</code>.</p></blockquote><blockquote><p><code>rmdir</code> —删除指定目录，但仅当它为空时。例如<code>rmdir my-awesome-website</code></p><p>将删除我们在上面创建的目录。如果您希望删除一个非空的目录 (并删除其中包含的所有内容)，则可以使用<code>-r</code> 选项（递归），但这很危险。 确保以后在目录中不需要任何内容，因为它将永远消失。</p></blockquote><blockquote><p><code>touch</code> —在当前目录中创建一个新的空文件 &gt;</p></blockquote><blockquote><p>许多终端命令允许您使用星号作为 “通配符” 字符，意思是“任何字符序列”。这允许您一次对可能大量的文件运行操作，所有这些文件都匹配指定的模式。作为一个例子, <code>rm mdn-*</code> 将删除所有文件开头<code>mdn-</code>. <code>rm mdn-*.bak</code> 会删除所有文件的开头<code>mdn-</code> 结束 <code>.bak</code>.</p><p><code>cp</code> — 类似于 <code>mv</code>, <code>cp</code>在指定的第一个位置和第二个位置创建文件的副本。</p><p><code>rm</code> —删除指定的文件</p></blockquote></li></ul><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><ul><li><p><strong>项目中的依赖项</strong></p><blockquote><p>是软件的第三方位，可能是由其他人编写的，理想情况下可以为您解决单个问题。</p><p>项目依赖项可以是一个完整的 JavaScript 库或框架 (如 React 或 Vue) ，也可以是一个非常小的实用程序 (如人类可读的日期库) ，或者是一个命令行工具 (如 Prettier 或 eslint) ，</p></blockquote></li><li><p><strong>为什么需要现代构建工具:</strong></p></li><li><p>如果没有现代的构建工具，像这样的依赖关系可能会使用一个简单的 <script> 元素包含在项目中，但是这可能不会立即生效，当代码和依赖关系在 web 上发布时，你可能需要一些现代的工具来将它们捆绑在一起。</p><blockquote><p>捆绑包通常用于指  Web 服务器上的一个<code>单个文件</code> 这个文件包含网页所需所有的JS代码 ,通常尽可能压缩，以帮助减少下载软件并在访问者浏览器中显示的时间</p></blockquote></li><li><p><strong>为什么需要包管理器:</strong> </p></li><li><p>如果您找到了一个更好的工具来代替当前的工具，或者您想要更新的依赖关系的新版本被释放了，对于一些依赖关系来说，这并不是太痛苦，但是对于有很多依赖关系的大型项目来说，跟踪这类事情确实很有挑战性。</p></li><li><p>包管理工具,将保证代码被完整地添加和删除，同时还有许多其他优点。</p></li></ul><ul><li><p>包管理器(npm yarn), 是一个管理项目依赖关系的系统。</p><blockquote><p>包管理器将提供一种方法来安装新的依赖项 (也称为 “包”) ，管理包在文件系统中的存储位置，并为您提供发布自己的包的功能</p></blockquote></li><li><p>理论上，您可能不需要包管理器，您可以手动下载和存储项目依赖项，但是包管理器将无缝地处理安装和卸载包。如果你没有使用，你必须手动处理</p><blockquote><p>手动处理的话有几点: </p><ol><li>需要手动的去找到所有的依赖项,把他们加到项目中,检查依赖项有没有错误, </li><li>如果依赖项还有子依赖项,那么手动的寻找子依赖项 </li><li>可能还需要去编写 模块代码去引入 依赖项</li><li> 删除依赖项的情况 和 重复引入的情况都会使开发更加的困难</li></ol></blockquote></li></ul><ul><li><p>对于 npm (以及基于 JavaScript 和基于 node 的包管理器) ，安装依赖项的位置有两个选项。正如我们在前一篇文章中提到的，依赖项可以全局安装，也可以本地安装。</p><blockquote><p>在本地安装的优点更为重要，比如代码可移植性和版本锁定。</p></blockquote></li></ul><ul><li><p>Package registries 包注册表</p><blockquote><p>对于一个软件包管理器，它需要知道从哪里安装软件包，这是一个软件包注册表的形式。</p><p>注册表是发布包的中心位置，因此可以从中安装。Npm 不仅是一个包管理器，还是 JavaScript 包最常用的包注册表的名称。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发 overview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/webpack/"/>
    <url>/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul><li><p><strong>为什么使用构建工具?</strong></p><blockquote><p>前端模块要在客户端(浏览器)中执行，所以他们需要增量加载到浏览器中。</p><p>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次</p><p>但是两种方法都不是最佳的, 所以我们采用<strong>分块传输</strong>，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案,要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。</p></blockquote></li><li><p>在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源,如果他们都可以视作模块，并且都可以通过<code>require</code>的方式来加载，将带来优雅的开发体验</p></li><li><p>构建工具 还可以帮助我们处理各种项目的依赖项, 优化打包后的文件…</p></li></ul><p><strong>Webpack的重要概念:</strong></p><ul><li><p><a href="https://webpack.docschina.org/glossary/">webpack 术语表</a></p></li><li><p>依赖图: 当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 <a href="https://webpack.docschina.org/concepts/entry-points/"><em>入口</em></a> 开始，webpack 会递归的构建一个<em>依赖关系图</em>，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 <em>bundle</em> —— 通常只有一个 —— 可由浏览器加载。</p></li><li><p>loader : Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p></li><li><p>plugin : 插件目的在于解决 loader 无法实现的<strong>其他事</strong>。</p></li><li><p>runtime  : 在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。</p></li><li><p>manifest : 是保留所有模块要点的数据集合, runtime 会通过 manifest 来解析和加载模块, 通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。</p><blockquote><p>通过使用内容散列(content hash)作为 bundle 文件的名称，这样在文件内容修改时，会计算出新的 hash，浏览器会使用新的名称加载文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。即使某些内容明显没有修改，某些 hash 还是会改变。这是因为，注入的 runtime 和 manifest 在每次构建后都会发生变化。</p></blockquote></li><li><p>模块热替换: 在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面</p><blockquote><ul><li>保留在完全重新加载页面期间丢失的应用程序状态。</li><li>只更新变更内容，以节省宝贵的开发时间。</li><li>在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ul></blockquote></li><li><p><code>style-loader</code> 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。 类似的也可以在模块中实现 HRM接口, 用来模块更新后调用该函数</p></li></ul><h4 id="webpack简单使用"><a href="#webpack简单使用" class="headerlink" title="webpack简单使用"></a>webpack简单使用</h4><ul><li><p>安装 <code>webpack-cli/init </code>工具 (可选), 也可以手动创建 webpack 的config文件</p><blockquote><p>也可以利用 webpage  vscode插件</p></blockquote></li><li><p>自定义<code> packge.json</code> 文件中的 编译命令 ,  运行该命令</p><blockquote><p>注意:  <code>npx webpack</code>  默认寻找webpack.config.js 文件 也可以自定义</p><p><code>npx webpack --config webpack.config.js</code></p></blockquote><blockquote><p>也可以使用 webpack-cli 命令进行零配置的编译</p></blockquote></li><li><p>加载 CSS/Scss.. 媒体资源(CSS中的图像 字体)</p><blockquote><p>下载相应的loader配置(style-loader+css-loader 是基础 还有sass-loader.. ), 然后就可以使用import 像模块一样加载CSS</p><p>加载CSS中的媒体资源:  webpack5 使用内置的 <a href="https://webpack.docschina.org/guides/asset-modules/">Asset Modules</a>  进行加载, 5之前使用相应的loader进行加载 例如: url-loader file-loader ..</p><p>对于html中的 媒体资源 使用 html-loader 处理 否则打包后找不到资源</p></blockquote><blockquote><p>以上方法打包后的图片路径都是针对本机的绝对路径,如果部署到线上是不行的,所以通过output 中的 publicpath 属性设置路径</p></blockquote></li><li><blockquote><p>加载数据 csv 文件 tsv xml 需要相应的loader</p></blockquote></li><li><p>输出管理</p><ul><li><p>打包文件输出: </p><blockquote><p>单入口的情况下, 正常的进行打包就可以了</p><p>多入口时,打包后出现多个bundle, 使用<code>HtmlWebpackPlugin</code> 自动的添加多个 bundle</p></blockquote></li><li><p>输出目录的清理:</p><blockquote><p> 每次构建时可能会遗留一些多余的代码文件,使用插件<code>clean-webpack-plugin</code>    </p></blockquote></li></ul></li><li><p>开发配置:</p><ul><li><p><strong>source map:</strong></p><blockquote><p>将多个源文件打包为一个文件时为了追踪错误信息, 需要配置 <a href="http://blog.teamtreehouse.com/introduction-source-maps">source maps</a>  </p></blockquote></li><li><p>热更新:</p><blockquote><p><code>watch</code>:自动重新编译更改的对象,  或者<code>webpack-dev-server</code>  :开启热更新, 配置dev server,从什么位置查找文件</p></blockquote></li></ul><blockquote><p>在开发设置中 <code>CleanWebpackPlugin</code> 插件会产生很多冲突, 原因在于, 该插件会在成功构建 build 后(包括编译),删除输出目录的文件.</p><p>导致 watch 模式下, 构建成功后,更改编译后, 静态资源 :html文件 和 图片.. 都被删除 <code>解决</code>:    cleanStaleWebpackAssets: false 更改该插件选项</p><p>在 dev Serve 模式下, 成功构建向内存 写文件而不是硬盘,导致该插件清空了dist目录</p><p><code>解决</code>: 调整 dev Serve 插件的选项 让其构建成功后使文件写入硬盘, 还有设置 cleanStaleWebpackAssets选项, 让其在热更新编译时不会删除静态文件</p></blockquote></li><li><blockquote><p>建议在最后构建的时候再进行清除 使用CleanWebpackPlugin,否则会很多冲突</p></blockquote><p>​    </p><ul><li><code>EslintWebpackPlugin</code>  插件带来eslint 功能  <code>Prettier Webpack Plugin</code> 带来 `Prettier 功能</li><li>babel</li></ul></li></ul><h4 id="预处理器loader"><a href="#预处理器loader" class="headerlink" title="预处理器loader"></a>预处理器loader</h4><ul><li><p>在引入loader时,可以通过options 提供额外的配置</p></li><li><p>loader 相关配置</p><blockquote><p>exclude  : 排除被正则匹配到的该模块  </p><p>必加项 : exclude: /node_modules/, 或者 include : /src/ </p><p>exclude 和 include  exclude 优先级更高</p><p>resource issuer : 可以更加精确的确定模块规则的作用范围</p><p>resource: 被加载模块   issuer:加载者</p></blockquote></li><li><p>URL-loader  file-loader 的区别:</p><blockquote><p>url-loader 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。  url-loader内置了file-loader ,只需要安装一个即可</p><p> limit : true  无限制</p></blockquote></li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ul><li><p>手动编译文件很麻烦 , webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码：</p><blockquote><p>webpack watch mode</p><p>webpack-dev-server  </p><p>webpack-dev-middleware</p></blockquote></li><li><p>webpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。 webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。</p></li><li><p><strong>webpack-dev-server:</strong></p><blockquote><p>服务启动时, <code>wds</code>进行模块打包, 当浏览器请求时,首先它先效验URL地址,</p><p>如果该地址是资源服务地址(指定的资源文件地址),就会从内存中寻找资源返回给服务器.  如果不是,就读取硬盘内的源文件返回给浏览器</p></blockquote></li><li><p>**webpack-dev-server 在编译打包之后不会写入到任何输出文件 ,**打包结果被放在了内存中而不是实际磁盘内。</p><blockquote><p>换句话说他不会生成新的文件,每次接到浏览器的请求,都只是将内存中的打包结果返回给浏览器</p></blockquote></li><li><p>‘WDS’参数说明:</p></li><li><blockquote><p><code>ContentBase</code>:    指定服务器资源的根目录,静态资源从该目录中找寻,默认使用和webpack-config.js 相同目录</p><p>PublicPath:    <em>如果你的页面希望在其他不同路径中找到 bundle 文件，则可以通过 dev server 配置中的</em> <a href="https://webpack.docschina.org/configuration/dev-server/#devserverpublicpath-"><code>publicPath</code></a> 选项进行修改。 默认为’/‘</p><p>不管 PublicPath 怎么设置, 通过路由查找文件时使用的路径都是<code>ContentBase</code> ,而且都是通过在硬盘文件中查找,而不是在内存中查找</p></blockquote></li><li><p><code>publicPath</code> 和 output <code>publicPath</code> 保持一致, 这样静态资源文件才可以请求到, 因为设置完  publicPath, 这个路径就代表了内存中的根目录</p></li></ul><ul><li><p>webpack-dev-server 的运行会进行构建,然后就调用了 <code>clean-webpack-plugin </code>来清空 dist目录下的文件, 通过设置webpack-dev-server 的 writetodisk 选项写入文件到硬盘解决</p></li><li><blockquote><p>clean-webpack-plugin  默认情况下，此插件将在每次成功构建时(包括编译时),删除输出目录所有的文件(包括asset), </p><p>如果想要在<strong>编译</strong>时不删除静态资源,使用  <code>cleanStaleWebpackAssets</code>  选项 设置为false, </p></blockquote></li></ul><ul><li><p><strong>资源加载:</strong></p></li><li><p>在 webpack 5 提供 资源模块类型 asset , 默认情况下，<code>asset/resource</code> 模块以 <code>[hash][ext][query]</code> 文件名发送到输出目录。</p><blockquote><p>可以通过在 webpack 配置中设置 <a href="https://webpack.docschina.org/configuration/output/#outputassetmodulefilename"><code>output.assetModuleFilename</code></a> 来修改此模板字符串.</p></blockquote></li><li><p><strong>自动管理输出</strong> : </p></li><li><blockquote><p><code>HtmlWebpackPlugin</code>  , html-webpack-插件将自动将所有必要的CSS、JS、清单和 favicon 文件注入到标记中</p></blockquote></li><li><p><strong>清理/dist 输出路径的文件夹</strong>,: <a href="https://www.npmjs.com/package/clean-webpack-plugin"><code>clean-webpack-plugin</code></a></p></li><li><p>源代码映射: 追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置 ,使用<code>source maps</code>功能</p></li></ul><ul><li><p><strong>webpack-dashboard 插件</strong>  :可以使控制台中打印的打包有关的信息以列表的形式提供,作为插件添加到webpack配置中,使用webpack-dashboard 模块命令替换原来的webpack启动方式即可</p></li><li><blockquote><p>speed-measure-webpack-plugin 可以分析出构建过程的时间, 可以找出构建过程中那个步骤最慢</p><p>size-plugin 每次打包后的体积和上次的体积变化值</p></blockquote></li></ul><ul><li><p><strong>热加载HMR</strong> :</p></li><li><p>模块热替换(<code>Hot Module Replacement</code>)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。</p></li><li><blockquote><p>不在进行刷新网页重新发送请求, HMR保留完全加载页面状态的前提下,只更新改动,不在进行刷新</p><p>原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。</p></blockquote></li><li><p><strong>手动引入HMR:</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &gt;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<br><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./print.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br> &gt;&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p><strong>模块热替换问题</strong> :    </p></li><li><p>借助于 <code>style-loader</code>，使用模块热替换来加载 CSS 实际上极其简单。此 loader 在幕后使用了 <code>module.hot.accept</code>，在 CSS 依赖模块更新之后，会将其 patch(修补) 到 <code>&lt;style&gt;</code> 标签中。</p></li><li><p>社区还提供许多其他 loader 和示例，可以使 HMR 与各种框架和库平滑地进行交互…… ,比如 vue-loader</p></li></ul><h4 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h4><ul><li><p>在生产环境下,我们希望样式存在于单独的css文件中, 而不是style标签内, 因为文件更有利于客户端缓存,  这时我们使用 mini-css-extract-plugin</p></li><li><blockquote><p> 样式的提取是以资源入口开始的整个chunk单位的封装, 如果index.js引入很多的模块,每个模块引入各自的样式, 但是最终只会生成一个css文件,因为只有一个入口</p><p>当有多个入口时,生成多个css文件,但是名字会重复,所以要使用[name].css 进行动态命名</p></blockquote></li><li><p>插件中可以指定同步加载的Css文件的文件名 filename  也可以指定异步加载的Css资源 chunkfileName 文件名</p><blockquote><p><code>filename</code> : 是主入口的文件名，<code>chunkFilename</code> 是非主入口的文件名</p><p>主入口 : 指的是<code>entry</code>里面生成出来的文件名</p><p>非主入口  :指的是按需加载（异步）模块,在entry没有名字</p><p>在打包时,同步加载的会被打包成一个 称为 initial chunk    默认main</p><p>异步 按需加载的会被打包为另一个包 称为 :non-initial chunk,默认使用唯一 ID 来替代名称</p></blockquote></li></ul><ul><li><p>想要在浏览器中查看CSS源码 需要给CSS-loader  SCSS-loader 单独配置source map选项</p></li><li><p> <code>module</code>，<code>chunk</code> 和 <code>bundle</code> 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：  我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p></li></ul><h4 id="代码分离-分片"><a href="#代码分离-分片" class="headerlink" title="代码分离(分片):"></a>代码分离(分片):</h4><ul><li><p> 能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p></li><li><p><strong>代码分离方法:</strong></p></li><li><ol><li>手动配置入口起点, 构建多个bundle 进行加载</li></ol><blockquote><p>这种方法不够灵活,必须手动的配置,</p><p>如果有重复的模块还是会加载检测不出来,导致冗余代码 </p></blockquote><ul><li><p>解决方法:</p><blockquote><p>方式一:  配置 <code>dependOn</code>选项,   把公共模块打包出来</p><p><code>optimization.runtimeChunk: </code> 选项 : 是否把runtime 代码打包出来, 配合缓存使用</p><p>方式二:  使用插件 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 可以将公共的依赖模块提取到已有的入口 chunk 中,或者提取到一个单独的chunk, 也需要 optimization.runtimeChunk 选项把runtime 代码分离出来</p></blockquote></li></ul></li><li><ol start="2"><li>动态导入模块</li></ol><blockquote><p>使用 es6 的 <code>import()</code> 动态导入代码  , 多个import导入只会引入一个,所以可以不使用代码分离插件了</p><p>使用webpack功能  <a href="https://webpack.docschina.org/api/module-methods/#requireensure"><code>require.ensure</code></a></p></blockquote><ul><li><p> import 动态引入:   </p></li><li><pre><code>import(&#39;lodash&#39;) .then((&#123; default: _ &#125;)=&gt;&#123;&#125;) // 需要 default参数值来获取模块对象，因为 webpack 4 在导入 CommonJS 模块时，将不再解析为 module.exports 的值<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  -</span> 由于 <span class="hljs-code">`import()`</span> 会返回一个 promise，因此它可以和 [<span class="hljs-code">`async`</span> 函数]一起使用<br><br><span class="hljs-bullet">  -</span> import() 实现原理就是动态生成script插入文档<br><br><span class="hljs-bullet">  -</span> 异步资源的chunk ,资源生成名字默认为数字 id, 我们可以通过特有注释来获取异步资源 chunk的name<br><br><span class="hljs-bullet">  -</span> &gt; import(/<span class="hljs-emphasis">*webpackChunkName :&quot;bar&quot;*</span>/  &#x27;./bar.js&#x27;) <br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; output&quot;&#123; chunkFilename: [name].js &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">- **懒加载:**</span><br><span class="hljs-code"></span><br><span class="hljs-code">  &gt; 手动的代码分离,从技术概念上确实实现了&#x27;懒加载&#x27;, 但是这个懒加载,会在每次加载页面自动加载, 而不是通过用户的交互进行加载(真正需要时加载)</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; 我们添加用户交互函数,  使用 import() 进行**懒加载**  </span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; 当调用 ES6 模块的 import() 方法（引入模块）时 必须指向模块的 `.default` 值, 因为他实际返回的是promise 处理后返回的module 对象</span><br><span class="hljs-code"></span><br><span class="hljs-code">  </span><br><span class="hljs-code"></span><br><span class="hljs-code">- 3. 预获取/预加载模块</span><br><span class="hljs-code"></span><br><span class="hljs-code">     &gt; 在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器：</span><br><span class="hljs-code">     &gt;</span><br><span class="hljs-code">     &gt; - **prefetch**(预获取)：将来某些导航下可能需要的资源</span><br><span class="hljs-code">     &gt; - **preload**(预加载)：当前导航下可能需要资源</span><br><span class="hljs-code">     &gt;</span><br><span class="hljs-code">     &gt; ```js</span><br><span class="hljs-code">     &gt; import(/* webpackPrefetch: true*/&#x27;./path/to/LoginModal.js&#x27;);</span><br><span class="hljs-code">     &gt; </span><br><span class="hljs-code">     &gt; // 这会生成 &lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt; 并追加到页面头部,指示着浏览器在闲置时间预取 login-modal-chunk.js 文件。</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ul><li><p><strong>代码分离插件:</strong></p></li><li><p><code>CommonsChunkPlugin</code> 插件 , (webpack4 之前的插件)</p><blockquote><p>一个CommonsChunkPlugin 只能提取一个vendor, </p><p>异步加载会出现错误, 提取runtime 的代码导致浏览器多加载资源, </p><p>wepback4之后被删除</p></blockquote></li><li><p><code>SplitChunks</code>  插件</p><blockquote><p><code>optimization.splitChunks</code>  开箱即用, 它的默认值可以参考<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">官网</a></p></blockquote></li><li><p>optimization.splitChunks 参数解释:</p><blockquote><p><code>chunks</code> :   async(默认值) 针对异步资源生效,  initial: 只对入口chunk生效, all:对所有的资源生效, 这意味着即使在异步和非异步块之间也可以共享块</p><p><code>minChunks </code>: 拆分之前, 公共模块被共享的最低次数</p><p><code>cacahGroups</code> :  分离chunks时的规则,一般有vendors 和default两种  :vendors 代表在 node_module的区块, default : 代表多次被引用的区块</p></blockquote></li><li><p><strong>代码分离插件存在的问题:</strong>  </p><blockquote><p>在使用代码分离插件时, 绕不开的问题是 hash 和长效缓存:</p><p>提取后的公共模块代码中, 有些chunk包含 runtime 初始化环境的代码, 导致每次打包影响chunk中 hash的变化,  而hash 的变化影响 runtime 的代码,导致某些chunk没有更新,缓存也会失效</p><p>因为我们使用 chunk hash 作为资源的版本号优化客户端的缓存,这导致用户频繁的更新资源</p></blockquote><ul><li>解决方法:</li></ul><blockquote><p>把runtime 的代码提取出来 , 通过在提取完公共模块后, 再调用该插件提取一次</p><p>或者 <strong>提取引导模板</strong></p><p>使用 <a href="https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 <code>single</code> 来为所有 chunk 创建一个 runtime bundle</p></blockquote></li></ul><ul><li><p><code>runtimeChunk</code> 作用就是为了线上更新版本时，充分利用浏览器缓存，使用户感知的影响到最低。</p></li><li><p>代码分离插件 都需要配合<code>optimization.runtimeChunk</code> 选项,把runtime 代码提取出来</p><blockquote><p>提取出runtime 代码后, 还可以利用插件<a href="https://links.jianshu.com/go?to=https://github.com/numical/script-ext-html-webpack-plugin">script-ext-html-webpack-plugin</a> 进行优化,原因每次构建上线后,runtime都要重新请求, 浪费网络资源, 把它直接内联到html中</p></blockquote></li></ul><ul><li><p>代码分离其他的插件 , 分离CSS: <a href="https://webpack.docschina.org/guides/code-splitting/plugins/mini-css-extract-plugin"><code>mini-css-extract-plugin</code></a> 把所有的CSS文件 抽离出来,变成一个CSS文件, 然后通过link 引入</p></li><li><p>代码切片的意义 : </p></li><li><blockquote><p>公共模块提取的收益 :  开发过程少了重复模块的打包, 提升开发速度, 减少整体体积  合理分片之后更有效利用客户端缓存</p></blockquote></li></ul><ul><li>bundle 分析:  <a href="https://github.com/webpack/analyse">官方分析工具</a>   分析输出结果来检查模块</li></ul><h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><ul><li><p><em>development(开发环境)</em> 和 <em>production(生产环境)</em> 这两个环境下的构建目标存在着巨大差异。</p><blockquote><p><strong><em>开发环境</em></strong>:   我们需要强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(热模块替换) 能力的 localhost server</p><p><strong><em>生产环境</em></strong> : 目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化(让用户更快加载资源,最大限度利用缓存, 资源的压缩)，</p></blockquote></li><li><p>由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>。也可以使用同一个配置文件,不过要在webpack.config.js文件内添加判断条件来使用那个配置</p><blockquote><p>使用一个名为 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a> 的工具,此工具会引用 “common” 配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。需要创建文件:</p><p><code>webpack.common.js  webpack.dev.js   webpack.prod.js</code>  </p><p>通过在文件中引入  webpack-merge, 编写独立的webpack配置:  </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;);<br>const common = require(&#x27;./webpack.common.js&#x27;);<br><br> module.exports = merge(common, &#123;<br>   mode: &#x27;development&#x27;,<br>   devtool: &#x27;inline-source-map&#x27;,<br>   devServer: &#123;<br>   contentBase: &#x27;./dist&#x27;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>更改script 命令行, 使用不同的config进行构建</p></blockquote></li></ul><ul><li><p><strong>指定mode(构建模式)</strong></p><blockquote><p>许多 library 通过与 <code>process.env.NODE_ENV</code> 环境变量关联，以决定 library 中应该引用哪些内容。</p><p>一些 library 可能针对具体用户的环境，删除或添加一些重要代码，以进行代码执行方面的优化,从 webpack v4 开始, 指定 <a href="https://webpack.docschina.org/configuration/mode/"><code>mode</code></a> 会自动地配置 <a href="https://webpack.docschina.org/plugins/define-plugin"><code>DefinePlugin</code></a></p></blockquote></li></ul><ul><li><p><strong>source map 配置</strong></p></li><li><p>对于 JS文件添加<code>devtool</code>配置即可,对于<code>css less scss</code>来说,在loader, options选项中添加</p><blockquote><p>开发环境: cheap-moudle-eval-source-map 通常是一个不错的选择</p><p>生产环境:  只有三种可供选择, 三种在安全性上各不相同 </p><p>nosources-source-map 推荐</p></blockquote></li></ul><ul><li><p><strong>资源压缩 (uglify)</strong> ,意思是移除多余空格, 换行,和不执行的代码, 缩短变量名.. 使代码形式变得更短, 压缩之后的代码基本上不可读</p><blockquote><p><strong>压缩JavaScript</strong> : webpack4之后默认 使用了terser 的插件 terser-webpack-plugin, 可以在optimization 中的 <code>minisize:true</code>, 开启功能,   如果mode : production  则会自动设置,不用再人为设置</p><p>也可以尝试别的压缩功能插件<a href="https://github.com/webpack-contrib/closure-webpack-plugin">closure-webpack-plugin</a></p></blockquote><blockquote><p><strong>压缩 css:</strong> 通过<code>mini-css-extract-plugin</code>  将样式提取出来到单独文件, 再使用<code>CssMinimizerWebpackPlugin</code> 进行压缩</p></blockquote></li></ul><ul><li><p><code>optimization.minimizer</code> 配置项中提供一个/多个压缩工具,</p></li><li><p><code>optimization.minimize:true</code>  开启压缩功能, 生产模式自动开启</p></li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li><p>客户端获取资源是比较耗费时间的 , 浏览器使用一种名为 <a href="https://searchstorage.techtarget.com/definition/cache">缓存</a>的技术, 重复利用浏览器已经获取过的资源, 通过命中缓存，以降低网络流量 </p><blockquote><p>当开发者更新了bug,希望立即更新到用户的浏览器上,而不是使用客户端旧的缓存,最好的办法是改变资源的URL,一个常用的办法时改变文件的名字 : 来迫使客户端重新下载</p></blockquote></li><li><p>技术点:</p><blockquote><ol><li><p>改变输出文件的文件名, ,使客户端只重新下载更新过的代码, </p><blockquote><p>我们可以通过替换 <code>output.filename</code> 中的 <a href="https://webpack.docschina.org/configuration/output/#outputfilename">substitutions</a> 设置, 还要设置 runtimeChunk 选项,把runtime代码拆分成单独的 chunk, 否则会影响文件名  </p><p>(但是在实际操作中 构建时不进行拆分runtime 代码, 也不会影响包含runtime的chunk的文件名  可能和文件名设置有关系  这里使用[contenthash] 并没有影响  如果使用[chunkhash]可能会发生变化 )</p><p>例子:    <code>filename: &#39;[name].[contenthash].js&#39;,  </code></p></blockquote></li><li><p>将第三方库(library)提取到单独的 vendor chunk 文件中, 因为他不会频繁改变, 可以利用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 插件的 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#splitchunkscachegroups"><code>cacheGroups</code></a> 选项来实现, 把<code>node_modules</code> 目录的代码提取出单独的一个chunk(所有的第三方库整合成一个chunk)</p><p>默认情况下 使用SplitChunksPlugin插件, 会把<strong>每个</strong>第三方库都声称一个单独的chunk, </p><blockquote><p>当分离出来第三方库时, 有可能(使用别的文件名时)每次构建时vendor 都会改变, 可以使optimization.moduleIds设置为 deterministic’</p><p>这里文件名使用了[contenthash] 构建时并没有影响vendor 的变化</p></blockquote></li></ol></blockquote></li></ul><h4 id="打包优化-构建性能"><a href="#打包优化-构建性能" class="headerlink" title="打包优化(构建性能)"></a>打包优化(构建性能)</h4><ul><li><p>让打包速度更快,资源输出体积更小 —–对应官网的构建性能</p></li><li><p>环境通用: </p></li><li><p>缩小打包作用域 : </p><ul><li><p>将 loader 应用于最少数量的必要模块</p><blockquote><p>通过使用 <code>include</code> 字段 规定loader应用的目录,缩小范围</p><p><code>exclude </code> 字段 , 排除不需要loader 的目录</p><p>有些库不希望webpack 进行解析,即不应用任何的loader,但仍然会被打包进资源文件,可以使用 <code>moudle</code>中的<code>noParse: /loadsh/ </code>指明模块名字</p></blockquote></li></ul></li><li><p>每个额外的 loader/plugin 都有其启动时间。尽量少地使用工具,尽量保持 chunk 体积小,减少编译结果的整体大小，</p></li><li><p>将 <code>ProgressPlugin</code> 从 webpack 中删除，可以缩短构建时间。</p></li><li><p>cache 选项: 缓存生成的 webpack 模块和 chunk，来改善构建速度。<code>cache</code> 会在<a href="https://webpack.docschina.org/configuration/mode/#mode-development"><code>开发</code> 模式</a>被设置成 <code>type: &#39;memory&#39;</code> 而且在 <a href="https://webpack.docschina.org/configuration/mode/#mode-production"><code>生产</code> 模式</a> 中被禁用</p></li><li><p>使用ignorePlugin ,他可以完全排除一些模块, 即使被引用也不会被打包, 对于排除一些库的相关文件非常有用, 一些库产生的额外资源我们用不到,但是引用语句在库文件内,我们也无法去掉,这时使用该插件不打包</p></li></ul><ul><li><p>使用 DIIplugin插件,对一些不经常改变的公共(第三方)模块,进行预先打包,到工程部署时使用DiiReferencePlugin来索引打包好的文件, DIIplugin和 代码分离类似,但是前者会把整个模块拆出来,代码分离会根据规则拆分, 相应的前者需要单独一个配置文件</p></li><li><p>开发环境使用:</p><ul><li><p>在内存中编译, 使用工具<code>webpack-dev-server</code> ….</p></li><li><p>需要注意的是不同的 <code>devtool</code> 设置，会导致性能差异。选择适当的<code>devtool</code></p></li><li><p>webpack 只会在文件系统中输出已经更新的 chunk。最小化入口chunk,把runtime 分离出来</p></li><li><p>webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 <code>options.output.pathinfo</code> 设置中关闭：</p></li><li><p>使用 <strong>happyPack</strong> 多线程进行打包(webpack本身是单线程的,只能一个一个的通过依赖关系查找进行转译),适用于转译任务比较重的项目效果明显,对于小项目来说并不明显</p></li></ul></li></ul><h5 id="Tree-Shaking-缩小chunk体积"><a href="#Tree-Shaking-缩小chunk体积" class="headerlink" title="Tree Shaking:  (缩小chunk体积)"></a>Tree Shaking:  (缩小chunk体积)</h5><ul><li><p>通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 <a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构</a> 特性, 例如我们仅仅导入了文件中的部分 导出内容, 而webpack将把所有内容导入进来,这时需要 tree shaking 去除冗余</p><blockquote><p>es6会在代码编译时确定依赖关系,可以检测出,没有引用过的模块(代码块),webpack进行标记,在开发环境下仍然可见, 在生产环境下<strong>资源压缩时</strong>将他们从最终的bundle去掉</p></blockquote></li><li><p>tree Shaking 只对<code>es6 module</code> 有用, 对于通过<code>commonJs</code> 引用进来的没有用处</p></li><li><blockquote><p>在工程中使用 <code>babel-loader</code> ,那么一定要通过配置来禁用它的模块依赖解析,因为解析过之后,webpack接受的都是commonjs形式的模块, </p><p>在loader 中<code>options:&#123;presets:[@babel/preset-env,&#123;moudle:false&#125;]&#125;</code></p></blockquote></li><li><p>使用 Tree Shaking:</p><blockquote><p>配置 <code>optimization: &#123; usedExports: true,&#125; </code> , 在mode: “production”时被默认添加 </p><p>该配置让webpack 标记标记未使用的成员,然后在压缩过程中删除代码</p></blockquote><blockquote><p><strong>该配置的副作用 :</strong> </p><p>在一个纯粹的 ESM 模块世界中,很容易分辨出哪些代码删除之后没有副作用,但是现实情况我们达不到这种纯度, 例如有些内容虽然没有使用,但是去除之后可能会有副作用( <code>polyfill </code> 不需要导出,他影响全局作用域)</p></blockquote><ul><li><p>``sideEffects<code> </code> 的原理:</p><blockquote><p><code>usedExports</code> 依赖于 <a href="https://github.com/terser-js/terser">terser</a> 去检测语句中的副作用,我们可以通过 <code>/*#__PURE__*/</code> 注释来帮忙 terser。</p><p>它将一个语句标记为没有副作用,这样进行有利于后期删除, 但是这种层面只能指定单个语句</p></blockquote></li><li><p>使用<code>sideEffects</code> 更加有效 ,他也是标记代码但是它作用于模块的层面, 而不是代码语句的层面</p><blockquote><p>通过 package.json 的 <code>&quot;sideEffects&quot;</code> 属性，来实现这种方式,默认为true</p><blockquote><p>optimization.sideEffects 中的选项将辨识<code>package.json</code> 中的sideEffects 规则    在生产环境下默认添加</p></blockquote><p>如果所有代码都没有副作用 ，我们就可以简单地将该属性标记为 false</p><p>或者可以给该选项提供一个数组</p></blockquote></li><li><blockquote><p> 所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 <code>css-loader</code> 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：</p></blockquote></li><li><p>还可以在 <code>module.rules</code> 配置选项中设置 <code>&quot;sideEffects&quot;</code>。</p></li></ul></li><li><p><code>sideEffects</code>    和 <code>usedExports</code>两者的联系</p><blockquote><p><code>sideEffects</code>    打包时直接删除了没有副作用 被引用但没有使用的模块</p><p><code>usedExports</code>   打包时 标记没有使用的语句, 在生产环境下删除多余的语句,</p></blockquote></li></ul><ul><li><p>在使用 tree shaking 时必须有 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a> 的支持，您可以通过设置配置项 <code>mode: &quot;production&quot;</code> 以启用它。如果您没有如此做，请记得手动引入 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a>。</p></li><li><p>tree shaking 本质上只对死代码进行标记, 真正去除死代码的是在生产环境下资源压缩那一步</p></li></ul><h4 id="Web-workers"><a href="#Web-workers" class="headerlink" title="Web workers"></a>Web workers</h4><ul><li>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。</li></ul><h4 id="进式网络应用程序PWA"><a href="#进式网络应用程序PWA" class="headerlink" title="进式网络应用程序PWA"></a>进式网络应用程序PWA</h4><ul><li>是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)。简单说是一种 web 应用  。PWA 可以用来做很多事。其中最重要的是，在__离线(offline)__时应用程序能够继续运行功能。这是通过使用名为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a> 的 web 技术来实现的。</li></ul><h4 id="Shimming-预置依赖"><a href="#Shimming-预置依赖" class="headerlink" title="Shimming 预置依赖"></a>Shimming 预置依赖</h4><ul><li><p><code>webpack</code> compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 <code>jQuery</code> 中的 <code>$</code>）。因此这些 library 也可能会创建一些需要导出的全局变量。这些 “broken modules(不符合规范的模块)” 就是 <em>shimming(预置依赖)</em> 发挥作用的地方。</p></li><li><p><em>shim</em> 另外一个极其有用的使用场景就是：当你希望 <a href="https://en.wikipedia.org/wiki/Polyfill_(programming)">polyfill</a> 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）</p></li><li><p><strong>Shimming 预置全局变量:</strong> </p></li><li><p>使用 <a href="https://webpack.docschina.org/plugins/provide-plugin"><code>ProvidePlugin</code></a> 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package</p><blockquote><p>还可以使用 <code>ProvidePlugin</code> 暴露出某个模块中单个导出，通过配置一个“数组路径”</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">new webpack.ProvidePlugin(&#123;<br>    _: &#x27;lodash&#x27;,<br>     join: [&#x27;lodash&#x27;, &#x27;join&#x27;],<br>     &#125;),<br></code></pre></td></tr></table></figure></blockquote></li><li><p>在依赖全局变量的 第三方模块中  <a href="https://webpack.docschina.org/loaders/imports-loader/"><code>imports-loader</code></a>  很有用,  <a href="https://webpack.docschina.org/loaders/exports-loader/"><code>exports-loader</code></a>，将一个全局变量作为一个普通的模块来导出</p><blockquote><p> imports-loader最直接的应用场景，就是你想直接import一个开放的js文件，而不是通过npm去加载这个类库（会有一些类库不支持npm的方式）</p></blockquote></li><li><p><strong>加载polyfills:</strong> </p><blockquote><p>最普通的方法 : 引入 <a href="https://babel.docschina.org/docs/en/babel-polyfill/"><code>babel-polyfill</code></a> 直接  import ‘babel-polyfill’;使用 <code>import</code> 将其引入到我们的主 bundle 文件：</p><p>最佳实践仍然是，不加选择地和同步地加载所有 polyfill/shim，尽管这会导致额外的 bundle 体积成本。</p><p>但是你仍然可以选择性的加载polyfill, 使用<code>whatwg-fetch</code> 条件性的加载</p></blockquote></li><li><p>优化方案:</p></li><li><p><code>babel-preset-env</code> package 通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来转译那些你浏览器中不支持的特性。这个 preset 使用 <a href="https://babel.docschina.org/docs/en/babel-preset-env#usebuiltins"><code>useBuiltIns</code></a> 选项，默认值是 <code>false</code>，这种方式可以将全局 <code>babel-polyfill</code> 导入，改进为更细粒度的 <code>import</code> 格式：<a href="https://babeljs.io/docs/en/babel-preset-env">babel-preset-env</a></p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linear</title>
    <link href="/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/preitter%20%20eslint/"/>
    <url>/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/preitter%20%20eslint/</url>
    
    <content type="html"><![CDATA[<h3 id="preitter-linner"><a href="#preitter-linner" class="headerlink" title="preitter linner"></a>preitter linner</h3><ul><li><p><strong>为什么要两者配合使用？</strong></p></li><li><p>在 ESLint 推出 –fix 参数前，ESLint 并没有自动化格式代码的功能，要对一些格式问题做批量格式化只能用 Prettier 这样的工具。</p></li><li><p>ESLint 的规则并不能完全包含 Prettier 的规则，两者并不是简单的谁替代谁的问题。</p></li><li><blockquote><p>在 ESLint 推出 –fix 命令行参数之后,也可以使用 standard aribnb 等规范格式化代码，如果觉得已经够用就可以不使用 Prettier。</p></blockquote></li><li><p><strong>ESLint 和 Prettier 冲突问题:</strong></p></li><li><p>对于他们交集的部分规则，ESLint 和 Prettier 格式化后的代码格式不一致。所以当你用 Prettier 格式化代码后再用 ESLint 去检测，会出现一些因为格式化导致的 warning。</p></li><li><p><strong>解决方法:</strong></p></li></ul><ol><li><p>运行 Prettier 之后，再使用 eslint –fix 格式化一把，这样把冲突的部分以 ESLint 的格式为标准覆盖掉，剩下的 warning 就都是代码质量问题了。</p><blockquote><p>简单理解: 使用 eslint 覆盖有冲突的规则</p></blockquote></li><li><p>在配置 ESLint 的校验规则时候把和 Prettier 冲突的规则 disable 掉，然后再使用 Prettier 的规则作为校验规则。那么使用 Prettier 格式化后，使用 ESLint 校验就不会出现对前者的 warning。</p></li></ol><blockquote><p>简单理解: 改变 eslint 规则,使其不再冲突</p></blockquote><ul><li><p><strong>为什么不能先使用 ESLint 再使用 Prettier:</strong></p></li><li><p>如果你后使用 Prettier，那么格式化后提交的代码在下一次或者别人 checkout 代码后是通不过 lint 校验的。</p></li><li><p><strong>方法一:</strong></p></li><li><p>安装 prettier-eslint , prettier-eslint-cli</p></li><li><blockquote><p>prettier-eslint 会一次执行 prettier 和 eslint –fix 命令。</p><p>整个流程是：Code ➡️ prettier ➡️ eslint –fix ➡️ Formatted Code。</p></blockquote></li><li><p>当然你也可以进行手动 fix</p></li><li><p><strong>方法二:</strong></p></li><li><p>主要是要改变 eslint 的规则配置文件，安装 eslint-config-prettier</p></li><li><blockquote><p>把其配置到 extends 字段，实现 prettier 规则对 eslint 规则的覆盖。</p><p>如果只是单纯的覆盖效验时的规则, 那么我们还是需要分别运行 prettier 和 eslint 命令来完成</p><p>我们可以利用插件 把两个操作整合一下</p></blockquote></li><li><p>利用 eslint-plugin-prettier 插件实现 将 prettier 规则以插件的形式加入到 ESLint 里面,让其作为规则运行, 不符合 prettier 规则的,整合为单独的 eslint 问题</p></li><li><blockquote><p>在使用 eslint –fix 时候，实际使用 prettier 来替代 eslint 的格式化功能。</p><p>来这里使用 官方推荐配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;plugin:prettier/recommended&quot;</span><br><span class="hljs-comment">//它是一些配置的缩写  可在官网查询</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>当然你可以单独使用 eslint-plugin-prettier 插件, 但是必须关闭格式化代码的规则,因为本质上冲突的规则还是会引起 lint 使用 eslint-config-prettier 将其覆盖是最好的方法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linear</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/Axios/"/>
    <url>/2021/02/21/%E5%B7%A5%E5%85%B7%E7%AF%87/Axios/</url>
    
    <content type="html"><![CDATA[<h3 id="Axios-基本入门"><a href="#Axios-基本入门" class="headerlink" title="Axios  基本入门"></a>Axios  基本入门</h3><ul><li>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</li></ul><h4 id="Axios-请求方式"><a href="#Axios-请求方式" class="headerlink" title="Axios 请求方式"></a>Axios 请求方式</h4><ul><li><p>基本请求</p><blockquote><p>使用请求方法函数</p><p>axios.request(config)</p><p>axios.get(url[, config])</p><p>axios.delete(url[, config])</p><p>axios.head(url[, config])</p><p>axios.options(url[, config])</p><p>axios.post(url[, data[, config]])</p><p>axios.put(url[, data[, config]])</p><p>axios.patch(url[, data[, config]])</p><p>在使用方法时， url、method、data 这些属性都不必在配置中指定。 </p></blockquote></li><li><p>并发请求</p><blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">axios.all([getUserAccount(), getUserPermissions()])<br>.then(axios.spread(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(res1, res2)</span> </span>&#123;<br> <span class="hljs-comment">// 两个请求现在都执行完成</span><br>&#125;));<br><span class="hljs-comment">//默认情况下 返回一个多个对象的数组, 如果想分开各个对象, 使用axios.spread() 函数 返回各个对象</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>通过向 <code>axios</code> 传递相关配置来创建请求</p><blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">axios</span>(&#123;<br>  <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>  <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/user/12345&#x27;</span>,<br>  <span class="hljs-attribute">data</span>: &#123;<br>    <span class="hljs-attribute">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span>,<br>    <span class="hljs-attribute">lastName</span>: <span class="hljs-string">&#x27;Flintstone&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>axios(url[, config])  :axios(‘/user/12345’);</p><blockquote><p>发送 GET 请求（将使用默认的方法）</p></blockquote></li></ul><h4 id="Axios-实例化"><a href="#Axios-实例化" class="headerlink" title="Axios 实例化"></a>Axios 实例化</h4><ul><li><p>创建Axios 实例</p><blockquote><p>可以使用自定义配置新建一个 axios 实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">axios.<span class="hljs-built_in">create</span>(&#123;<span class="hljs-built_in">config</span>..&#125;)<br></code></pre></td></tr></table></figure></blockquote></li><li><p>配置默认值</p></li><li><p>你可以指定用在各个请求配置的默认值</p><blockquote><p>全局的 axios 默认值 ::  axios.defaults.baseURL = ‘<a href="https://api.example.com&/#39;">https://api.example.com&#39;</a>;</p><p>自定义实例默认值:: </p><p>const instance = axios.create({baseURL: ‘<a href="https://api.example.com&/#39;}">https://api.example.com&#39;}</a>);<br>instance.defaults.headers.common[‘Authorization’] = AUTH_TOKEN;</p></blockquote><ul><li>配置会以一个优先顺序进行合并 ,  默认值&lt; 实例的defaultes属性 &lt; 请求的config</li></ul></li></ul><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><ul><li><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p></li><li><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) &#123;&#125;)// 添加响应拦截器axios.interceptors.response.use(function (response) &#123;&#125;)</code></pre></li><li><p>移除拦截器: axios.interceptors.request.eject(拦截器名字)</p></li></ul><ul><li>默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，需要更改格式</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web框架</title>
    <link href="/2021/02/21/Vue/web%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/02/21/Vue/web%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><ul><li><p>请记住，您可能根本不需要框架ーー不要仅仅为了框架而使用框架。 在某些情况下，框架应用程序创建了传统网站不存在的可访问性障碍。</p><blockquote><p>最大的例子是客户端路由， 使用客户端路由，你的浏览器不会加载新的网页，所以它不知道它应该自动调整焦点或宣布一个新的页面标题。</p></blockquote></li><li><p>客户端框架 的替代方案</p><blockquote><p>A content management system 内容管理系统</p><p>Server-side rendering 服务器端呈现 SSR</p><p>A static site generator 一个静态站点生成器</p></blockquote></li><li><p>框架改善了冗长的 Dom 操作,提高了开发效率</p></li></ul><h4 id="框架组成要素"><a href="#框架组成要素" class="headerlink" title="框架组成要素"></a>框架组成要素</h4><ul><li><p><strong>组件</strong></p></li><li><blockquote><p>大多数主流框架都鼓励开发人员将用户界面的不同部分抽象为组件ーー可维护、可重用的代码块，这些代码块可以相互通信。</p></blockquote></li><li><p>组件有以下几个重要要素</p><blockquote><p>1.属性 例如: </p><p>2.状态 一个健壮的状态处理机制是有效框架的关键，每个组件可能拥有需要其状态控制的数据。只要组件仍在使用，这种状态就会以某种方式保持下去 例如检测按钮被点击了多少次</p><p>3.事件 event</p></blockquote></li><li><p>框架都提供了一种为组件或整个应用程序定义样式的方法。</p></li><li><p>组件可以互相组合</p></li><li><p>所有主要的框架都提供了处理依赖关系的机制ーー使用其他组件内部的组件</p><blockquote><p>但是实际程序中通常涉及具有多级嵌套的组件结构。这时候我们就需要 <code>依赖注入</code>系统</p><p>The problem of passing data through many layers of components is called prop drilling,通过多层组件传递数据的问题称为支柱钻井，( 这对于大型应用来说并不理想。)</p></blockquote></li><li><p>框架提供了一种称为依赖注入数据库的功能，这是一种将特定数据直接传递给需要它的组件的方法，而不需要通过中间层传递数据。每个框架都以不同的名称和方式实现依赖注入/服务，但最终的效果是相同的。</p></li><li><p><strong>Lifecycle 生命周期:</strong></p></li><li><p>在框架的上下文中，组件的生命周期是组件从被浏览器呈现(通常称为挂载)到从 DOM 中移除(通常称为卸载)所经历的阶段的集合。所有框架都遵循相同的通用模型: 它们允许开发人员在组件挂载、呈现、卸载以及这些之间的许多阶段执行某些操作。</p></li><li><p><strong>Rendering elements 渲染元素</strong></p></li><li><p>使用框架,通常不会亲自和 DOM 交互,这种远离 DOM 的抽象比自己更新 DOM 更复杂，也更占用内存，但是如果没有它，框架就不能允许您以声明性的方式进行编程。</p><blockquote><p>虚拟 DOM 是一种将浏览器的 DOM 信息存储在 JavaScript 内存中的方法。您的应用程序更新这个 DOM 副本，然后将其与“真正的” DOM (实际上为用户呈现的 DOM)进行比较，以决定呈现什么。</p></blockquote></li><li><p><strong>客户端路由:</strong></p><blockquote><p>路由是网络体验的重要组成部分。为了避免在具有大量视图的足够复杂的应用程序中出现破坏性体验，此模块中的每个框架都提供了一个库 (或多个库) ，帮助开发人员在其应用程序中实现客户端路由。</p></blockquote></li></ul><h3 id="MVC-MVVM-设计思想"><a href="#MVC-MVVM-设计思想" class="headerlink" title="MVC MVVM 设计思想"></a>MVC MVVM 设计思想</h3><ul><li><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步, 不在进行操作 DOM 弱化了 controller 层</p></li><li><p>MVC</p><blockquote><p>用户对 View 的操作交给了 Controller 处理,Controller 中响应 View 的事件调用 Model 的接口对数据进行操作</p><p>大量的逻辑放在 c 层导致过于臃肿,</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex</title>
    <link href="/2021/02/21/Vue/vuex/"/>
    <url>/2021/02/21/Vue/vuex/</url>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul><li><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理</strong>应用的<strong>所有组件</strong>的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></li><li><p>单向数据流</p></li><li><blockquote><p>State –&gt; View–&gt;Actions—&gt;State    形成一个循环, 但是当我们多个组件共享状态时,单向数据流会被破坏</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p>因此，我们把组件的共享状态抽取出来，以一个全局单例模式管理,在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为</p></blockquote></li><li><p>Vuex 依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">Promise (opens new window)</a>。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 <a href="https://github.com/stefanpenner/es6-promise">es6-promise (opens new window)</a>。</p></li></ul><h4 id="Store-模式"><a href="#Store-模式" class="headerlink" title="Store 模式"></a>Store 模式</h4><ul><li><pre><code class="js">var store = &#123;  debug: true,  state: &#123;    message: &#39;Hello!&#39;  &#125;,  setMessageAction (newValue) &#123;    if (this.debug) console.log(&#39;setMessageAction triggered with&#39;, newValue)    this.state.message = newValue  &#125;,  clearMessageAction () &#123;    if (this.debug) console.log(&#39;clearMessageAction triggered&#39;)    this.state.message = &#39;&#39;  &#125;&#125;var vmA = new Vue(&#123;  data: &#123;    privateState: &#123;&#125;,    sharedState: store.state  //store模式 不需要 store.state.message 这样写到具体属性值, 如果写到属 性值 调用 mutation无法进行更新数据       // 组件和 store 需要引用同一个共享对象，变更才能够被观察到。  &#125;&#125;)var vmB = new Vue(&#123;  data: &#123;    privateState: &#123;&#125;,    sharedState: store.state  &#125;&#125;)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 所有 store 中 state 的变更，都放置在 store 自身的 action 中去管理。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。<br><br>- &gt; 组件不允许直接变更属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变<br><br><br><br><br><br><br><br>#### 开始<br><br>- 每一个 Vuex 应用的核心就是 store（仓库）, store 基本上是一个容器, 包含所有的state(状态).Vuex 它和单纯的全局对象不同<br><br>- &gt; Vuex 的状态存储是响应式的   store 状态的改变,相应的组件也会发生相应的更新<br>  &gt;<br>  &gt; 不能直接改变 store中的状态, 只能通过显示提交 mutation 改变状态, 这样我们方便追踪每个状态的变化<br><br>- 为了在 Vue 组件中访问 `this.$store` property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 `store` 选项的方式“注入”该 store 的机制：<br><br>- ```js<br>  new Vue(&#123;<br>    el: &#x27;#app&#x27;,<br>    store: store,<br>  &#125;)<br>  <br>  //现在可以在组件中通过提交mutation的方式, 来改变数据<br>  methods: &#123;<br>    increment() &#123;<br>      this.$store.commit(&#x27;increment&#x27;)<br>      console.log(this.$store.state.count)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>再次强调，我们通过提交 mutation 的方式，而非直接改变 <code>store.state.count</code></p></li></ul><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><ul><li><p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态, 这也意味着，每个应用将仅仅包含一个 store 实例。</p></li><li><p>从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p></li><li><pre><code class="js">const Counter = &#123;  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,  computed: &#123;    count () &#123;      return store.state.count    &#125;  &#125;&#125;// 这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入// 所以Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中, 这样子组件能通过 this.$store 访问到//  更改为       return this.$store.state.count<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余,使用 `mapState` 辅助函数帮助我们生成计算属性<br><br>- 我们在需要使用这个辅组函数的地方导入 , `import &#123; mapState &#125; from &#x27;vuex&#x27;`<br><br>- &gt; 在单独构建的版本中辅助函数为 Vuex.mapState<br><br><br><br>- 当计算属性的名称与 state 的子节点名称相同时,使用数组语法<br><br>- ```js<br>  computed: mapState([&#x27;count&#x27;,&#x27;name&#x27;,&#x27;age&#x27;])<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>普通情况使用对象语法:</p></li><li><pre><code class="js">export default &#123;  // ...  computed: mapState(&#123;    // 箭头函数可使代码更简练    count: state =&gt; state.count,    // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`    countAlias: &#39;count&#39;,    // 为了能够使用 `this` 获取局部状态，必须使用常规函数    countPlusLocalState (state) &#123;      return state.count + this.localCount    &#125;  &#125;)<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- `mapState` 函数返回的是一个对象。我们如何将它与局部计算属性混合使用, 使用对象展开符 `...`<br><br></code></pre></td></tr></table></figure>computed: &#123;  localComputed () &#123;&#125;,  // 使用对象展开运算符将此对象混入到外部对象中  ...mapState(&#123;  &#125;),&#125;<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs pf"><br>- &gt; 使用 Vuex 并不意味着你需要将**所有的**状态放入 Vuex, 如果有些状态严格属于单个组件，最好还是作为组件的局部状态。<br><br><br><br><span class="hljs-comment">#### Getters</span><br><br>- 获取<span class="hljs-keyword">state</span>状态后,我们有时会对其进行处理在computed中, 当多个组件都需要这个处理过的值, 每个组件都进行computed处理转态太麻烦, 使用getters 派生出<span class="hljs-keyword">state</span>处理过后的状态, 直接调用getter<br><br>- &gt; 在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><br>- ```js<br>  <span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>      todos: [<br>        &#123; id: <span class="hljs-number">1</span>, text: &#x27;...&#x27;, done: true &#125;,<br>        &#123; id: <span class="hljs-number">2</span>, text: &#x27;...&#x27;, done: false &#125;<br>      ]<br>    &#125;,<br>    getters: &#123;<br>      doneTodos: <span class="hljs-keyword">state</span> =&gt; &#123;   // Getter 接受 <span class="hljs-keyword">state</span> 作为其第一个参数：<br>        return <span class="hljs-keyword">state</span>.todos.filter(todo =&gt; todo.done)<br>      &#125;<br>      doneTodosCount: (<span class="hljs-keyword">state</span>, getters)=&gt;&#123;&#125;  可以接受其他 getter 作为第二个参数<br>                           <br>      getTodoById: (<span class="hljs-keyword">state</span>) =&gt; (id) =&gt; &#123;<br>      return <span class="hljs-keyword">state</span>.todos.find(todo =&gt; todo.id === id)<br>    &#125;<br>    &#125;<br>  &#125;)<br>  <br>  通过属性访问   store.getters.doneTodos getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的<br>  <br>  通过方法访问  store.getters.getTodoById(<span class="hljs-number">2</span>)  getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>在组件中使用:</p></li><li><pre><code class="js">computed: &#123;  doneTodosCount () &#123;    return this.$store.getters.doneTodosCount  属性访问     return this.$store.getters.doneTodosCount(id)   方法访问  &#125;&#125;<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- `mapGetters` 辅助函数:  仅仅是将 store 中的 getter 映射到局部计算属性.<br><br>- ```js<br>  import &#123; mapGetters &#125; from &#x27;vuex&#x27;<br>  <br>  export default &#123;<br>    // ...<br>    computed: &#123;<br>    // 使用对象展开运算符将 getter 混入 computed 对象中<br>      ...mapGetters([<br>        &#x27;doneTodosCount&#x27;,<br>        &#x27;anotherGetter&#x27;,<br>        // ...<br>      ])<br>    &#125;<br>  &#125;<br>  <br>  重命名: ...mapGetters(&#123;<br>    // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`<br>    doneCount: &#x27;doneTodosCount&#x27;<br>  &#125;)<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><ul><li><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,Vuex 中的 mutation 非常类似于事件,每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。</p></li><li><pre><code class="js">mutations: &#123;    increment (state) &#123;   //回调函数 , 会接受 state 作为第一个参数      // 变更状态      state.count++    &#125;  &#125;// 要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：store.commit(&#39;increment&#39;)<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf"><br>- 提交载荷 : 向 `store.commit` 传入额外的参数, 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段<br><br>- ```<br>  mutations: &#123;<br>    increment (<span class="hljs-keyword">state</span>, n) &#123;<br>      <span class="hljs-keyword">state</span>.count += n<br>    &#125;<br>  &#125;<br>  <br>  store.commit(&#x27;increment&#x27;, <span class="hljs-number">10</span>)<br>  <br>  载荷是对象:<br>   increment (<span class="hljs-keyword">state</span>, payload) &#123;<br>      <span class="hljs-keyword">state</span>.count += payload.amount<br>    &#125;<br>    <br>   store.commit(&#x27;increment&#x27;, &#123;<br>    amount: <span class="hljs-number">10</span><br>  &#125;) <br>    <br></code></pre></td></tr></table></figure></code></pre></li><li><p>对象风格方式的提交 :  当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数</p></li><li><pre><code>store.commit(&#123;  type: &#39;increment&#39;,  amount: 10&#125;)//mutations 不需要变化mutations: &#123;  increment (state, payload) &#123;    state.count += payload.amount  &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 一条重要的原则就是要记住 **mutation 必须是同步函数**。因为任何在回调函数中的状态改变不可追踪<br><br>- &gt; 当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？在 Vuex 中，**mutation 都是同步事务**  而处理异步操作需要Action<br><br>- 你可以在组件中使用 `this.$store.commit(&#x27;xxx&#x27;)` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）。<br><br>- ```js<br>  import &#123; mapMutations &#125; from &#x27;vuex&#x27;<br>  <br>  export default &#123;<br>    // ...<br>    methods: &#123;<br>      ...mapMutations([<br>        &#x27;increment&#x27;, // 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`<br>  <br>        // `mapMutations` 也支持载荷：<br>        &#x27;incrementBy&#x27; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`<br>      ]),<br>      ...mapMutations(&#123;<br>        add: &#x27;increment&#x27; // 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><ul><li><blockquote><p>Action 提交的是 mutation，而不是直接变更状态。</p><p>Action 可以包含任意异步操作。</p></blockquote></li><li><p>注册 action:</p></li><li><pre><code class="js">const store = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    increment (state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;     increment (context) &#123;   // 接受一个与 store 实例具有相同方法和属性的 context 对象      context.commit(&#39;increment&#39;)    &#125;  &#125;&#125;)//使用 es6结构语法:actions: &#123;  increment (&#123; commit &#125;) &#123;    commit(&#39;increment&#39;)  &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 触发 action:<br><br>- ```js<br>  store.dispatch(&#x27;increment&#x27;)  <br>  <br>  // action 也支持载荷, 两种带有载荷的触发方式<br>  <br>  store.dispatch(&#x27;incrementAsync&#x27;, &#123;<br>    amount: 10<br>  &#125;)<br>  <br>  store.dispatch(&#123;<br>    type: &#x27;incrementAsync&#x27;,<br>    amount: 10<br>  &#125;)<br></code></pre></td></tr></table></figure></code></pre></li><li><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p></li><li><blockquote><p><code>mapActions</code> 和 <code>mapmutations </code>用法一样 , </p></blockquote></li></ul><ul><li><p>组合action:  处理更复杂的异步操作,  使用promise 处理</p></li><li><blockquote><p>待拓展…</p></blockquote></li></ul><h4 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h4><ul><li><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong></p></li><li><pre><code>const moduleB = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    moduleA  &#125;&#125;)store.state.moudleA.数据名  //获得moudleA的状态<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- 模块的局部状态<br><br>- &gt; 对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。<br>  &gt;<br>  &gt; 对于模块内部的 action，局部状态通过 `context.state` 暴露出来<br>  &gt;<br>  &gt; 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<br><br><br><br>- 命名空间<br><br>- 默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。  这使得模块 之间会产生冲突,使用命名空间隔离状态<br><br>- &gt; 你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名<br><br>- ```<br>  const store = new Vuex.Store(&#123;<br>    modules: &#123;<br>      account: &#123;<br>        namespaced: true,<br>  <br>        // 模块内容（module assets）<br>        state: () =&gt; (&#123; ... &#125;), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响<br>        getters: &#123;<br>          isAdmin () &#123; ... &#125; // -&gt; getters[&#x27;account/isAdmin&#x27;]<br>        &#125;,<br>        actions: &#123;<br>          login () &#123; ... &#125; // -&gt; dispatch(&#x27;account/login&#x27;)<br>        &#125;,<br>        mutations: &#123;<br>          login () &#123; ... &#125; // -&gt; commit(&#x27;account/login&#x27;)<br>        &#125;,<br>        &#125;<br>        &#125;<br>        // 调用时需要加上模块名来调用指定的内容, 可以通过从console.log()来查看嵌套<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p></li><li><pre><code class="js">computed: &#123;  ...mapState(&#123;    a: state =&gt; state.some.nested.module.a,    b: state =&gt; state.some.nested.module.b  &#125;)&#125;,对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。computed: &#123;  ...mapState(&#39;some/nested/module&#39;, &#123;    a: state =&gt; state.a,    b: state =&gt; state.b  &#125;)&#125;,</code></pre></li></ul>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- 模块动态注册:<br><br>- &gt; 你可以使用 `store.registerModule` 方法注册模块：<br>  &gt;<br></code></pre></td></tr></table></figure><blockquote><p>// 注册模块 <code>myModule</code><br>store.registerModule(‘myModule’, {<br>  // …<br>})</p><pre><code></code></pre></blockquote><h4 id="Vuex-进阶"><a href="#Vuex-进阶" class="headerlink" title="Vuex 进阶"></a>Vuex 进阶</h4><ul><li>模块分离</li></ul><ul><li><p>严格模式  <strong>不要在发布环境下启用严格模式</strong>！</p></li><li><blockquote><p>开启严格模式，仅需在创建 store 的时候传入 <code>strict: true</code></p><p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p></blockquote></li><li><p>表单处理- </p></li><li><p>测试</p></li><li><p>手动热重载</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 基础</title>
    <link href="/2021/02/21/Vue/vue/"/>
    <url>/2021/02/21/Vue/vue/</url>
    
    <content type="html"><![CDATA[<h2 id="VUE-一遍"><a href="#VUE-一遍" class="headerlink" title="VUE 一遍"></a>VUE 一遍</h2><h4 id="vue-的核心思想是什么"><a href="#vue-的核心思想是什么" class="headerlink" title="vue 的核心思想是什么"></a>vue 的核心思想是什么</h4><ul><li>构建用户界面的渐进式框架 设计为可以<strong>自底向上逐层应用</strong>(—-串联线) 只关注视图层 提供 MVVM 数据双向绑定的库 其核心思想包括数据驱动，组件化思想</li><li><blockquote><p>渐进式 : vue 每个功能是独立的,你可以只用其中一种</p></blockquote></li><li><blockquote><p>Vue 的体系从内到外依次是声明式渲染(Declarative Rendering)、组件系统(Component System)、客户端路由(Client-side Routing)、大规模状态管理(Large Scale State Management)、构建系统(Build System)。</p></blockquote></li><li><blockquote><p>MVVM 数据(Model)和视图(View)是不能直接通讯的，而是需要通过 ViewModel 来实现双方的通讯 (Viewmodel:就是连接视图与数据的中间件)</p></blockquote></li><li><blockquote><p>组件化思想: 把复杂逻辑分为多个组件处理, 所以本质上,我们是要写各个组件, 各个组件之间的通讯,渲染..</p></blockquote></li></ul><h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><ul><li><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><blockquote><p><code>beforeCreate created beforeMount mounted</code> &gt; <code>beforeUpdate updated beforeDestroy destroyed</code></p></blockquote></li></ul><h3 id="第一层-声明式渲染"><a href="#第一层-声明式渲染" class="headerlink" title="第一层:声明式渲染"></a>第一层:声明式渲染</h3><ul><li><h4 id="声明式地将数据渲染进-DOM-的系统"><a href="#声明式地将数据渲染进-DOM-的系统" class="headerlink" title="声明式地将数据渲染进 DOM 的系统:"></a>声明式地将数据渲染进 DOM 的系统:</h4></li></ul><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><ul><li><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p></li><li><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><blockquote><p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量, 可以不用模板，<a href="https://cn.vuejs.org/v2/guide/render-function.html">直接写渲染 (render) 函数</a>，使用可选的 JSX 语法也是可以的</p></blockquote></li></ul><p><strong>渲染数据</strong></p><ul><li><p><strong>文本</strong></p></li><li><blockquote><p>通过双括号插值</p></blockquote></li><li><blockquote><p>v-once 进行一次性插值, 后续改变不在变化</p></blockquote></li><li><p><strong>原始 HTML</strong> 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html</p></li><li><blockquote><p>会直接渲染被标签处理过的文本内容,而不是连同标签一起输出</p><p>使用<code>&#123;&#123;..&#125;&#125;</code> 会连同标签一起输出</p></blockquote></li><li><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p></blockquote></li><li><p><strong>attribute</strong> 作用在 HTML attribute 上，遇到这种情况应该使用 v-bind</p></li><li><blockquote><p>对于布尔 attribute 如果是 null<code>、</code>undefined<code>或</code>false,那个该特性就不会渲染出来</p></blockquote></li><li><p>vue 提供了 JavaScript 表达式支持,可以在大括号中写表达式, 有个限制是只能包含<strong>单个表达式</strong></p></li><li><blockquote><p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。</p><p>你不应该在模板表达式中试图访问用户定义的全局变量</p></blockquote></li></ul><p><strong>指令</strong></p><ul><li><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute, 指令的职责是，当表达式的值改变时，将响应式地作用于 DOM</p></li><li><p><code>v-if</code> 指令将根据表达式 的值的真假来插入/移除 DOM 元素</p></li><li><p><code>v-bind</code> 指令可以用于响应式地更新 HTML attribute,</p></li><li><p><code>v-on</code> 指令，它用于监听 DOM 事件,绑定事件参数</p></li><li><blockquote><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如:</p><a v-bind:href="url"></blockquote></li><li><p>当使用 v-bind 绑定 attribute 的时,将不再是静态字符串,而是一个 JavaScript 表达式</p></li><li><pre><code>&lt; p v-bind:value=&quot;a&quot;&gt; &lt;/p&gt;//这时 a 是一个 JavaScript 表达式而不是一个字符串.如果是字母 将会被解析成表达式,必须在vue定义数字      表达式进行计算,返回一个数字作为绑定的值<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>- 动态参数: 从 <span class="hljs-number">2.6</span><span class="hljs-number">.0</span> 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数, 表达式将进行动态求值<br><br>  &gt; `&lt;<span class="hljs-keyword">a</span> v-<span class="hljs-keyword">on</span>:[<span class="hljs-title">eventName</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt; ... &lt;/<span class="hljs-title">a</span>&gt;`<br><br>- 动态参数事项:<br>- &gt; 动态参数预期会求出一个字符串，异常情况下值为 `<span class="hljs-literal">null</span>`。这个特殊的 `<span class="hljs-literal">null</span>` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。<br>  &gt;<br>  &gt; 动态参数表达式有一些语法约束:<br>  &gt;<br>  &gt; 因为某些字符，如空格和引号,放在 HTML attribute 名里是无效<br>  &gt;<br>  &gt; 还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写<br><br>  **修饰符** : 用于指出一个指令应该以特殊方式绑定<br><br>- ```html<br>  &lt;form v-<span class="hljs-keyword">on</span>:<span class="hljs-title">submit</span>.<span class="hljs-title">prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;...&lt;/<span class="hljs-title">form</span>&gt;<br> <span class="hljs-comment"> //.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</span><br></code></pre></td></tr></table></figure>**缩写:**</code></pre></li><li><blockquote><p>v-bind 缩写 =&gt; “:”</p><p>v-on 缩写 =&gt; “@”</p></blockquote></li></ul><h5 id="v-bind-绑定-class-style"><a href="#v-bind-绑定-class-style" class="headerlink" title="v-bind 绑定 class style"></a>v-bind 绑定 class style</h5><ul><li>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</li></ul><p><strong>绑定 class 基本语法:</strong></p><p>​ <strong>对象语法:</strong> 可以动态地切换 class</p><ul><li><pre><code class="html">1.把class名字内联写在模板里,通过更改isActive的bool值决定,是否渲染active类&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;2.把class名字外联写在data中的classObject对象里,通过在data中改变 bool值渲染类名&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &#39;text-danger&#39;: false &#125; &#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>  **数组语法:** 应用一个 <span class="hljs-class"><span class="hljs-keyword">class</span> 列表</span><br><br>- ```html<br>  &lt;div v-bind:<span class="hljs-class"><span class="hljs-keyword">class</span>=&quot;[<span class="hljs-title">activeClass</span>, <span class="hljs-type">errorClass]&quot;&gt;</span>&lt;<span class="hljs-type">/div</span>&gt;</span><br>  <span class="hljs-keyword">data</span>: &#123; activeClass: <span class="hljs-string">&#x27;active&#x27;</span>, errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span> &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>在数组语法中也可以使用对象语法</strong>:</p></li><li><pre><code class="html">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>*<span class="hljs-strong">*绑定在自定义组件上*</span><span class="hljs-strong">*:</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- &gt; 当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的*</span><span class="hljs-strong">*根元素*</span><span class="hljs-strong">*上面。</span><br><span class="hljs-strong">  &gt;</span><br><span class="hljs-strong">  &gt; 这个元素上已经存在的 class 不会被覆盖,即使发生重名。</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">  *</span>*<span class="hljs-strong">*</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">*</span><span class="hljs-strong">*绑定 style 基本语法:*</span><span class="hljs-strong">*</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">*</span><span class="hljs-strong">*对象语法:*</span><span class="hljs-strong">*</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">​ 内联式:</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- `v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- ```html</span><br><span class="hljs-strong">  &lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-strong">  CSS property 名可以用驼峰式 (camelCase) 或短横线分隔</span><br><span class="hljs-strong">  (kebab-case，记得用引号括起来) 来命名</span><br></code></pre></td></tr></table></figure>外联式:</code></pre></li><li><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p></li><li><pre><code class="html">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &#39;red&#39;, fontSize: &#39;13px&#39; &#125; &#125;<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><br><span class="hljs-comment">**数组语法:**数组语法可以将多个样式对象应用到同一个元素上</span><br><br>- ```html<br>  &lt;<span class="hljs-built_in">div</span> v-bind:style=<span class="hljs-string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;&lt;/<span class="hljs-built_in">div</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>自动添加前缀:</strong></p><ul><li><blockquote><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀</p></blockquote></li></ul><p><strong>多重值:</strong></p><ul><li><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值,这样写只会渲染数组中最后一个被浏览器支持的值</p></li><li><p>```html</p><div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>##### v-<span class="hljs-keyword">if</span> /v-show 条件渲染<br><br>**v-<span class="hljs-keyword">if</span> 条件渲染:**<br><br>- 条件渲染一块内容:<br><br>- ```html<br>  &lt;h1 v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;Vue is awesome!&lt;/h1&gt;<br>  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br></code></pre></td></tr></table></figure></li><li><blockquote><p>可以添加<code>v-else</code> 添加一个“else 块” : 还可以添加 <code>v-else-if</code>块</p><p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p></blockquote></li><li><p>条件渲染多个元素:</p></li><li><pre><code class="html">在&lt;template&gt;  元素上使用 v-if 条件渲染分组:  &lt;template v-if=&quot;ok&quot;&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Paragraph 1&lt;/p&gt;    &lt;p&gt;Paragraph 2&lt;/p&gt;  &lt;/template&gt;&lt;/template&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">**用 key 管理可复用的元素:</span>**<br><br>- Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.<br><br>- &gt; 即两个相同的标签,不会渲染第二个,而是复用第一个,<br>  &gt;<br>  &gt; 把标签内的值进行更换, 但是特殊情况如`input` 仅仅是替换了它的 `placeholder`,而输入内容会被复用而不是清空<br>  &gt;<br>  &gt; 因此,我们使用 key 方式,表达“这两个元素是完全独立的，不要复用它们”<br><br>- 只需添加一个具有唯一值的 `key` attribute 即可<br><br>- &gt;  &lt;input placeholder=<span class="hljs-string">&quot;Enter your email address&quot;</span> key=<span class="hljs-string">&quot;email-input&quot;</span>&gt;<br><br><span class="hljs-title">**v-show 条件渲染:</span>**<br><br>- `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。<br><br>- &gt; 注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。<br><br><span class="hljs-title">- **v-show v-if 的区别:</span>**<br><br>- &gt; v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>  &gt;<br>  &gt; 也是**惰性的**：直到条件第一次变为真时，才会开始渲染条件块。<br>  &gt;<br>  &gt; `v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换<br>- &gt; 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。<br>  &gt;<br>  &gt; 因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。<br><br>##### v-for 列表渲染<br><br><span class="hljs-title">- 用 `v-for` 指令基于一个数组来渲染一个列表:</span><br><br>- ```html<br>  &lt;li v-for=<span class="hljs-string">&quot;item in items&quot;</span>&gt;<br>    items 是源数据数组，而 item 则是被迭代的数组元素的别名<br>  &lt;/li&gt;<br>  &lt;li v-for=<span class="hljs-string">&quot;(item, index) in items&quot;</span>&gt;<br>    支持一个可选的第二个参数，即当前项的索引。<span class="hljs-number">0</span>开始 of可以代替in<br>  &lt;/li&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>用 <code>v-for</code> 来遍历一个对象的 property</p></li><li><pre><code class="html">&lt;li v-for=&quot;value in object&quot;&gt;以此遍历对象的属性值&lt;/li&gt;&lt;li v-for=&quot;(value,name) in Object&quot;&gt;&lt;/li&gt;遍历对象属性值 value 属性名 name&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;用第三个参数作为索引：&lt;/div&gt;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> &gt; 在遍历对象时，会按 <span class="hljs-code">`Object.keys()`</span> 的结果遍历，但是<span class="hljs-strong">**不能**</span>保证它的结果在不同的 JavaScript 引擎下都一致。<br><br><span class="hljs-strong">**列表渲染时状态维护**</span><br><br><span class="hljs-bullet">-</span> 当 Vue 正在更新使用 <span class="hljs-code">`v-for`</span> 渲染的元素列表时，它默认使用“<span class="hljs-strong">**就地更新**</span>”的策略。<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-strong">**如果数据项的顺序被改变**</span>，Vue 将<span class="hljs-strong">**不会移动 DOM 元素**</span>来匹配数据项的顺序，而是就地更新每个元素.只会渲染数据,不会更改 DOM 元素<br><br><span class="hljs-bullet">-</span> 这个默认的模式是高效的，但是<span class="hljs-strong">**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**</span>。(但不总是高效的)<br><span class="hljs-bullet">-</span> &gt; 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <span class="hljs-code">`key`</span> attribute<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**使用 key 值的原因:**</span><br><br>  &gt; Vue Dom 更新原理,通过 Virtual DOM diff 算法 ------ 通过对比 DOM 中的值,不一致进行更新值,直到没有数据.<br>  &gt;<br>  &gt; 例子 : 当把一条数据插入到很多数据的中间,那么它将会比对 DOM 中的数据是否一致,不一致,新的数据项将替换旧的数据项,一直渲染到没有数据,导致在中间插入一条数据,需要更新多个 DOM 的值,很没有效率.<br>  &gt;<br>  &gt; 通过添加 key 值, 我们以相同的 key 值为基准(相同的 key 之间进行对比),进行新旧 DOM 值比对,不一致进行值更新,没有的 key 值渲染新的 DOM 添加进来,这样大大提高了效率<br>  &gt;<br>  &gt; 所以一句话，key 的作用主要是在新旧 nodes 对比时辨识 VNodes,更高效的更新虚拟 DOM。<br>  &gt;<br>  &gt; 另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。<br><br><span class="hljs-bullet">-</span> key 值最好不要使用数组中的 index, 因为这会导致 key 变化,更新很多的 Dom 数据,降低效率, 例如:从中间插入数据时,会更新大量数据<br><br>  &gt; 不要使用对象或数组之类的非基本类型值作为 <span class="hljs-code">`v-for`</span> 的 <span class="hljs-code">`key`</span>。<br>  &gt;<br>  &gt; 请用字符串或数值类型的值。<br><br><span class="hljs-strong">**列表源数据(数组)的方法:**</span><br><br><span class="hljs-bullet">-</span> Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br><br><span class="hljs-bullet">-</span> 更改数组(变更方法)<br><br><span class="hljs-bullet">-</span> &gt; push() pop()<br>  &gt;<br>  &gt; shift() unshift()<br>  &gt;<br>  &gt; splice() sort() reverse()<br><br><span class="hljs-bullet">-</span> 替换数组:(非变更方法)<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">`filter()`</span>、<span class="hljs-code">`concat()`</span> 和 <span class="hljs-code">`slice()`</span>。它们不会变更原始数组，而<span class="hljs-strong">**总是返回一个新数组**</span> ,<br>  &gt;<br>  &gt; 这不会使 Vue 丢弃现有 DOM 并重新渲染整个列表,Vue 为了使得 DOM 元素得到最大范围的重用使用了优化方法<br>  &gt;<br>  &gt; 所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。<br><br><span class="hljs-bullet">-</span> 由于 JavaScript 的限制，Vue <span class="hljs-strong">**不能检测**</span>数组和对象的变化<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**直接使用过滤/排序后的结果:**</span><br><br><span class="hljs-bullet">-</span> 我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。<br><br>  &gt; 在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。使用这个数组进行渲染<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```html</span><br><span class="hljs-code">  &lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="hljs-code">  computed: &#123; evenNumbers: function () &#123;返回处理后的数组&#125; &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个方法</p></li><li><p><strong>在 v-for 里使用值</strong> :</p></li><li><pre><code class="html">`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt; //输出 1 2 3..10<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- **v-for 重复渲染多个元素:</span>**<br><br>- &gt; 可以利用带有 `v-for` 的 `&lt;template&gt;` 来循环渲染一段包含多个元素的内容<br><br><span class="hljs-title">- **使用 `v-if` 和 `v-for`:</span>**<br><br>- &gt; 当它们处于**同一节点**，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中, 当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用,在每次循环中使用 v-if 决定是否渲染出节点<br><br>  &gt; 如果你的目的是有条件地跳过循环的执行，那么可以将 `v-if` 置于外层元素<br><br><span class="hljs-title">  **在组件上使用 v-for:</span>**<br><br>- &gt; 在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。<br>  &gt;<br>  &gt; <span class="hljs-number">2.2</span>.<span class="hljs-number">0</span>+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。<br>- 然而任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop<br><br>##### v-on 处理事件<br><br><span class="hljs-title">**监听事件:</span>**<br><br>- ```html<br>  <span class="hljs-number">1</span>.直接传入js代码段<br><span class="hljs-title">  &lt;button v-on:</span>click=<span class="hljs-string">&quot;counter += 1&quot;</span>&gt;Add <span class="hljs-number">1</span>&lt;/button&gt;<br>  <span class="hljs-number">2</span>.直接调用一个方法<br><span class="hljs-title">  &lt;button v-on:</span>click=<span class="hljs-string">&quot;say(&#x27;hi&#x27;,$event)&quot;</span>&gt;Say hi&lt;/button&gt;<br>  通过特殊变量 $event 把它传入方法, 这样我们可以访问事件对象 <span class="hljs-number">3</span>.传递一个方法<br>  methods<br><span class="hljs-title">  &lt;button v-on:</span>click=<span class="hljs-string">&quot;greet&quot;</span>&gt;Greet&lt;/button&gt;<br></code></pre></td></tr></table></figure>**事件修饰符:**</code></pre></li><li><p>方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong></p></li><li><blockquote><p>.stop 停止冒泡</p><p>.prevent 阻止默认事件</p><p>.capture 捕获模式</p><p>.self 只当在 <code>event.target</code> 是当前元素自身时触发处理函数</p><p>.once 只会触发一次</p><blockquote><p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<strong>组件事件</strong>上</p></blockquote><p>.passive 会告诉浏览器你<strong>不</strong>想阻止事件的默认行为。</p><blockquote><p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告</p></blockquote></blockquote><p><strong>按键/系统修饰符:</strong></p></li><li><p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：只在满足修饰符的情况下执行事件</p></li><li><pre><code class="html">&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;&lt;input v-on:keyup.page-down=&quot;onPageDown&quot; /&gt;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- 按键码: `keyCode` 的事件用法[已经被废弃了](https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/en-US/</span>docs<span class="hljs-regexp">/Web/</span>API<span class="hljs-regexp">/KeyboardEvent/</span>keyCode)并可能不会被最新的浏览器支持。但使用 `keyCode` attribute 也是允许的：<br><br>- ```<br>  &lt;input v-on:keyup.<span class="hljs-number">13</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p><p>.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right</p><p>你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://cn.vuejs.org/v2/api/#keyCodes">自定义按键修饰符别名</a>： Vue.config.keyCodes.f1 = 112</p></blockquote></li><li><p>系统修饰符 : <code>.ctrl .alt .shift .meta</code> 仅在按下相应按键时才触发鼠标或键盘事件的监听器</p></li><li><pre><code class="html">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;&lt;!-- Ctrl + Click --&gt;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>- &gt; 请注意**修饰键与常规按键不同**，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态然后释放另一个按键。<br><br>- **`.exact` 修饰符: **允许你控制由**精确的**系统修饰符组合触发的事件。<br><br>- ```html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>**鼠标按钮修饰符: ** <code>.left</code> <code>.right</code> <code>.middle</code> 仅响应特定的鼠标按钮</p></li></ul><h5 id="v-model-处理表单输入"><a href="#v-model-处理表单输入" class="headerlink" title="v-model 处理表单输入"></a>v-model 处理表单输入</h5><ul><li><p><code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。</p></li><li><blockquote><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源,你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p></blockquote></li><li><p><strong>各个类型的表单基本用法:</strong></p></li><li><blockquote><p>1.文本/多行文本 input textarea 数据使用字符串 例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;edit me&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>vue 绑定数据 message:&quot;&quot;<br></code></pre></td></tr></table></figure><p>2.复选框 type=”checkbox” 单个复选框 : 数据使用字符串 多个复选框: 数据使用数组</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">单个复选框:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> // checked:&quot;&quot;,数据是字符串,<br>默认会显示ture false 多个单选框:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>&#123;&#123;checkedNames&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>// checkedNames:[],数据是数组, 使用value 属性进行显示<br></code></pre></td></tr></table></figure><p>数据使用数组,复选框没有 value 值 ,那么数组中显示 null, 有 value 值显示 value</p><p>数据使用字符串, 复选框没有 value 值, 显示 ture/false 并且会造成全选.</p><p>3.单选框 type=”radio”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;One&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;picked&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据使用字符串,必须有 value 值才会显示,没有 value 值会造成全选,还不会显示值</p><p>数据使用数组, 有 value 值的话也可以,也只会显示单个 value 值,没有 value 值会造成全选,不显示值</p><p>想让 radio 单选框默认被选中,必须是数据和 value 值相同, radio 不存在 true/false 值, 它只使用 value</p><p>4.选择框 <select> 数据可以是数组/字符串,有 value 显示 value 值,没有 value 值显示 option 中的值,但是都只显示一个值</p></blockquote><p><strong>表单的值(value)绑定:</strong></p></li><li><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串,这里指的是表单的 value 属性值,我们可以使用<code>v-bind</code> 绑定 value 属性到一个动态值上.</p></li><li><p>```html</p><select v-model="selected">  <option v-bind:value="number">123</option></select><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">  **修饰符:</span>**<br><br><span class="hljs-title">- **.lazy** :</span> 在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步, 使用 `lazy` 修饰符，从而转为在 `change` 事件*之后*进行同步,<br><br>- ```html<br>  &lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model.lazy=<span class="hljs-string">&quot;msg&quot;</span> /&gt; change 在失去焦点后才触发事件<br></code></pre></td></tr></table></figure></li><li><p><strong>.number</strong> : 如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符</p></li><li><blockquote><p>因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p></blockquote></li><li><p><strong>.trim</strong> : 如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p></li><li><blockquote><p>对于需要使用输入法的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。</p><p>在文本区域插值 (<code>&lt;textarea&gt;&#123;&#123;text&#125;&#125;&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p></blockquote></li></ul><p><strong>v-model 实现原理:</strong></p><ul><li><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p></li><li><blockquote><p>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</p><p>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</p><p>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</p></blockquote></li><li><p>v-model 只不过是一个语法糖而已</p></li><li><pre><code class="html">&lt;input v-model=&quot;searchText&quot; /&gt; 等价于=&gt;&lt;input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event.target.value&quot;/&gt;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- **自定义组件上使用 v-model**<br><br>- &gt; 子组件创建 prop 接受父组件传递的 <span class="hljs-keyword">value</span> 值<br>  &gt;<br>  &gt; 子组件使用$emit 触发自定义事件传递 输入的 <span class="hljs-keyword">value</span> 值<br><br>- ```vue<br>  Vue.component(<span class="hljs-string">&#x27;custom-input&#x27;</span>, &#123;<br>    props: [<span class="hljs-string">&#x27;value&#x27;</span>],<br>    <span class="hljs-keyword">template</span>: `<br>      &lt;<span class="hljs-keyword">input</span><br>        v-bind:<span class="hljs-keyword">value</span>=&quot;value&quot;<br>        v-<span class="hljs-keyword">on</span>:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;<br>      &gt;<br>    `<br>  &#125;)<br>  这样父组件就可以使用 v-model 了<br><br>  &lt;custom-<span class="hljs-keyword">input</span> v-model=&quot;searchText&quot;&gt;&lt;/custom-<span class="hljs-keyword">input</span>&gt;<br>  相当于=&gt;<br>  &lt;custom-<span class="hljs-keyword">input</span><br>    v-bind:<span class="hljs-keyword">value</span>=&quot;searchText&quot;<br>    v-<span class="hljs-keyword">on</span>:input=&quot;searchText = $event&quot;<br>  &gt;&lt;/custom-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突</p></li><li><blockquote><p>首先解释下默认利用 value input 的问题 : 在 html 正常使用 v-model,它会根据 type,选择不同的属性 和事件进行处理,这点可以参考上面的原理部分,</p><p>在 自定义组件内,就算使用 type=”checkbox”, 它也会默认使用 value input 事件(绑定别的事件/属性没有用), 会影响选框类组件的 value 属性,导致提交时的问题.</p><p>所以我们使用 <code>model</code> 解决这样的问题,这样我们可以自定义 value 值进行其他目的</p></blockquote></li><li><pre><code class="js"> Vue.component(&#39;base-checkbox&#39;, &#123;  model: &#123;    prop: &#39;checked&#39;,    event: &#39;change&#39;  &#125;,  ...  props;&#123;  checked:Boolen,  &#125;,  template: `     &lt;input      type=&quot;checkbox&quot;    v-bind:checked=&quot;checked&quot;      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;  &gt;  ` &#125; //注意使用model 选项,仍然需要在props 里声明这个 checked<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">##### 计算属性和监听器</span><br><br><span class="hljs-bullet">-</span> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,所以，对于任何复杂逻辑，你都应当使用<span class="hljs-strong">**计算属性**</span>. <span class="hljs-code">`computed: &#123; reverMessage:function()&#123;&#125;&#125;`</span><br><br><span class="hljs-bullet">-</span> 计算属性 vs 方法<br><br><span class="hljs-bullet">-</span> &gt; 我们可以将同一函数定义为一个方法而不是一个计算属性,两种方式的最终结果确实是完全相同的。然而，不同的是<span class="hljs-strong">**计算属性是基于它们的响应式依赖进行缓存的**</span>。<br>  &gt;<br>  &gt; 也就是说 计算属性中函数不发生更新, 就<span class="hljs-strong">**只返回缓存**</span>不在进行执行函数<br><br><span class="hljs-bullet">-</span> 如果你不希望有缓存，请用方法来替代。(双大括号中也可以放置方法的)<br><br><span class="hljs-bullet">-</span> 计算属性 v s 侦听属性<br><br><span class="hljs-bullet">-</span> &gt; Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<span class="hljs-strong">**侦听属性**</span>: watch,<br>  &gt;<br>  &gt; 通常更好的做法是使用计算属性而不是命令式的 <span class="hljs-code">`watch`</span> 回调<br><br><span class="hljs-bullet">-</span> 计算属性的 setter<br><br><span class="hljs-bullet">-</span> &gt; 计算属性默认只有 getter(通常返回一个值)，不过在需要时你也可以提供一个 setter<br><br><span class="hljs-strong">**侦听器 watch:**</span><br><br><span class="hljs-bullet">-</span> 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器,<br><br><span class="hljs-bullet">-</span> &gt; 当需要在<span class="hljs-strong">**数据变化时**</span>执行<span class="hljs-strong">**异步或开销较大**</span>的操作时，这个方式是最有用的。除了 <span class="hljs-code">`watch`</span> 选项之外，您还可以使用命令式的 [<span class="hljs-string">vm.$watch API</span>](<span class="hljs-link">https://cn.vuejs.org/v2/api/#vm-watch</span>)。 (开销较大的操作不应该是 使用计算属性吗??)<br><br><span class="hljs-bullet">-</span> watch 中的选项含义 <span class="hljs-code">`deep`</span> <span class="hljs-code">`immediate`</span><br><br><span class="hljs-bullet">-</span> &gt; deep : bool 告诉 Vue 使用递归方式侦听<span class="hljs-strong">**嵌套对象内部值**</span>的变化 (如果没有 deep 选项,想要侦听内部值必须手动设置),<br>  &gt;<br>  &gt; immediate :bool 侦听开始就调用函数,不在等到属性变化时再调用<br><br><span class="hljs-section">### 第二层:组件系统</span><br><br><span class="hljs-bullet">-</span> #### Vue 使用组件化进行开发<br><br><span class="hljs-section">#### 组件基础</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**什么是组件 :**</span> 组件是可复用的 Vue 实例，且带有一个名字<br><br><span class="hljs-bullet">-</span> &gt; 因为组件是可复用的 Vue 实例，所以它们与 <span class="hljs-code">`new Vue`</span> 接收相同的选项，例如 <span class="hljs-code">`data`</span>、<span class="hljs-code">`computed`</span>、<span class="hljs-code">`watch`</span>、<span class="hljs-code">`methods`</span> 以及生命周期钩子等。<br>  &gt;<br>  &gt; 仅有的例外是像 <span class="hljs-code">`el`</span> 这样根实例特有的选项。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**组件的复用:**</span> 每个组件都会各自独立维护它的数据, 可以进行任意次复用, 原因:<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-strong">**一个组件的 `data` 选项必须是一个函数**</span>，因此每个实例可以维护一份被返回对象的独立的拷贝, 如果 Vue 没有这条规则,那么 data 属性将被共享, 无法进行复用<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">`data`</span> 选项返回的数据,作用域只在<span class="hljs-strong">**组件内 模板中**</span>, 而不能作用在自定义组件上(指自定义标签)<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**组件名:**</span><br><br><span class="hljs-bullet">-</span> &gt; 两种命名方法: 推荐使用连字符的写法,因为直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>  &gt;<br>  &gt; <span class="hljs-strong">**字母全小写且必须包含一个连字符**</span>, ( kebab-case)<br>  &gt;<br>  &gt; 使用 PascalCase (<span class="hljs-strong">**首字母大写命名**</span>) 驼峰命名<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**每个组件模板内必须只有一个根元素**</span>, 模板内需要存在唯一的父元素<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**组件注册**</span>:<br><br><span class="hljs-bullet">-</span> <span class="hljs-emphasis">_全局注册_</span>:<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```js</span><br><span class="hljs-code">  Vue.component(&quot;my-component-name&quot;, &#123;</span><br><span class="hljs-code">    // ... options ...</span><br><span class="hljs-code">  &#125;);</span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>全局注册的组件可以用在其被注册之后的任何 新创建的 Vue 根实例(通过 new Vue)模板中，也包括其组件树中的所有子组件的模板中。</p><p>例如: 全局注册三个组件, 三个组件可以在各自内部中相互使用</p></blockquote></li><li><p>全局注册往往是不够理想的。如果使用 webpack 构建系统,全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中</p></li><li><p><em>局部注册:</em></p></li><li><pre><code class="js">//1.通过普通对象 来定义组件:var ComponentA = &#123;  /* ... */&#125;;//2.然后在 components 选项中定义你想要使用的组件：new Vue(&#123;  el: &quot;#app&quot;,  components: &#123;    &quot;component-a&quot;: ComponentA, //属性名是自定义便签名  &#125;,&#125;);//如果需要子组件之间使用:var ComponentA = &#123;  /* ... */&#125;;var ComponentB = &#123;  components: &#123;    &quot;component-a&quot;: ComponentA,  &#125;,  // ...&#125;;<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>- **模块系统下的组件注册注意事项:**<br><br>- 如果使用 es2015+ 模块系统,子组件局部注册<br><br>- ```<span class="javascript">javascript</span><br><span class="javascript">  <span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ComponentA&quot;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">import</span> ComponentC <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ComponentC&quot;</span>;</span><br><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    components: &#123;</span><br><span class="javascript">      ComponentA, <span class="hljs-comment">//同时代表 自定义标签名</span></span><br><span class="javascript">      ComponentC,</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-comment">// ...</span></span><br><span class="javascript">  &#125;;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>对于一些频繁用到的<strong>基础组件</strong>,我们往往会进行全局注册, 如果你使用 webpack/vue cli 构建系统,那么就可以使用 <code>require.context</code> <strong>一次性,自动化全局注册</strong>这些基础组件</p></li><li><blockquote><p><a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C">基础组件的自动化全局注册</a> 代码参考</p></blockquote></li></ul><h4 id="组件间的数据-内容传递"><a href="#组件间的数据-内容传递" class="headerlink" title="组件间的数据/内容传递"></a>组件间的数据/内容传递</h4><h5 id="父子组件之间传递数据"><a href="#父子组件之间传递数据" class="headerlink" title="父子组件之间传递数据"></a><strong>父子组件之间传递数据</strong></h5><ul><li><p><em>父组件通过 <code>prop </code>向子组件传递数据:</em></p></li><li><p>**什么是 Prop: **Prop 是你可以在组件上注册的一些自定义 attribute(不会渲染出来)。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。</p></li><li><blockquote><p>问题 : 改变这个 传递给 prop 的值 会引起外部数据的变化吗 不推荐 警告</p></blockquote></li><li><p><strong>prop 命名:</strong> HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着在 HTML 中是 kebab-case 的</p></li><li><p><strong>传递静态/动态 Prop</strong> : 直接给 prop 传入一个静态的值, 或者 v-bind 传递动态值</p></li><li><p><strong>prop 类型:</strong> 字符串形式/ 对象形式</p></li><li><p>**prop 注册: ** 给 prop 传入一个静态的值, 或者也可以使用 <code>v-bind</code> 来动态传递 prop。</p></li><li><pre><code class="html">//这里 prop 注册的是 props: [&#39;title&#39;]&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; //静态值&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post  v-for=&quot;post in posts&quot;  v-bind:key=&quot;post.id&quot;  v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;//动态值 //通过 v-bind 的动态绑定,就算是静态字符串也会被解析成js表达式<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br>- 如果你想要将一个对象的所有 property 都作为 <span class="hljs-keyword">prop</span> 传入,可以使用`v-bind=<span class="hljs-string">&quot;post&quot;</span> `, 把整个 <span class="hljs-keyword">post</span> 对象传入 <span class="hljs-keyword">prop</span><br><br>- **<span class="hljs-keyword">prop</span> 单向数据流:**<br><br>- &gt; 所有的 <span class="hljs-keyword">prop</span> 都使得其父子 <span class="hljs-keyword">prop</span> 之间形成了一个**单向下行绑定** :父级 <span class="hljs-keyword">prop</span> 的更新会向下流动到子组件中,但是反过来则不行<br>  &gt;<br>  &gt; 每次父级组件发生变更时，子组件中所有的 <span class="hljs-keyword">prop</span> 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 <span class="hljs-keyword">prop</span>。<br><br>- 两种试图改变 <span class="hljs-keyword">prop</span> 的情形 :<br><br>  &gt; 1. 子组件希望 <span class="hljs-keyword">prop</span> 当成本地的数据进行使用: 定义一个本地的 data 属性, 并将这个 <span class="hljs-keyword">prop</span> 用作其初始值：<br>  &gt; 2. <span class="hljs-keyword">prop</span> 传入后需要进行转换 : 定义一个计算属性,返回一个转换后的副本<br>  &gt;<br>  &gt; 注意 js 中数组/对象传递的是引用,所以在子组件中改变这个,会影响到父组件的状态<br><br>- **<span class="hljs-keyword">Prop</span> 验证:**<br><br>- 我们可以为组件的 <span class="hljs-keyword">prop</span> 指定验证要求, 为了定制 <span class="hljs-keyword">prop</span> 的验证方式，你可以为 `props` 中的值提供一个带有验证需求的对象，<br><br>- ```js<br>  Vue.component(<span class="hljs-string">&quot;my-component&quot;</span>, &#123;<br>    props: &#123;<br>      <span class="hljs-comment">// 多个可能的类型</span><br>      propB: [String, Number],<br><br>      <span class="hljs-comment">// 必填的字符串</span><br>      propC: &#123;<br>        <span class="hljs-keyword">type</span>: String,<br>        required: true,<br>      &#125;,<br><br>      <span class="hljs-comment">// 带有默认值的数字</span><br>      propD: &#123;<br>        <span class="hljs-keyword">type</span>: Number,<br>        default: 100,<br>      &#125;,<br><br>      <span class="hljs-comment">// 带有默认值的对象</span><br>      propE: &#123;<br>        <span class="hljs-keyword">type</span>: Object,<br>        <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br>        default: function () &#123;<br>          <span class="hljs-keyword">return</span> &#123; message: <span class="hljs-string">&quot;hello&quot;</span> &#125;;<br>        &#125;,<br>      &#125;,<br><br>      <span class="hljs-comment">// 自定义验证函数</span><br>      propF: &#123;<br>        validator: function (value) &#123;<br>          <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>          <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;danger&quot;</span>].indexOf(value) !== -1;<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;);<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>注意那些 prop 会在一个<strong>组件实例创建之前进行验证</strong>，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p></blockquote></li><li><p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。</p></li><li><p><strong>非 prop 的 attribute:</strong></p></li><li><blockquote><p>attribute 传向一个组件，但是该组件并没有相应 prop 定义.</p><p>这些 attribute 会被添加到这个组件的根元素上。对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。</p><p>但是<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来</p></blockquote></li><li><pre><code class="html">&lt;blog-post v-bind:post=&quot;post&quot; title=&quot;this is se&quot;&gt;&lt;/blog-post&gt;// 声明组件中props: [&#39;post&#39;],只有一个post属性, 那么titleattribute就会被传递给模板的根元素 // title 就是非prop的 attribute<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- 如果你**不**希望组件的根元素继承 非 prop 的 attribute，你可以在组件的选项中设置 `inheritAttrs:</span> <span class="hljs-literal">false</span>`<br><br><span class="hljs-title">- &gt; `inheritAttrs:</span> <span class="hljs-literal">false</span>` 选项**不会**影响 `style` 和 `class` 的绑定。<br><br><span class="hljs-title">- 通过`inheritAttrs:</span> <span class="hljs-literal">false</span>` 和 `$attrs`, 决定 attribute 会被赋予哪个元素,而不总是根元素<br><br>- ```html<br>  &lt;label&gt;<br>    &#123;&#123; label &#125;&#125;<br>    &lt;input v-bind=<span class="hljs-string">&quot;$attrs&quot;</span> /&gt; //通过 v-bind=<span class="hljs-string">&quot;$attrs&quot;</span> 传入内部组件<br>  &lt;/label&gt;<br></code></pre></td></tr></table></figure>***</code></pre></li></ul><p><strong>子组件通过<code>事件</code>向父组件传递数据:</strong></p><ul><li><blockquote><ol><li>子组件模板内可以通过<code>v-on:click =$emit(&#39;enlarge-text&#39;, 0.1) </code> 触发事件并传递数据</li><li>父级组件监听这个自定义事件,内联式直接处理,或者传递一个函数,在 methods 中处理</li></ol></blockquote></li><li><pre><code class="HTML">&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;  //子组件模板内&lt;blog-post  v-on:enlarge-text=&quot;postFontSize += $event&quot;  //父级组件,通过内联式处理     我们可以通过 $event 访问到被抛出的这个值：&gt;&lt;/blog-post&gt;&lt;blog-post  v-on:enlarge-text=&quot;onEnlargeText&quot;       //父级组件,通过外联式处理 , 函数第一个参数接受子组件的数据&gt;&lt;/blog-post&gt;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">##### <span class="hljs-strong">**自定义事件**</span>:</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**事件名**</span>: 不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。(触发一个 camelCase 名字的事件, 监听这个名字的 kebab-case 版本是不会有任何效果)<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">`v-on`</span> 事件监听器在 <span class="hljs-strong">**DOM 模板中**</span>会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <span class="hljs-code">`v-on:myEvent`</span> 将会变成 <span class="hljs-code">`v-on:myevent`</span>——导致 <span class="hljs-code">`myEvent`</span> 不可能被监听到。<br>  &gt;<br>  &gt; 因此，我们推荐你<span class="hljs-strong">**始终使用 kebab-case 的事件名**</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**将原生事件绑定到子组件:**</span><br><br><span class="hljs-bullet">-</span> 想要在一个组件的根元素(含有模板的父组件)上直接监听一个<span class="hljs-strong">**原生事件**</span>。这时，你可以使用 <span class="hljs-code">`v-on`</span> 的 <span class="hljs-code">`.native`</span> 修饰符： 如果不使用 native 将无法监听事件<br><br><span class="hljs-bullet">-</span> &gt; 针对组件 Vue 有自己的事件系统,在父组件山 v-on 希望监听一个自定义事件, 而不是原生事件, 所以需要加上 native 告诉他.<br>  &gt;<br>  &gt; $on $emit 并不是 addeventlistener dispatcheventlistener 的别名,这和浏览器事件是不同的两个系统<br><br><span class="hljs-bullet">-</span> &gt; 为什么在父组件 监听原生组件而不是直接在根元素上 ??<br>  &gt;<br>  &gt; 原因是 :<br>  &gt;<br>  &gt; 因为我们在使用时,经常使用父组件, 不会去特意去修改组件里的 template 模板内容, 使用 native 父组件绑定的事件传递给子组件<br>  &gt;<br>  &gt; 1.作用域的原因, 事件将使用父作用域,<br>  &gt;<br>  &gt; 2.而且不加 native,父组件绑定的事件无法传给 子组件, 不像 非 prop 的 attribute<br><br><span class="hljs-bullet">-</span> &gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">v-on:focus.native</span>=<span class="hljs-string">&quot;onFocus&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span></span><br>  &gt;<br>  &gt; //这会传递到组件上的根元素上, 但是当根元素是个特殊元素,没有该事件,父级的 <span class="hljs-code">`.native`</span> 监听器将静默失败。它不会产生任何报错<br><br><span class="hljs-bullet">-</span> 为了解决这个问题，Vue 提供了一个 <span class="hljs-code">`$listeners`</span> property，它是一个对象，里面包含了作用在这个组件上 (不含 <span class="hljs-code">`.native`</span> 修饰器的) <span class="hljs-code">`v-on`</span> 事件监听器的所有监听器,你就可以配合 <span class="hljs-code">`v-on=&quot;$listeners&quot;`</span> 将所有的事件监听器指向这个组件的某个特定的子元素<br><br>  <span class="hljs-strong">**.sync 修饰符**</span>:<span class="hljs-emphasis">_(子组件通过事件的形式,改变 prop 绑定的值, 即像父组件传递了数据)_</span><br><br><span class="hljs-bullet">-</span> 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。<br><br><span class="hljs-bullet">-</span> 这也是为什么我们推荐以 <span class="hljs-code">`update:myPropName`</span> 的模式触发事件取而代之:<br><br><span class="hljs-bullet">-</span> &gt; 在一个包含 <span class="hljs-code">`title`</span> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图<br>  &gt;<br>  &gt; <span class="hljs-code">```html</span><br><span class="hljs-code">  &gt; this.$emit(&#x27;update:title&#x27;, newTitle)</span><br><span class="hljs-code">  &gt; 然后父组件可以监听那个事件并根据需要更新一个本地的数据 property</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; &lt;text-document</span><br><span class="hljs-code">  &gt;   v-bind:title=&quot;doc.title&quot;</span><br><span class="hljs-code">  &gt;   v-on:update:title=&quot;doc.title = $event&quot;</span><br><span class="hljs-code">  &gt; &gt;</span><br><span class="hljs-code">  &gt; &lt;/text-document&gt;</span><br></code></pre></td></tr></table></figure>&gt;&gt; 我们为这种模式提供一个缩写，即 `.sync` 修饰符, 类似于 v-model 也是一个语法糖&gt;&gt; <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title.sync</span>=<span class="hljs-string">&quot;doc.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span> // 子组件设置<br>this.$emit(&#x27;update:title&#x27;, newTitle) // 父组件将会自动绑定prop<br>并且添加用于更新的 v-on 监听器。<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p></li><li><pre><code class="html">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;//用在一个字面量的对象上，例如 v-bind.sync=”&#123; title: doc.title&#125;”，也是无法正常工作的<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 注意带有 `.sync` 修饰符的 `v-bind` **不能**和表达式一起使用, 你只能提供你想要绑定的 property 名<br><br>##### **通过插槽传递内容**<br><br>- 和 HTML 元素一样，我们经常需要向一个组件传递内容，(注意不是数据 而是内容)<br><br><span class="hljs-title">_插槽的基本用法_::</span><br><br><span class="hljs-title">- **插槽内容:</span>**<br><br>- ```html<br><span class="hljs-title">  父组件:</span><br>  &lt;navigation-link url=<span class="hljs-string">&quot;/profile&quot;</span>&gt; Your Profile &lt;/navigation-link&gt;<br><br><span class="hljs-title">  子组件:</span><br><span class="hljs-title">  &lt;a v-bind:</span>href=<span class="hljs-string">&quot;url&quot;</span> class=<span class="hljs-string">&quot;nav-link&quot;</span>&gt;<br>    &lt;slot&gt;当组件渲染的时候，将会被替换为“Your Profile”。&lt;/slot&gt;<br>  &lt;/a&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>如果子组件中没有<slot>标签 , 父组件的内容将会被抛弃</p><p><strong>slot 插槽可以包含任何模板代码</strong>, 可以是 html 标签…</p></blockquote></li><li><p><strong>后备内容:</strong>(插槽的默认内容)</p></li><li><pre><code class="html">例如在一个&lt;submit-button&gt;  组件template中:  &lt;button type=&quot;submit&quot;&gt;    &lt;slot&gt;Submit&lt;/slot&gt;  &lt;/button&gt;&lt;/submit-button&gt;<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml">- **插槽中使用数据:**</span><br><br><span class="xml">- ```html</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="xml">    Logged in as </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>当你想在一个插槽中使用数据时, 这里的作用域只能使用和父组件作用域一样的,(使用 vue 实例中的数据)</p><p>而子组件只能使用, Vue 组件定义内数据, 两个作用域<strong>相互独立</strong> =&gt;</p><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p></blockquote></li><li><p><strong>作用域插槽:</strong></p></li><li><blockquote><p>让插槽内容能够访问子组件作用域的数据*, 插槽内容作用域和子组件的作用域是独立的, 使用作用域插槽,可以访问到子组件的作用域</p></blockquote></li><li><pre><code class="html">&lt;current-user&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;  //将包含所有插槽 prop 的对象命名为 slotProps    &#123;&#123; slotProps.user.firstName &#125;&#125;  &lt;/template&gt;&lt;/current-user&gt;子组件 :  &lt;span&gt;    &lt;slot v-bind:user=&quot;user&quot;&gt;   // 绑定在 &lt;slot&gt; 元素上的 attribute 被称为插槽 prop,通过该prop访问子组件的数据      &#123;&#123; user.lastName &#125;&#125;    &lt;/slot&gt;  &lt;/span&gt;<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml">- 在上述情况下，当被提供的内容*只有*默认插槽时，组件的标签才可以被当作插槽的模板来使用。不再使用 template</span><br><br><span class="xml">- ```html</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span><br><span class="xml">  //default 也可以省略</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确,只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="xml">...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>解构插槽 prop</strong>:</p></li><li><blockquote><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里:</p><ul><li>function (slotProps) { // 插槽内容 }</li><li>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。可以使用<strong>解构语法</strong>来<strong>传入具体的插槽 prop</strong>: 在该插槽提供了多个 prop 的时候很有用</li></ul></blockquote></li><li><pre><code class="html">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125; &lt;/current-user&gt;prop 重命名:&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt;  &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt;定义后备内容，用于插槽 prop 是 undefined 的情形:&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &#39;Guest&#39; &#125; &#125;&quot;&gt;  &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt;<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>- **具名插槽:**(_多个插槽时需要起名字_)<br><br>- <span class="hljs-string">``</span><span class="hljs-string">``</span>html<br>  <span class="hljs-comment">//&lt;base-layout</span><br>    &gt;组件的template中:<br>    &lt;div&gt;<br>      &lt;header&gt;<br>        &lt;slot name=<span class="hljs-string">&quot;header&quot;</span>&gt;&lt;/slot&gt;<br>      &lt;/header&gt;<br>      &lt;main&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>      &lt;/main&gt;<br>    &lt;/div&gt;<br><br>    &lt;base-layout<br>      &gt;组件中:<br><br>      &lt;base-layout&gt;<br>        &lt;template v-slot:header&gt;<br>          &lt;h1&gt;Here might be a page title&lt;/h1&gt;<br>        &lt;/template&gt;<br><br>        &lt;p&gt;A paragraph <span class="hljs-keyword">for</span> the main content.&lt;/p&gt;<br>        &lt;p&gt;And another one.&lt;/p&gt;<br>      &lt;/base-layout&gt;<br></code></pre></td></tr></table></figure>  &lt;/base-layout&gt;&lt;/base-layout&gt;</code></pre></li><li><blockquote><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p></blockquote></li><li><p>默认插槽内容也可以使用<template v-slot:default> </template> 包裹起来</p></li><li><blockquote><p>默认插槽内容没有被包裹在<code>&lt;template&gt;</code>中 和包裹在<template v-slot:default> </template> 中的元素,后者优先级更高</p></blockquote></li><li><p><em>v-slot 只能添加在 <template> 上</em></p></li><li><p><strong>动态插槽名 :</strong></p></li><li><pre><code class="html">&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt; &lt;/template&gt;&lt;/base-layout&gt;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**具名插槽的缩写**</span>: <span class="hljs-code">`v-slot`</span>: 替换为字符 <span class="hljs-code">`#`</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**废弃语法:**</span><br><br><span class="hljs-bullet">-</span> &gt; 带有 slot attribute 的具名插槽 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span></span><br>  &gt;<br>  &gt; 带有 slot-scope attribute 的作用域插槽<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><br><span class="hljs-section">#### 组件切换(动态组件) / 异步组件:</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`is attribute`</span><br><br><span class="hljs-bullet">-</span> 有的时候，在<span class="hljs-strong">**不同组件之间进行动态切换**</span>是非常有用的,可以通过 Vue 的 <span class="hljs-code">`&lt;component&gt;`</span> 元素加一个特殊的 <span class="hljs-code">`is`</span> attribute 来实现:<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```html</span><br><span class="hljs-code">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; `currentTabComponent `</span><br><span class="hljs-code">  可以是 已注册组件的名字，或 一个组件的选项对象(带有component选项的对象)</span><br><span class="hljs-code">  注意和注册组件 components 选项的区别</span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p><code>is attribute </code>可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。</p><p>意味着像 <code>value</code> 这样的 property,只能表示用户输入的值,而不是预设的值 参考 js attr property 区别 value 只能从特性 同步到 属性 你需要使用 .prop 修饰器</p></blockquote></li><li><p><strong>解析 DOM 模板时的注意事项:</strong></p></li><li><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p></li><li><pre><code>&lt;table&gt;  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt;   //无法解析该自定义组件&lt;table  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;   // 使用 is  attribute 解决该状况&lt;/table&gt;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> 但是从以下来源使用模板,这条限制不存在 :<br><br><span class="hljs-selector-tag">-</span> &gt; <span class="hljs-selector-tag">-</span> 字符串 (例如：<span class="hljs-built_in">`template: &#x27;...&#x27;`</span>)<br>  &gt; <span class="hljs-selector-tag">-</span> <span class="hljs-selector-attr">[单文件组件 (`.vue`)]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//cn.vuejs.org/v2/guide/single-file-components.html)</span><br>  &gt; - &lt; script type=<span class="hljs-string">&quot;text/x-template&quot;</span>&gt;<br>- **<span class="hljs-attribute">keep-alive</span>:**<br><br>- 使用 <span class="hljs-built_in">`is`</span> attribute 来切换不同的组件,当在这些组件之间切换的时候，会重新渲染这些组件, 你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。 :可以用一个 <span class="hljs-built_in">`&lt;keep-alive&gt;`</span> 元素将其动态组件包裹起来。<br><br>- <span class="hljs-built_in">``</span>`html<br>  &lt;keep-alive&gt;<br>    &lt;component <span class="hljs-attribute">v-bind</span>:is=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;&lt;/component&gt;<br>  &lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>异步组件:</strong></p></li><li><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件, 这个工厂函数会异步解析你的组件定义。</p></li><li><blockquote><p>…待拓展</p></blockquote></li><li><pre><code class="vue">Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template:&#39;&lt;div&gt;I am async!&lt;/div&gt;&#39; &#125;) &#125;, 1000) &#125;)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">#### 处理边界情况</span><br><br><span class="hljs-bullet">-</span> &gt; 这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**访问元素&amp;组件**</span><br><br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**访问根/父级组件实例:**</span><br><br><span class="hljs-bullet">  -</span> 每个 <span class="hljs-code">`new Vue`</span> 实例的子组件中, 通过 <span class="hljs-code">`$root`</span> property 进行访问根实例<br><br><span class="hljs-bullet">  -</span> &gt; <span class="hljs-code">`this.$root.foo `</span> //获取根实例的数据<br><br><span class="hljs-bullet">  -</span> 和 <span class="hljs-code">`$root`</span> 类似, <span class="hljs-code">`$parent`</span> property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。<br><br><span class="hljs-bullet">  -</span> 但是对于嵌套过深的父子元素推荐<span class="hljs-strong">**依赖注入**</span><br><br><span class="hljs-bullet">  -</span> &gt; 依赖注入 : 实例选项：<span class="hljs-code">`provide`</span> 和 <span class="hljs-code">`inject`</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; `provide` 选项允许我们指定我们想要**提供**给后代组件的数据/方法。在父级组件中定义</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; 然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的 property</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - 依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - **访问子组件实例或子元素:**</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - 尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里**直接访问一个子组件**。通过 `$ref` :</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - ```html</span><br><span class="hljs-code">    访问子组件</span><br><span class="hljs-code">    &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br><span class="hljs-code">    this.$refs.usernameInput 访问子元素 (甚至可以在父级组件中访问)</span><br><span class="hljs-code">    &lt;input ref=&quot;input&quot; /&gt;</span><br><span class="hljs-code">    this.$refs.input.focus()</span><br></code></pre></td></tr></table></figure>- &gt; `$refs` 只会在组件渲染完成之后生效，并且它们不是响应式的, 你应该避免在模板或计算属性中访问 `$refs`。  &gt;  &gt; 当 `ref` 和 `v-for` 一起使用的时候，你得到的 ref 将会是一个包含了对应数据源的这些子组件的数组。</code></pre></li><li><p><strong>程序化的事件侦听器:</strong></p></li><li><blockquote><p>Vue 实例同时在其事件接口中提供了其它的方法。</p><p>你通常不会用到这些，但是当你需要在一个<strong>组件实例(methods 选项中)上手动侦听事件</strong>时，它们是派得上用场的</p></blockquote></li><li><blockquote><ul><li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li><li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li><li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li></ul></blockquote></li><li><p><strong>循环引用:</strong></p></li><li><p><strong>组件本身的循环引用:</strong></p></li><li><p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事：</p></li><li><blockquote><p>使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p></blockquote></li><li><pre><code class="html">template: &#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 请确保递归调用是条件性的(使用 v-if) , 否则组件将会导致“max stack size exceeded”错误(组件无限循环)<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**组件之间的循环引用:**</span><br><br><span class="hljs-bullet">-</span> 两个组件互相依赖,如果你使用一个<span class="hljs-emphasis">*模块系统*</span>依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误,这时候需要把某个子组件首先注册出来, 或者使用异步加载<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**模板定义的替代品:**</span><br><br><span class="hljs-bullet">-</span> 内联模板 : <span class="hljs-code">`inline-template`</span> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```html</span><br><span class="hljs-code">  &lt;my-component inline-template&gt;</span><br><span class="hljs-code">    &lt;div&gt;</span><br><span class="hljs-code">      &lt;p&gt;These are compiled as the component&#x27;s own template.&lt;/p&gt;</span><br><span class="hljs-code">      &lt;p&gt;Not parent&#x27;s transclusion content.&lt;/p&gt;</span><br><span class="hljs-code">    &lt;/div&gt;</span><br><span class="hljs-code">  &lt;/my-component&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p></blockquote></li><li><p>X-Template: 在一个 <code>&lt;script&gt;</code> 元素中，带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。</p></li><li><pre><code class="html">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;  &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&#39;hello-world&#39;, &#123; template: &#39;#hello-world-template&#39; &#125;)<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> **控制更新<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- 强制更新 : [<span class="hljs-string">`$forceUpdate`</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/cn.vuejs.org/v</span>2/api/<span class="hljs-comment">#vm-forceUpdate)</span></span><br><br><span class="ruby">- 通过 <span class="hljs-string">`v-once`</span> 创建低开销的静态组件<span class="hljs-symbol">:</span></span><br><br><span class="ruby">- &gt; 组件包含了**大量**静态内容。在这种情况下，你可以在根元素上添加 <span class="hljs-string">`v-once`</span> attribute 以确保这些内容只计算一次然后缓存起来, (这导致的副作用是, 该内容是无法进行更新的)</span><br><br><span class="ruby">- <span class="hljs-string">``</span><span class="hljs-string">`html</span></span><br><span class="ruby">  Vue.component(<span class="hljs-string">&#x27;terms-of-service&#x27;</span>, &#123; <span class="hljs-symbol">template:</span> <span class="hljs-string">`</span></span><br><span class="ruby">  &lt;div v-once&gt;</span><br><span class="ruby">    &lt;h1&gt;Terms of Service&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="ruby">    ... a lot of static content ...</span><br><span class="ruby">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="ruby">  <span class="hljs-string">` &#125;)</span></span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="番外-Vue-过渡动画"><a href="#番外-Vue-过渡动画" class="headerlink" title="番外: Vue 过渡动画"></a>番外: Vue 过渡动画</h3><h4 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h4><ul><li><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果</p></li><li><blockquote><ul><li>在 CSS 过渡和动画中自动应用 class(可以使用第三方 css 动画库 Animate.css 自定义)</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM ,(可以使用第三方 JavaScript 动画库 Velocity.js)</li></ul></blockquote></li><li><p><strong>单元素/组件的过渡:</strong> 使用<code>transition</code> 的封装组件</p></li><li><blockquote><p>在下列情形中,可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 <code>v-if</code>)</li><li>条件展示 (使用 <code>v-show</code>)</li><li>动态组件</li><li>组件根节点</li></ul></blockquote></li><li><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p></li><li><blockquote><p>1.检查元素是否应用了 css 过渡/动画, 如果是在恰当的时机添加/删除类名</p><p>2.过渡组件是否提供了 JavaScript 钩子函数, 这些钩子函数在恰当时机调用</p><p>3.如果以上都没有找到, 立即执行 DOM 操作</p></blockquote><ul><li><strong>过渡的类名:</strong></li></ul></li><li><blockquote><ol><li><code>v-enter</code>：元素进入过渡的开始状态, 元素插入 dom 之前,添加该类到元素中,元素插入的<strong>下一帧</strong>移除</li><li><code>v-enter-active</code>：进入过渡状态激活应用该类。在元素插入 DOM 之前添加该类到元素 ,在过渡/动画完成之后移除</li><li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入 DOM 之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，<strong>下一帧</strong>被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li></ol><p>没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 则 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p></blockquote><ul><li><blockquote><p>一般不设置 <code>v-enter-to</code> <code>v-leave</code> 类</p><p>因为 <code>v-enter-to</code>在结束动画时该类会被移除,移除后样式恢复默认(会发生突然变化无法保存最后的样式效果), 不添加时,直接应用 v-enter 类往默认的样式过渡</p><p><code>v-leave</code>类 在离开过渡时立即生效,下一帧移除,导致看不到初始效果(看起来还是默认效果)</p></blockquote></li><li><p><strong>css 过渡&amp;动画:</strong></p></li><li><pre><code class="html">插入或删除包含在 `transition` 组件中的元素,自动应用类完成过渡&lt;transition name=&quot;slide-fade&quot;&gt;  &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;&lt;/transition&gt;.slide-fade-enter-active &#123; transition: all .3s ease; &#125;...省略<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  - CSS 动画用法同 CSS 过渡，区别是在动画中 `v-enter` 类名在节点插入 DOM 后不会立即删除，而是在 `animationend` 事件触发时删除。<br><br><span class="hljs-title">  - **自定义过渡的类名(使用第三方 css 库):</span>**<br><br>- &gt; 我们可以通过以下 attribute 来自定义过渡类名：<br>  &gt;<br>  &gt; - `enter-class`<br>  &gt; - `enter-active-class`<br>  &gt; - `enter-to-class` (<span class="hljs-number">2.1</span>.<span class="hljs-number">8</span>+)<br>  &gt; - `leave-class`<br>  &gt; - `leave-active-class`<br>  &gt; - `leave-to-class` (<span class="hljs-number">2.1</span>.<span class="hljs-number">8</span>+)<br><br>  - ```html<br>    &lt;link<br>      href=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span><br>      rel=<span class="hljs-string">&quot;stylesheet&quot;</span><br>      type=<span class="hljs-string">&quot;text/css&quot;</span><br>    /&gt;<br>    &lt;transition<br>      name=<span class="hljs-string">&quot;custom-classes-transition&quot;</span><br>      enter-active-class=<span class="hljs-string">&quot;animated tada&quot;</span><br>      leave-active-class=<span class="hljs-string">&quot;animated bounceOutRight&quot;</span><br>    &gt;<br>      &lt;p v-if=<span class="hljs-string">&quot;show&quot;</span>&gt;hello&lt;/p&gt;<br>    &lt;/transition&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>同时使用过渡和动画:</strong> 使用过渡 动画其中一种, Vue 能自动识别类型并设置监听,事件是否完成。在一些场景中，你需要给同一个元素同时设置两种过渡动效，</p></li><li><blockquote><p>在这种情况中，你就需要使用 <code>type</code> attribute 并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p></blockquote></li><li><p><strong>显性的过渡持续时间:</strong> 默认情况下，Vue 会等待其在过渡效果的根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</p></li><li><blockquote><p>你可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间 ,在过渡/动画上的事件失效</p><p><transition :duration="{ enter: 500, leave: 800 }">…</transition></p></blockquote></li><li><p><strong>JavaScript 钩子:</strong></p></li><li><p>```html<br>&lt;transition<br>  v-on:before-enter=”beforeEnter”<br>  v-on:enter=”enter”<br>  v-on:after-enter=”afterEnter”<br>  v-on:enter-cancelled=”enterCancelled”<br>  v-on:before-leave=”beforeLeave”<br>  v-on:leave=”leave”<br>  v-on:after-leave=”afterLeave”<br>  v-on:leave-cancelled=”leaveCancelled”</p><blockquote></blockquote>  <!-- ... --></transition>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>  - 当只用 JavaScript 过渡(**只在钩子函数中定义样式变化**,一般使用第三方 js 库在钩子函数中实现)的时候，**在 `enter` 和 `leave` 中必须使用 `done` 进行回调**。否则，它们将被同步调用，过渡会立即完成。<br><br>  - &gt; 推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=&quot;false&quot;`，Vue 会跳过 CSS 的检测。<br><br>- **初始渲染的过渡:** 初始渲染过渡就是界面初始化时的过渡，在界面刚打开或刚刷新的时候就进入过渡渲染。<br><br>  &gt; 可以通过 `appear` attribute 或者`v-on:appear `设置节点在初始渲染的过渡, 设置类(appear-class...)样式<br><br>- 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。自定义 JavaScript 钩子：<br><br>- ```html<br>  &lt;transition<br>    appear<br>    appear-class=&quot;custom-appear-class&quot;<br>    appear-to-class=&quot;custom-appear-to-class&quot;<br>    (2.1.8+)<br>    appear-active-class=&quot;custom-appear-active-class&quot;<br>  &gt;<br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>多个元素的过渡:</strong></p></li><li><blockquote><p>对于原生标签可以使用 <code>v-if</code>/<code>v-else</code></p><p>当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p></blockquote></li><li><p>也可以通过给同一个元素的 <code>key</code> attribute 设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code></p></li><li><p><strong>过渡模式:</strong></p></li><li><p><code>&lt;transition&gt;</code> 的默认行为 - 进入和离开过渡同时发生。</p><ul><li><blockquote><ul><li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li><li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul></blockquote></li></ul></li><li><p><strong>多个组件间的过渡:</strong></p></li><li><blockquote><p>我们只需要使用绑定 is , 使用动态组件</p></blockquote></li><li><p><strong>列表过渡:</strong></p></li><li><p>以上都是单个元素/组件的过渡,或者同一时间多个节点中的一个, 如何同时渲染一个列表?</p></li><li><blockquote><p>使用 <transition-group> 组件, 不同于<transition></p><ol><li>它默认是一个<span>作为根节点, 可以通过 tag=”” 更换其他的元素</li><li>过渡模式不可用,因为不再切换特定元素,</li><li>内部元素<strong>总是需要</strong>一个 key, 因为 vue 高度复用 dom 节点的问题, 不加 key 造成指定的 DOM 节点并没有动态变化</li><li>css 过渡/动画都是应用在内部的元素中, 而不是这个容器中</li></ol></blockquote></li><li><p><strong>列表的进入/离开过渡:</strong></p></li><li><pre><code class="html">&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt;  &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;  &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;  &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;    &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;      &#123;&#123; item &#125;&#125;    &lt;/span&gt;  &lt;/transition-group&gt;&lt;/div&gt;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**列表的排序过渡:**</span>(即被动移动元素的平滑过渡)<br><br><span class="hljs-bullet">-</span> 在操作元素的位置变化时，由于 DOM 文档流的变化，会同时引起其它（邻近）节点元素的位置变化, 对于这些“被动”移动的元素来说，也可以实现过渡，这就用到了<span class="hljs-code">`v-move`</span> 特性。<br><br><span class="hljs-bullet">-</span> &gt;      1.<span class="hljs-strong">**`v-move` class**</span>，它会在元素的<span class="hljs-strong">**改变定位的过程中**</span>(交换数据位置也算改变定位)应用。<br>  &gt;<br>  &gt; 可以通过 <span class="hljs-code">`name`</span> attribute 来自定义前缀，也可以通过 <span class="hljs-code">`move-class`</span> attribute 手动设置<br>  &gt;<br>  &gt; 2. 也可以给列表的所有元素都添加一个类，直接给这个类设置 CSS transition 属性，元素移动的时候自动获得 v-move。<br>  &gt; 3. 用 splice 删除数组的元素，由于删除的元素经历过渡时，始终占据文档流的这个位置，导致下一个元素要等待其过渡结束,DOM 移除时才移动过来，造成一个生硬的效果。要达到平滑过渡，就要在删除元素 leave-active 阶段用 position:absolute 将其移出文档流，后面的元素才能同时平滑过渡过来<br>  &gt;<br>  &gt; 内部的实现，Vue 使用了一个叫 [<span class="hljs-string">FLIP</span>](<span class="hljs-link">https://aerotwist.com/blog/flip-your-animations/</span>) 简单的动画队列,使用 transforms 将元素从之前的位置平滑过渡新的位置。<br>  &gt;<br>  &gt; 需要注意的是使用 FLIP 过渡的元素不能设置为 <span class="hljs-code">`display: inline`</span> 。作为替代方案，可以设置为 <span class="hljs-code">`display: inline-block`</span> 或者放置于 flex 中<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**列表的交错过渡:**</span> 通过 data attribute 数据 和 js 钩子函数, 直接在函数中根据 data 操作过渡时间, 形成交错过渡的效果<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**可复用的过渡:**</span> 要创建一个可复用过渡组件，你需要做的就是将 <span class="hljs-code">`&lt;transition&gt;`</span> 或者 <span class="hljs-code">`&lt;transition-group&gt;`</span> 作为根组件<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**动态过渡:**</span> 在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 <span class="hljs-code">`name`</span> attribute 来绑定动态值。<br><br><span class="hljs-bullet">-</span> &gt; 不仅仅只有 attribute 可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。根据数据 使用 js 过渡会有不同的表现<br><br><span class="hljs-section">#### 状态过渡</span><br><br><span class="hljs-bullet">-</span> 数据元素本身的动效, 这些数据要么本身就以数值形式存储，要么可以转换为数值。<br><br><span class="hljs-bullet">-</span> 比如：<br><br><span class="hljs-bullet">  -</span> 数字和运算<br><span class="hljs-bullet">  -</span> 颜色的显示<br><span class="hljs-bullet">  -</span> SVG 节点的位置<br><span class="hljs-bullet">  -</span> 元素的大小和其他的 property<br><br><span class="hljs-bullet">-</span> 通过侦听器我们能监听到任何数值 property 的数值更新, 再使用第三方动画库, 实现数据的动效<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**动态状态过渡:**</span> 类似于组件的动态过渡<br><br><span class="hljs-bullet">-</span> &gt; 管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，可以提取到子组件中。<br><br><span class="hljs-section">### 其他</span><br><br><span class="hljs-section">#### 可复用性&amp;&amp;组合</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**混入(mixin)**</span> : 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。<br><br><span class="hljs-bullet">-</span> 一个混入对象可以包含<span class="hljs-strong">**任意组件选项**</span>。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项<br><br><span class="hljs-bullet">-</span> 混合语法:<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```javascript</span><br><span class="hljs-code">  var myMixin = &#123;</span><br><span class="hljs-code">    created: function () &#123;</span><br><span class="hljs-code">      this.hello();</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">    methods: &#123;</span><br><span class="hljs-code">      hello: function () &#123;</span><br><span class="hljs-code">        console.log(&quot;hello from mixin!&quot;);</span><br><span class="hljs-code">      &#125;,</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">  &#125;;</span><br><span class="hljs-code">  var Component = Vue.extend(&#123;</span><br><span class="hljs-code">    //使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</span><br><span class="hljs-code">    mixins: [myMixin],</span><br><span class="hljs-code">  &#125;);</span><br><span class="hljs-code"></span><br><span class="hljs-code">  var component = new Component(); // =&gt; &quot;hello6 from mixin!&quot;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>混合规则:</p></li><li><blockquote><p>数据对象(data)在内部会进行递归合并，并在发生冲突时以组件数据优先。</p><p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p></blockquote></li><li><p>全局混入:一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例。</p></li><li><pre><code class="js">Vue.mixin(&#123;  created: function () &#123;    var myOption = this.$options.myOption;    if (myOption) &#123;      console.log(myOption);    &#125;  &#125;,&#125;);<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 自定义选项混合规则:<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">`Vue.config.optionMergeStrategies`</span> 添加一个函数<br><br><span class="hljs-section">#### <span class="hljs-strong">**自定义指令:**</span></span><br><br><span class="hljs-bullet">-</span> Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。<br><br><span class="hljs-bullet">-</span> 自定义指令:<br><br><span class="hljs-bullet">-</span> &gt; 定义全局指令:<br>  &gt;<br>  &gt; Vue.directive(&#x27;指令 name&#x27;, &#123;&#125;);<br>  &gt;<br>  &gt; 定义局部指令:<br>  &gt;<br>  &gt; 组件中也接受一个 <span class="hljs-code">`directives`</span> 的选项<br><br><span class="hljs-bullet">-</span> 一个指令定义对象可以提供如下几个<span class="hljs-strong">**钩子函数**</span>:<br><br><span class="hljs-bullet">-</span> &gt; bind 只调用一次，指令第一次绑定到元素时调用。<br>  &gt;<br>  &gt; inserted 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>  &gt;<br>  &gt; update 所在组件的 VNode 更新时调用，<span class="hljs-strong">**但是可能发生在其子 VNode 更新之前**</span>。<br>  &gt;<br>  &gt; componentUpdated 指令所在组件的 VNode <span class="hljs-strong">**及其子 VNode**</span> 全部更新后调用。<br>  &gt;<br>  &gt; unbind 只调用一次，指令与元素解绑时调用。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**指令的参数可以是动态的**</span>。例如，在 <span class="hljs-code">`v-mydirective:[argument]=&quot;value&quot;`</span> 中，<span class="hljs-code">`argument`</span> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。通过调用 binding.arg 来获取该动态值<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**函数简写**</span>:你可能想在 <span class="hljs-code">`bind`</span> 和 <span class="hljs-code">`update`</span> 时触发相同行为，而不关心其它的钩子<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```javascript</span><br><span class="hljs-code">  Vue.directive(&quot;color-swatch&quot;, function (el, binding) &#123;</span><br><span class="hljs-code">    el.style.backgroundColor = binding.value;</span><br><span class="hljs-code">  &#125;);</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>对象字面量 :</strong> 如果指令需要多个值，可以传入一个 JavaScript 对象字面量</p></li><li><pre><code>&lt;div v-demo=&quot;&#123; color: &#39;white&#39;, text: &#39;hello!&#39; &#125;&quot;&gt;&lt;/div&gt;//通过binding.value.color , binding.value.text调用<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>#### **渲染函数&amp;&amp;JSX**<br><br>- Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。但是有时候你需要**动态编辑模板**中内容,需要 js 的完全编程控制,这是需要 渲染函数<br><br>- &gt; 模板 也是一种限制, 渲染函数可以对渲染的模板进行完全的编辑, 利用函数控制渲染出的 DOM<br><br>- **vue 更新 DOM 方法:**<br><br>- &gt; <span class="hljs-number">1.</span>在 vue 里使用模板 &lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt;<br>  &gt;<br>  &gt; <span class="hljs-number">2.</span>或者使用渲染函数 :<br>  &gt;<br>  &gt; render: function (createElement) &#123;<br>  &gt;<br>  &gt; <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-keyword">this</span>.blogTitle)<br>  &gt;<br>  &gt; &#125;<br>  &gt;<br>  &gt; 在这两种情况下，Vue 都会自动保持页面的更新<br><br>- **vue 更新 DOM 原理:**<br><br>- **虚拟 DOM** : Vue 通过建立一个**虚拟 DOM** 来追踪自己要如何改变真实 DOM<br><br>- &gt; <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-keyword">this</span>.blogTitle)<br>  &gt;<br>  &gt; createElement 返回的不是一个实际的 DOM 元素, 而是 createNodeDescription, 它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点包括及其子节点的描述信息。<br>  &gt;<br>  &gt; 我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“**VNode**”。<br><br>- **渲染函数:**<br><br>- **createElement 参数**<br><br>- ```javascript<br>  createElement(<br>    <span class="hljs-comment">// &#123;String | Object | Function&#125;</span><br>    <span class="hljs-comment">// 一个 HTML 标签名、组件选项对象，或者</span><br>    <span class="hljs-string">&quot;div&quot;</span>,<br><br>    <span class="hljs-comment">// &#123;Object&#125;</span><br>    <span class="hljs-comment">// 一个与模板中 attribute 对应的数据对象。可选。</span><br>    &#123;<br>      <span class="hljs-comment">// 允许你绑定普通的 HTML attribute</span><br>      <span class="hljs-class"><span class="hljs-keyword">class</span>: <span class="hljs-type">&#123;</span></span><br>        foo: <span class="hljs-literal">true</span>,<br>        bar: <span class="hljs-literal">false</span>,<br>      &#125;,<br>      domProps: &#123;<br>        innerHTML: <span class="hljs-string">&quot;baz&quot;</span>,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-comment">// &#123;String | Array&#125;</span><br>    <span class="hljs-comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，</span><br>    <span class="hljs-comment">// 也可以使用字符串来生成“文本虚拟节点”。可选。</span><br>    [<br>      <span class="hljs-string">&quot;先写一些文字&quot;</span>,<br>      createElement(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-string">&quot;一则头条&quot;</span>),<br>      createElement(MyComponent, &#123;<br>        props: &#123;<br>          someProp: <span class="hljs-string">&quot;foobar&quot;</span>,<br>        &#125;,<br>      &#125;),<br>    ]<br>  );<br></code></pre></td></tr></table></figure></code></pre></li><li><p>待拓展<code>createElement</code> 函数…</p></li><li><p><strong>使用 JavaScript 代替模板功能:</strong></p></li><li><blockquote><p>只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。</p><p>比如 : 模板中的 v-if v-for , 在渲染函数中使用 js 的 if/else/map 重写即可</p></blockquote></li><li><p>渲染函数中没有与 <code>v-model</code> 的直接对应——你必须自己实现相应的逻辑</p></li><li><p>对于 <code>.passive</code>、<code>.capture</code> 和 <code>.once</code> 这些事件修饰符, Vue 提供了相应的前缀可以用于 <code>on</code>(createlement 函数中)</p></li><li><p>你可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-slots"><code>this.$slots</code></a> 访问静态插槽的内容，每个插槽都是一个 VNode 数组, 也可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-scopedSlots"><code>this.$scopedSlots</code></a> 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数</p></li><li><p>JSX : 在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上。</p></li></ul><p><strong>模板编译:</strong></p><ul><li>Vue 的模板实际上被编译成了渲染函数</li></ul><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul><li><p>使用插件: 通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p></li><li><blockquote><p><code>Vue.use</code> 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p><p>Vue.js 官方提供的一些插件 (例如 <code>vue-router</code>) 在检测到 <code>Vue</code> 是可访问的全局变量时会自动调用 <code>Vue.use()</code>。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 <code>Vue.use()</code>：</p></blockquote></li><li><p>开发插件 : Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p></li></ul><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><ul><li><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。</p></li><li><blockquote><p>过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。</p></blockquote></li><li><pre><code class="js">//过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;局部过滤器:  在一个组件的选项中定义filters: &#123;  capitalize: function (value) &#123;    if (!value) return &#39;&#39;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)  &#125;&#125;</code></pre></li></ul><p>  全局过滤器： 在创建 Vue 实例之前使用函数<br>  Vue.filter(‘capitalize’, function (value) {<br>    if (!value) return ‘’<br>  value = value.toString()<br>    return value.charAt(0).toUpperCase() + value.slice(1)<br>  })</p><pre><code>- 当全局过滤器和局部过滤器重名时，会采用局部过滤器。### 响应式原理- 由于 js 原因无法检测对象 和数组- &gt; Vue 无法检测 property 的添加或移除。- &gt; Vue 不能检测以下数组的变动：&gt;&gt; 1. 当你利用索引直接设置一个数组项时&gt; 2. 当你修改数组的长度时- 这样规则对 watch 一样使用 , 对于对象内部的变化需要使用 deep 选项- &gt; 对象 : watch 无法检测到 对象某个属性的值 /嵌套对象 改变, 使用 deep&gt;&gt; 数组同上</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router</title>
    <link href="/2021/02/21/Vue/vue%20router/"/>
    <url>/2021/02/21/Vue/vue%20router/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><ul><li><p>通过不同参数匹配到的所有路由，全都映射到同个组件</p></li><li><blockquote><p>例如 :  将<code>/user/foo</code> 和 <code>/user/bar</code> 映射到相同的路由。</p></blockquote></li></ul><ul><li><p>通过动态路径参数实现这个效果:</p></li><li><table><thead><tr><th align="left"></th><th><strong>$route.params</strong></th></tr></thead><tbody><tr><td align="left">/user/:username</td><td>{ username: ‘evan’ }</td></tr><tr><td align="left">/user/:username/post/:post_id</td><td>{ username: ‘evan’, post_id: ‘123’ }</td></tr></tbody></table></li><li><blockquote><p><strong>$route.params</strong> 获得动态路径参数</p><p>$route.query    $route.hash  提供其他信息</p></blockquote></li></ul><p>监听路由变化</p><ul><li><p>由于动态路由使用不同参数,访问的都是同一组件，组件会被复用以提升效率；</p></li><li><blockquote><p><strong>这也意味着组件的生命周期钩子不会再被调用</strong>。那怎么监听路由的变化呢？</p><p>可以利用Watch <code>$route</code> 对象来对路由参数的变化进行监测  , 监听$route(to, from)判断去处和来源；</p><p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫 </p></blockquote></li><li><pre><code class="javascript">组件:const User = &#123;  template: &#39;...&#39;,  watch: &#123;    $route(to, from) &#123;      // 对路由变化作出响应... &#125; &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 有时路由不存在会得不到任何结果，可以设置捕获所有路由或 404<br><br>- ```javascript<br>  &#123;<br>    // 会匹配所有路径<br>    path: &#x27;*&#x27;&#125;<br>  &#123;<br>    // 会匹配以 `/user-` 开头的任意路径<br>    path: &#x27;/user-*&#x27;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分</p></li><li><blockquote><p> { path: ‘/user-*’ }<br>this.$router.push(‘/user-admin’)<br>this.$route.params.pathMatch // ‘admin’</p></blockquote></li></ul><ul><li><p>路由路径高级匹配模式</p></li><li><blockquote><p><code>vue-router</code> 使用 <a href="https://github.com/pillarjs/path-to-regexp/tree/v1.7.0">path-to-regexp</a> 作为路径匹配引擎，所以支持很多高级的匹配模式，查看文档获取更高级的匹配形式</p></blockquote></li><li><p>同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序</p></li></ul><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><ul><li><p>实际应用界面中, 通常由多层嵌套的组件组合而成:类似栏目分类,而路由也应该按某种结构对应这种嵌套关系,借助 <code>vue-router</code>，使用嵌套路由配置，就可以很简单地表达这种关系。</p></li><li><pre><code class="js">// 在 children 选项中定义嵌套路由设置new VueRouter(&#123;routes: [    &#123;      name:&#39;user&#39;      path: &#39;/user/:id&#39;, component: User,      children: [        // 当 /user/:id 匹配成功，        //  UserHome组件会被渲染在 User组件中的 &lt;router-view&gt;中        &#123; path: &#39;username&#39;, component: UserHome &#125;,        // ...其他子路由      ]              &#125;)<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- &gt; 如果不在父路由组件中使用 &lt;router-view&gt;, 那么将不会渲染子路由组件<br><br>- &gt; 这里组件名称和路径设置的不一样，路由采用的是路径； <br>  &gt;<br>  &gt; 子路由不需要 / ，因为斜杠会被当成根路径； <br><br>- 可以嵌套多层路由,而且子路由不需要 / 设置更方便, 不要忘记 &lt;router-view&gt;否则不会渲染<br><br><br><br><br><br><span class="hljs-comment">#### 编程式导航</span><br><br>- 使用 `&lt;router-link&gt;` 可以创建 a 标签来定义导航链接,但是缺乏编程性<br><br>- | 声明式                  | 编程式           |<br>  | ----------------------- | ---------------- |<br>  | &lt;router-link :to=<span class="hljs-string">&quot;...&quot;</span>&gt; | router.push(...) |<br><br>- **在 Vue 实例内部，你可以通过 `<span class="hljs-variable">$router</span>` 访问路由实例** (注意和<span class="hljs-variable">$route</span>的区别  route路由对象的属性)<br><br>- **router.push()**函数:<br><br>- &gt; 想要导航到不同的 URL，则使用 `router.push` 方法。这个方法会向 history 栈添加一个新的记录<br><br>- ```js<br>  <span class="hljs-regexp">//</span> 该方法的参数可以是一个字符串路径，或者一个描述地址的对象<br>  router.push(<span class="hljs-string">&#x27;/home&#x27;</span>)  <span class="hljs-regexp">//</span> 注意加上/就代表根目录, <br>  <br>  <span class="hljs-regexp">//</span> 命名的路由<br>  router.push(&#123; name: <span class="hljs-string">&#x27;user&#x27;</span>, params: &#123; userId: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br>  <br>  <span class="hljs-regexp">//</span> 带查询参数，变成 /register?plan=private<br>  router.push(&#123; path: <span class="hljs-string">&#x27;register&#x27;</span>, query: &#123; plan: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br>  <br>  <span class="hljs-regexp">//</span> 如果提供了 path，params 会被忽略,path和query是配套的<br>  <br>  const userId = <span class="hljs-string">&#x27;123&#x27;</span><br>  router.push(&#123; path: `<span class="hljs-regexp">/user/</span><span class="hljs-variable">$&#123;userId&#125;</span><span class="hljs-regexp">/test` &#125;) /</span><span class="hljs-regexp">/ -&gt; /u</span>ser<span class="hljs-regexp">/123/</span>test <br>  <span class="hljs-regexp">//</span>嵌套多层路由时,只能通过path解析路径<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p><strong>router.replace(…)函数:</strong></p></li><li><blockquote><p>跟 <code>router.push</code> 很像，但是它不会向 history 添加新记录， 而是替换掉当前的 history 记录。</p></blockquote></li><li><p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p></li><li><p><strong>router.go(n):函数:</strong></p></li><li><blockquote><p>类似 <code>window.history.go(n)</code>,意思是在 history 记录中向前或者后退多少步</p><p>1 前进一步   -1 后退一步</p></blockquote></li></ul><ul><li>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，你需要使用 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 来响应这个变化 (比如抓取用户信息)</li></ul><h4 id="命名路由和视图"><a href="#命名路由和视图" class="headerlink" title="命名路由和视图"></a>命名路由和视图</h4><ul><li><p>通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候,通过Router实例中的<code>name</code>属性实现</p></li><li><pre><code>routes: [    &#123;      path: &#39;/user/:userId&#39;,      name: &#39;user&#39;,      component: User    &#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- 要链接到一个命名路由，可以给 `router-link` 的 `<span class="hljs-keyword">to</span>` 属性传一个对象：<br><br>- &gt; &lt;router-link :<span class="hljs-keyword">to</span>=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;<span class="hljs-keyword">User</span>&lt;/router-link&gt;<br>  &gt;<br>  &gt; 注意这时候的 <span class="hljs-keyword">to</span>是通过 v-bind绑定的, 我们通过<span class="hljs-type">name</span>值 ,完成跳转<br><br><br><br>- **命名视图** : 有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar` (侧导航) 和 `main` (主内容) 两个视图，这个时候命名视图就派上用场了。<br><br>- &gt; 如何理解同级展示 嵌套展示:  当通过嵌套路由设置router-<span class="hljs-keyword">view</span> 这时会渲染成嵌套的div, 而通过命名视图设置router-<span class="hljs-keyword">view</span> ,则是  同级的div块<br><br>- 通过设置多个带有名字的 `router-<span class="hljs-keyword">view</span>`,没有名字默认为 `<span class="hljs-keyword">default</span>`<br><br>- ```html<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view one&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view two&quot; <span class="hljs-type">name</span>=&quot;a&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view three&quot; <span class="hljs-type">name</span>=&quot;b&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。这时在路由上需要使用<code>components</code>来规定子组件</p></li><li><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;     path: &#39;/&#39;,      components: &#123;        default: Foo,  //还可以是懒加载, () =&gt; import(&#39;../views/About.vue&#39;)也是可以        a: Bar,        b: Baz      &#125;    &#125;  ]&#125;)<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> &gt; 我们也有可能使用命名视图创建嵌套视图的复杂布局, 展示嵌套视图时还存在嵌套路由<br><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">js</span><br>  &#123; <br>      <span class="hljs-attribute">path</span>:<span class="hljs-string">&#x27;/long/:id&#x27;</span>,<br>      <span class="hljs-attribute">name</span>:<span class="hljs-string">&#x27;long&#x27;</span>,<br>      <span class="hljs-attribute">component</span>:long,<br>      <span class="hljs-attribute">children</span>:[&#123;<br>        <span class="hljs-attribute">path</span>:<span class="hljs-string">&quot;test&quot;</span>,<br>        <span class="hljs-attribute">components</span>:&#123;<br>          <span class="hljs-attribute">default</span>:Test,  <br>          <span class="hljs-attribute">sec</span>:button,<br>        &#125;,<br>        <span class="hljs-attribute">children </span>: [<br>          &#123;<br>              <span class="hljs-attribute">path </span>: <span class="hljs-string">&#x27;list&#x27;</span>,<br>              <span class="hljs-attribute">component </span>:List,<br>          &#125;<br>      ]   <br>      <span class="hljs-comment">/* 展示嵌套视图里的嵌套路由 , 默认children 是第一个元素的 */</span><br>   &#125;,<br>   ]&#125;, <br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h4><ul><li><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code></p></li><li><p>使用 redirect，可以配置路由的重定向功能，有多种方式；</p></li><li><pre><code class="js">routes: [    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;   //使用路径    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;   //使用路由名字  ]方法:routes: [    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123; &#125;      // 方法接收 目标路由 (被跳转的路由) 作为参数      // return 重定向的 字符串路径/路径对象    &#125; //每次点击不同的链接跳转时 总会触发redirect函数<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><br>  <span class="hljs-selector-tag">-</span> 注意<span class="hljs-selector-attr">[导航守卫]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//router.vuejs.org/zh/guide/advanced/navigation-guards.html)并没有应用在跳转路由上，而仅仅应用在其目标上。</span><br><br>- 别名 : **<span class="hljs-built_in">`/a`</span> 的别名是 <span class="hljs-built_in">`/b`</span>，意味着，当用户访问 <span class="hljs-built_in">`/b`</span> 时，URL 会保持为 <span class="hljs-built_in">`/b`</span>，但是路由匹配则为 <span class="hljs-built_in">`/a`</span>，就像用户访问 <span class="hljs-built_in">`/a`</span> 一样。**<br><br>- &gt; <span class="hljs-built_in">``</span>`js<br>  &gt;  <span class="hljs-attribute">routes</span>: [<br>  &gt;     &#123; <span class="hljs-attribute">path</span>: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attribute">component</span>: A, <span class="hljs-attribute">alias</span>: <span class="hljs-string">&#x27;/b&#x27;</span> &#125;<br>  &gt;   ]<br>  &gt; “别名”的功能让你可以自由地将 <span class="hljs-selector-tag">UI</span> 结构映射到任意的 <span class="hljs-selector-tag">URL</span>，而不是受限于配置的嵌套路由结构。<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="路由组件间的传参"><a href="#路由组件间的传参" class="headerlink" title="路由组件间的传参"></a>路由组件间的传参</h4><ul><li><p>在组件中使用<code>$route</code>会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p></li><li><p>使用 <code>props</code> 将组件和路由解耦:</p></li><li><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)解耦 :const User = &#123;  props: [&#39;id&#39;],  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    &#123;      path: &#39;/user/:id&#39;,      components: &#123; default: User, sidebar: Sidebar &#125;,      props: &#123; default: true, sidebar: false &#125;    &#125;  ]&#125;)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- 三种模式 : 布尔模式  对象模式 函数模式<br><br>- &gt;布尔模式 :  `props` 被设置为 `true`，`route.params` 将会被设置为组件属性。<br>  &gt;<br>  &gt;这样可以直接使用 route.params 中的对象, 注意这里的 prop 的名字 需要对应route.params 中的数据<br><br>  &gt;有对于静态路由，可以使用对象模式；<br>  &gt;<br>  &gt;```html<br>  &gt;props : &#123; <br>  &gt;name : &#x27;列表&#x27; <br>  &gt;&#125;,<br>  &gt;&lt;template&gt; <br>  &gt;&lt;h3&gt;这里是 List 页面 : &#123;&#123;name&#125;&#125;&lt;/h3&gt; <br>  &gt;&lt;/template&gt;<br>  &gt;<br>  &gt;对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：<br>  &gt;props : &#123; default : &#123; name : &#x27;列表&#x27; &#125; &#125;,<br>  &gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>函数模式  创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">routes: [<br>   &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-attr">component</span>: SearchUser, <span class="hljs-attr">props</span>: <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> (&#123; <span class="hljs-attr">query</span>: route.query.q &#125;) &#125;<br> ]<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h4><ul><li><p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p></li><li><p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p></li><li><blockquote><pre><code class="js">const router = new VueRouter(&#123;  mode: &#39;history&#39;,  routes: [...]&#125;)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 需要后台配置   <br><br><span class="hljs-bullet">-</span> &gt; 待拓展<br><br><br><br><br><br><span class="hljs-section">#### 导航守卫</span><br><br><span class="hljs-bullet">-</span> 什么是导航 : 表示路由正在发生改变。导航守卫主要作用: 是通过跳转/取消的方式 守卫导航 ,路由跳转时会触发一些钩子函数,这些钩子函数被称为导航守卫<br><br><span class="hljs-bullet">-</span> &gt; 记住<span class="hljs-strong">**参数或查询的改变并不会触发进入/离开的导航守卫**</span>。你可以通过[<span class="hljs-string">观察 `$route` 对象</span>](<span class="hljs-link">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化</span>)来应对这些变化，或使用 <span class="hljs-code">`beforeRouteUpdate`</span> 的组件内守卫。<br><br><span class="hljs-bullet">-</span> 导航守卫有多种: 全局  组件  路由独享<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局前置守卫**</span> :<br><br><span class="hljs-bullet">-</span> 使用 <span class="hljs-code">`router.beforeEach((to,from,next)=&gt;&#123;&#125;)`</span> 注册一个全局前置守卫<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-strong">**`to: Route`**</span>: 即将要进入的目标 [<span class="hljs-string">路由对象</span>](<span class="hljs-link">https://router.vuejs.org/zh/api/#路由对象</span>)<br><br><span class="hljs-strong">**`from: Route`**</span>: 当前导航正要离开的路由<br><br><span class="hljs-strong">**`next: Function`**</span>: 一定要调用该方法来 <span class="hljs-strong">**resolve**</span> 这个钩子。执行效果依赖 <span class="hljs-code">`next`</span> 方法的调用参数。<br><br> 不执行 next 函数,无法继续运行<br><br><span class="hljs-bullet">-</span> next()   next(false)   next(&#x27;/&#x27;)  <span class="hljs-code">`next(error)`</span> 四类不同的调用方式<br><br><span class="hljs-bullet">-</span> 确保 <span class="hljs-code">`next`</span> 函数在任何给定的导航守卫中都被严格调用一次。他可以出现多次但只能调用一次, <br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">` RangeError: Maximum call stack size exceeded`</span> <br><br>注意无限递归问题 ,因为不加判断条件往往导致无限递归 <br><br> <br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局解析守卫**</span> :  <span class="hljs-code">`router.beforeResolve`</span> 注册一个全局守卫。<br><br><span class="hljs-bullet">-</span> &gt; 和<span class="hljs-code">`router.beforeEach`</span> 类似, 区别在于 调用顺序的不同   待拓展...<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局后置钩子**</span> : <span class="hljs-code">`router.afterEach((to, from) =&gt; &#123;&#125;`</span> , 这些钩子和守卫不同, 不会接受 <span class="hljs-code">`next`</span>函数自然不会改变导航本身, ，一般用于路由页面加载完毕之后操作一些动作，比如取消 loading<br><br><br><br><span class="hljs-strong">**路由独享的守卫**</span>:<br><br><span class="hljs-bullet">-</span> 在路由配置上直接定义 <span class="hljs-code">`beforeEnter`</span> 守卫：<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```js</span><br><span class="hljs-code"> const router = new VueRouter(&#123;</span><br><span class="hljs-code">   routes: [</span><br><span class="hljs-code">     &#123;</span><br><span class="hljs-code">       path: &#x27;/foo&#x27;,</span><br><span class="hljs-code">       component: Foo,</span><br><span class="hljs-code">       beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="hljs-code">         // ...</span><br><span class="hljs-code">       &#125;&#125;]&#125;)</span><br><span class="hljs-code"> // 这些守卫与全局前置守卫的方法参数是一样的。</span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><blockquote><p>路由中配置的守卫, 当从该路由跳转  或者进入该路由调用守卫</p></blockquote></li></ul><p><strong>组件内的守卫:</strong></p><ul><li><pre><code class="js">const Foo = &#123;  template: `...`,  beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- beforeRouteEnter 守卫不能 访问 `this`, 不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫<br><br>- ```<br>  beforeRouteEnter (to, from, next) &#123;<br>    next(vm =&gt; &#123;<br>      // 通过 `vm` 访问组件实例<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>导航守卫钩子函数的执行顺序  : <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">#</a>完整的导航解析流程 </p></li></ul><h4 id="路由元信息-过渡效果"><a href="#路由元信息-过渡效果" class="headerlink" title="路由元信息  过渡效果"></a>路由元信息  过渡效果</h4><ul><li><p>定义路由的时候可以配置 <code>meta</code> 字段, 一般设置为对象</p></li><li><p>过渡效果:</p></li><li><pre><code class="html">&lt;transition name=&quot;fade&quot;&gt;&lt;router-view/&gt;&lt;/transition&gt;//Transition 的所有功能 在这里同样适用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>- 单个路由的过渡: 在路由组件上使用<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br><br>- ```<br>  const Foo = &#123;<br>    template: `<br>      <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slide&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>    `<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>基于当前路由与目标路由的变化关系,动态设置过渡</p></li><li><pre><code class="html">&lt;transition :name=&quot;transitionName&quot;&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;接着在父组件内// watch $route 决定使用哪种过渡watch: &#123;  &#39;$route&#39; (to, from) &#123;   const toDepth = to.path.split(&#39;/&#39;).length...&#125;</code></pre></li></ul>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>#### 数据获取<br><br>- 有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：<br><br>- &gt; 1. **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。<br>  &gt; 2. **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。<br><br><br><br>#### 滚动行为  路由懒加载<br><br>滚动行为:<br><br>- 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样<br><br>- &gt; **注意: 这个功能只在支持 `history.pushState` 的浏览器中可用。**<br><br>- ```js<br>  const router = new VueRouter(&#123;<br>    routes: [...],<br>    scrollBehavior (to, from, savedPosition) &#123;<br>    if (savedPosition) &#123;<br>      return savedPosition  //保存之前的位置  通过浏览器的 前进/后退 按钮触发<br>    &#125; else &#123;<br>      return &#123; x: 0, y: 0 &#125;<br>    &#125;<br>      // return 期望滚动到哪个的位置<br>    &#125;<br>  &#125;)<br>  //  <br></code></pre></td></tr></table></figure><ul><li><p>路由懒加载 : 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p></li><li><pre><code class="js">&#123; path: &#39;/about&#39;, name: &#39;About&#39;, component: () =&gt; import(&#39;../views/About.vue&#39;) &#125;</code></pre></li></ul><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件循环</title>
    <link href="/2021/02/21/Node%20+%20JS/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2021/02/21/Node%20+%20JS/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul><li><p>JavaScript 有一个基于<strong>事件循环</strong>的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p></li><li><p>并发模型的解释:</p><blockquote><p>栈:  调用函数时创建元素压入栈,元素中包含参数和局部变量, 解析函数内容,如果函数内又调用了函数,那就再次压入栈,执行完之后弹出栈</p><p>堆: 当 JS 引擎解析JS代码的过程中遇到一些变量或者函数申明的时候，它会将它们存储到里面。</p><p>消息队列(回调函数队列): 存储待处理信息,每个信息是经过Web API 处理结束后的回调函数</p></blockquote></li><li><p>大致过程:</p><blockquote><p>首先同步函数依次进入栈中进行调用,如果遇见异步函数就发送给web API 调用相应的模块进行处理(例如: 计时器有timer模块进行执行), 执行完成之后,发送给消息队列进行等待</p></blockquote></li><li><p>事件循环:</p><blockquote><p>事件循环是一种机制，他不断的检查栈是否执行空, 如果栈执行空了把消息队列的第一个放入栈中处理,<strong>函数的处理会一直进行到执行栈再次为空为止</strong>,然后处理队列中的下一个消息</p></blockquote></li><li><p>以上模型解释了两个问题:</p><ul><li><p>异步函数的执行顺序:   异步函数就算在同步函数内部, 执行也会在所有同步函数执行结束之后,才会执行</p></li><li><p>计时器函数为什么不准确: 计时器时间值代表了消息被实际加入到队列的最小延迟时间。但是实际中执行该计时器需要等到同步函数结束,所以就算时间为0,也不代表立即执行</p></li></ul></li><li><p>其他</p><blockquote><p>一个 web worker 或者一个跨域的 <code>iframe</code> 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage"><code>postMessage</code></a> 方法进行通信。</p><p>由于历史原因有一些例外，如 <code>alert</code> 或者同步 XHR，但应该尽量避免使用它们,它会导致堵塞</p></blockquote></li></ul><h3 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h3><ul><li><p>当每一个消息被<strong>完整</strong>的处理完之后,才会执行其他的消息,</p><blockquote><p>其他多线程语言不同,资源不会被抢占,  对于多线程语言,可能函数执行时会被终止,来执行其他的任务, </p><p>JS的单线程处理方式导致它 永不堵塞</p><p>但是一个消息长时间才能处理完毕,我们必须等待而无法进行网页交互</p></blockquote></li></ul><ul><li>多线程学习重点是要大量面对资源争抢与同步方面的问题 ，JS是单线程的可以避免此类问题</li><li></li></ul><h3 id="宏任务-微任务队列"><a href="#宏任务-微任务队列" class="headerlink" title="宏任务/微任务队列"></a>宏任务/微任务队列</h3><ul><li><p>Es6 之后因为Promise 的原因,引入宏任务/微任务队列的概念</p></li><li><p>微任务: 微任务仅来自于我们的代码,它们通常是由 promise 创建的</p><blockquote><p>对  .then/catch/finally 处理程序的执行会成为微任务。await `的“幕后”</p><p>使用queueMicrotask(f) 可以安排一个微任务</p></blockquote></li><li><p>宏任务: 就是平时我们说的消息队列</p><blockquote><p>细节: 页面<code>渲染</code>也算是宏任务队列的一个消息,所以引擎执行时永远不会进行渲染,只有当栈为空,才会进行渲染</p><p>所以在函数中对一个元素持续改变,然后渲染它,改变过程是看不到的,因为只有函数结束后,才会执行渲染任务</p></blockquote></li><li><p><strong><code>每个</code>宏任务之后，引擎会立即执行微任务队列中的<code>所有</code>任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</strong></p></li><li><p>微任务会一个接一个执行,中间没有其他任务</p></li><li><p>利用JS事件循环的模型, 宏任务/微任务的概念, 使用异步操作常见的三种操作</p><blockquote><p>拆分大任务, 不让CPU过载 </p><p>持续渲染页面 (进度指示)</p><p>在浏览器事件结束之后,再进行操作, </p></blockquote></li></ul><ul><li><p>Promise</p></li><li><p>promise 本质是同步函数返回的对象, 返回的对象再次调用回调函数,这是我们常见的形式</p></li><li></li><li><blockquote><p>new Promise() 同步函数,返回promise对象,而.then/catch/finally则是异步函数</p></blockquote></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础下</title>
    <link href="/2021/02/21/Node%20+%20JS/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8B/"/>
    <url>/2021/02/21/Node%20+%20JS/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h4><h5 id="Rest参数-Spread语法"><a href="#Rest参数-Spread语法" class="headerlink" title="Rest参数  Spread语法"></a>Rest参数  Spread语法</h5><ul><li><p>Rest 参数<code>...</code> : 在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数。不会因为传入“过多”的参数而报错,只会取得前几个参数匹配  </p><ul><li><blockquote><p> 在 JavaScript 中，很多内建函数都支持传入任意数量的参数          </p></blockquote></li></ul></li><li><p><strong>Rest 参数语法</strong>:</p></li><li><p><code>function showName(firstName, lastName, ...titles)</code> </p><blockquote><p>   Rest  参数必须放到参数列表的末尾, 收集参数放到titles<code>数组</code>中</p></blockquote></li></ul><ul><li><p><strong>arguments 变量</strong>:</p></li><li><p>有一个名为 arguments 的特殊的<strong>类数组对象</strong>，该对象包含所有参数,使用索引访问参数,我们可以在一些老代码里找到它。</p><blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>alert( <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] );<br><span class="hljs-comment">// 它是可遍历的</span><br>  <span class="hljs-comment">// for(let arg of arguments) alert(arg);</span><br>  &#125;<br>  <br>  showName(<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>rest  arguments 两者区别:</p><blockquote><p>arguments 是一个类数组，也是可迭代对象，但它终究不是数组,不支持数组方法</p><p>它始终包含所有参数，我们不能像使用 rest 参数那样可以还可以给与别的参数值</p></blockquote></li><li><p>箭头函数是没有 “arguments”, 如果我们在箭头函数中访问 <code>arguments</code>，访问到的 <code>arguments</code> 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。</p></li></ul><ul><li><p><strong>Spread</strong> 语法 :</p></li><li><blockquote><p>把可迭代对象 spread 开, 分给每个函数参数, 和Rest参数相反</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>];<br>alert( <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,...arr) ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>Rest Spread 语法区别:</p><blockquote><p>Spread 在函数调用时使用<code>...</code>    Rest 是在函数声明时使用<code>... </code>  </p><p>Spread 语法 把数组转换成参数列表,  Rest 把参数列表转换为数组</p></blockquote></li></ul><ul><li><p>对于可迭代对象都可以展开, 甚至可以用它来合并数组, 转化数组,复制数组</p><blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &gt;<span class="hljs-keyword">let</span> merged = [<span class="hljs-number">0</span>, ...arr, <span class="hljs-number">2</span>, ...arr2];  <span class="hljs-comment">//返回一个数组</span><br>alert( [...str] ); <span class="hljs-comment">// [..str] 把字符串转化为数组    </span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-keyword">let</span> arrCopy = [...arr] <span class="hljs-comment">//复制一个数组, arr是对象也成立</span><br></code></pre></td></tr></table></figure></blockquote></li><li><blockquote><p><code> Array.from(obj)</code>  和 <code>Spread</code> 区别:</p><p>区别在于<code>Array.from</code> <strong>适用于类数组对象也适用于可迭代对象</strong>, </p><p>Spread 语法<strong>只适用于可迭代对象</strong>。</p></blockquote></li></ul><ul><li><p><strong>简单区分 Rest  Spread:</strong></p></li><li><p>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。</p></li><li><p>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。</p></li></ul><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><ul><li><p>词法环境 : </p><ol><li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li><li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联</li></ol></li><li><p>一个“变量”只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p><blockquote><p>“词法环境”是一个规范对象（specification object）：它仅仅是存在于 <a href="https://tc39.es/ecma262/#sec-lexical-environments">编程语言规范</a> 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。</p></blockquote></li><li><p><code>闭包</code>是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。</p></li><li><blockquote><p>在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <a href="https://zh.javascript.info/new-function">“new Function” 语法</a> 中讲到） </p><p>原因 : 所有的函数在“诞生”时都会记住创建它们的词法环境。所有函数都有名为 <code>[[Environment]]</code> 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。</p></blockquote></li><li><p>垃圾收集 : 通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p></li><li><p>理论上当函数可达时，它外部的所有变量也都将存在。实际上，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。</p><blockquote><p>在 V8（Chrome，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。</p></blockquote></li></ul><h5 id="let-和-var-区别"><a href="#let-和-var-区别" class="headerlink" title="let 和 var 区别:"></a>let 和 var 区别:</h5><ul><li><p>变量提升和函数提升</p></li><li><blockquote><p>函数表达式不存在提升 , let有提升但是有暂时锁区</p></blockquote></li></ul><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">案例一: <br><span class="hljs-keyword">let</span> x=<span class="hljs-string">&quot;fef&quot;</span>;<br> &#123;<br>   <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//x 显示错误</span><br>   <span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;eew&quot;</span>;<br>   <span class="hljs-comment">//在代码块中, x创建时变量提升, 所以log() 使用的是代码块中的x值.但是初始化并没有被提升, 所以初始化之前不能使用的x 报错</span><br> &#125;<br>案例二:<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br> element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(i)  <span class="hljs-comment">// 结果都会是 5 ,因为var不存在块作用域,循环中的i值 一直只有一个, 所以结果都是I的最终值</span><br> &#125;<br> &#125;<br> <br></code></pre></td></tr></table></figure></blockquote><ul><li><p><code>var</code> 没有块级作用域,不是函数作用域就是全局作用域</p><blockquote><p>例如if块中定义的变量,或者是for循环中定义的变量,在外面还是能访问到</p></blockquote></li><li><p><code>var</code>我们可以重复声明一个变量，不管多少次都行,</p><blockquote><p>新的声明语句被忽略,但是仍然被赋值</p></blockquote></li><li><p><code>var</code> 声明的变量可以在其声明语句前被使用,变量提升</p></li><li><p>IIFE 函数书写   存在意义: 创建一个块级作用域进行使用,不会污染全局变量</p></li><li><blockquote><p>jq 中开发插件也使用了IIFE ,为了继续使用$ 和 创建一个作用域</p></blockquote></li></ul><h5 id="全局对象-不是全局变量搞清楚"><a href="#全局对象-不是全局变量搞清楚" class="headerlink" title="全局对象(不是全局变量搞清楚)"></a>全局对象(不是全局变量搞清楚)</h5><ul><li><p>全局对象提供可在任何地方使用的变量和函数,默认情况下，这些全局变量内置于语言或环境中,全局对象的所有属性都可以被直接访问</p></li><li><blockquote><p>在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”</p></blockquote></li><li><p>在浏览器中，使用 var（而不是 let/const！）声明的全局函数和变量会成为全局对象的<strong>属性</strong>。使用 let，就不会发生这种情况.</p></li></ul><ul><li><p>如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：</p><blockquote><p>window.currentUser = {<br>name: “John”<br>};</p></blockquote></li><li><p>我们使用全局对象来测试对现代语言功能的支持。</p><blockquote><p> <code>if (!window.Promise)&#123;...&#125; </code>  测试是否存在promise对象</p></blockquote></li></ul><h5 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h5><ul><li><p>在 JavaScript 中，函数的值类型是一个对象, 我们可以把它当成一个对象使用, </p><blockquote><p>函数名字通过属性name 访问获得  length返回函数需要参数的个数(rest 参数不参与计数)。</p><p>我们也可以在函数内添加自定义属性,在函数外可以调用,改变它. 通过函数名.属性名添加, 创建只属于函数的属性</p></blockquote></li></ul><ul><li>命名函数表达式 (NFE): 指带有函数名字的函数表达式 </li><li><blockquote><p><code>let sayHi = function func(who)</code> ,</p><p>通过func可以在函数内调用自己 而且在函数外不可见</p></blockquote></li><li><blockquote><p>为什么不使用嵌套调用的原因:为了避免在函数内嵌套调用时, 函数表达式在外部已被修改(引用其他函数..)</p><p>比如: let sayhi =null 那么使用sayhi的嵌套调用就无效了</p></blockquote></li></ul><h5 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h5><ul><li><p><code>new Function</code> 允许我们将任意字符串变为函数</p></li><li><p>创建函数体, 参数内接受函数参数 和函数体 ,应用在从服务器获取代码 ..复杂场景才会使用 , 创建的函数只能访问全局变量</p></li></ul><h5 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h5><ul><li><p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”</p></li><li><p>两种方法事件 : setTimeout 和 setInterval</p></li><li><pre><code class="javascript">let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)// 实例 : setTimeout(sayHi, 1000, &quot;Hello&quot;, &quot;John&quot;);                       <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <br>- &gt; func|code : 想要执行的函数或代码字符串。 一般传入的都是函数。<br>  &gt; 由于某些历史原因，支持传入代码字符串，但是不建议这样做。(JavaScript 会自动为字符代码块其创建一个函数) <br>  &gt; arg1 ..要传入被执行函数（或代码字符串）的参数列表,一般都使用函数了<br><br>- <span class="hljs-built_in">setInterval</span> 方法 <span class="hljs-built_in">setTimeout</span> 的语法相同<br><br>  <br><br>- 使用<span class="hljs-built_in">clearTimeout</span>() , <span class="hljs-built_in">clearInterval</span>()  取消调度,在浏览器中，定时器标识符是一个数字。在其他环境中，可能是其他的东西。<br><br>- 在大多数浏览器中，包括 Chrome 和 Firefox，在显示 <span class="hljs-string">`alert/confirm/prompt`</span> 弹窗时，内部的定时器仍旧会继续“嘀嗒”。<br><br><br><br>- <span class="hljs-string">`周期性调度`</span>有两种方式 ： 一种是使用 <span class="hljs-built_in">setInterval</span>，另外一种就是嵌套的 <span class="hljs-built_in">setTimeout</span> <br><br>- &gt; 嵌套的 <span class="hljs-string">`setTimeout`</span> 要比 <span class="hljs-string">`setInterval`</span> 灵活得多,采用这种方式可以根据当前执行结果来调整下次调用的时间间隔<br><br>- &gt; 使用 <span class="hljs-built_in">setInterval</span> 时，func 函数的实际调用间隔要比代码中设定的时间间隔要短！ 因为其中设置的间隔时间包括函数执行的时间, 所以实际间隔要小<br>  &gt;<br>  &gt; 嵌套的 <span class="hljs-built_in">setTimeout</span> 就能确保延时的固定（这里是 <span class="hljs-number">100</span> 毫秒）。这是因为下一次调用是在前一次调用完成时再调度的。  嵌套调用时 函数名字不能再是 匿名函数..<br>&gt;<br></code></pre></td></tr></table></figure>&gt; let timerId = setTimeout(function tick()&gt; &#123;  alert(&#39;tick&#39;);  *timerId = setTimeout(tick, 2000);&#125;, 2000);&gt; <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 垃圾回收 和 计时函数 : 对于 setInterval，传入的函数也是一直存在于内存中，直到 clearInterval 被调用。 如果函数还引用了一些外部变量,那么函数存在,变量也会随之存在(闭包), 会占用内存<br><br>在浏览器环境下，嵌套定时器的运行频率是受限制的。必须经过 4 毫秒以上的强制延时<br><br>##### 装饰者模式和转发，call/apply<br>- 装饰者模式 : 一个特殊的函数 :  它接受另一个函数并改变它的行为(参数是一个函数)。返回一个新函数<br><br> <br><br><br>- **call/apply:**<br><br><br>- ```javascript<br> func.call(context, arg1, arg2, ...)<br> // 提供的第一个参数作为 this<br> func.apply(context, args)   <br> // 第一个参数作为this , args: 参数数组/类数组对象<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>两者区别: </p><p><code>call()</code> 方法接受的是一个参数列表，而<code>apply()</code>方法接受的是一个包含多个参数的数组。</p><p><code>apply</code> 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。</p><p>这两个函数 和 bind函数的区别:</p><p>前者更像是调用函数自身,只是给与了this 指针, 后者bind 则是返回了一个新函数</p></blockquote></li></ul><ul><li><p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。</p></li><li><p>方法借用 : </p><blockquote><p><code>[].join.call(arguments)</code>  借用原始方法,给与上下文,它为什么有效？</p><p>因为原生方法内部,需要<code>this</code> 来操作</p></blockquote></li><li><p>通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，装饰后的函数将不再提供这些属性.</p></li></ul><h5 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h5><ul><li><p>丢失”this” : 一旦方法被传递到与对象分开的某个地方 —— <code>this</code> 就丢失。例如对象方法作为回调函数进行传递</p></li><li><blockquote><p>当对象方法不是直接调用,就会丢失this</p><p>例如:  setTimeout(user.func,1000); 直接调用user,func() 就不会发生丢失; </p><p>本质上第一种的调用方法是和对象分开的,当传递对象方法时,会直接传递该函数地址, 不会连同对象一起传输,this又是运行时才被计算出来,所以就会丢失</p><p>第一种写法相当于    let f  = user.func;  setTimeout(f,1000);</p></blockquote></li></ul><ul><li><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法 :"></a>解决方法 :</h5></li><li><p>包装器 ,使用匿名函数/箭头函数, 在内部写调用对象方法</p></li><li><blockquote><p>传递时传递包装器,调用时对象方法会直接调用,就不会丢失</p></blockquote></li><li><blockquote><p>包装器的缺点:</p><p>当对象方法在<strong>包装器之前</strong>更新,包装器中的对象方法就会更新, </p><p> 常见情况: 如果传递的包装器是作为异步函数的参数,那么只要主线程中更改对象方法, 包装器中的方法就会受到影响和 顺序不一致</p></blockquote></li></ul><ul><li><p>如果利用bind进行绑定, 只要<strong>在bind之后</strong>再更改对象方法,那么都不会影响之前的对象方法, 这样就算是异步函数, 和书写顺序也保持一致</p><blockquote><p>let funcUser = func.bind(user);  </p><p>func.bind(user),  </p><p>返回一个类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用   funcUser() ,参数列表和func一样,一样传递参数调用,只是this被绑定了</p></blockquote></li></ul><ul><li><p>bindAll : 对象有很多方法都需要绑定, 可以在一个循环中完成所有方法绑定</p></li><li><pre><code>for (let key in user) &#123;if (typeof user[key] == &#39;function&#39;) &#123;user[key] = user[key].bind(user);&#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>  <br><br>- 偏函数 :  bind 不仅可以绑定this ,还可以绑定参数<br><br>- &gt; ```javascript<br>  &gt; let bound = func.bind(context, [arg1], [arg2], ...);<br>  &gt; 当this 不需要绑定时 传递 null给conttext<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>通过绑定一个函数的一些参数来创建一个新函数</p><p>当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用</p></blockquote></li></ul><ul><li><p>如果不想要绑定 this 参数, 我们可以自己实现 ‘偏函数’</p></li><li><blockquote><pre><code>function partial(func, ...argsBound) &#123;return function(...args) &#123; // (*)return func.call(this, ...argsBound, ...args);&#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br> <br><br>#### 对象属性配置<br><br>##### 属性标志和属性描述符<br><br>- 对象可以存储属性。 除了简单的“键值”对。对象属性实际上是更灵活且更强大的东西。<br><br><br>- 对象属性（properties），除 value 外还有特殊的特性 <br><br>- &gt; 属性标志 : <br><br>writable  修改权限   如果为 `true`，则值可以被修改<br><br> enumerable 循环是否列出  如果为 `true`，则会被在循环中列出<br><br> configurable   如果为 `true`,此特性可以被删除，以上这些属性也可以被修改  否则不行<br><br>- &gt; 它们通常不会出现。当我们用“常用的方式”创建一个属性时，它们都为 true。但我们也可以随时更改它们。<br><br> ##### 设置/访问标志<br><br> - `Object.getOwnPropertyDescriptor(obj, &quot;propertyName&quot;); ` 返回值是一个所谓的“属性描述符”对象：它包含值和所有的标志<br> - `Object.defineProperty(obj, propertyName, descriptor)`, 返回对象  , descriptor : 要应用的属性描述符对象。<br><br> - &gt; 如果对象存在该属性, 那么标志的默认值为true, <br><br>如果对象没有该属性, 而是直接使用defineProperty() 定义,那么标志默认都为 false<br><br><br>- **&quot;configurable: false&quot; 的用途是防止更改和删除属性标志，但是允许更改对象的值。**<br><br><br><br><br>- `Object.defineProperties(obj, descriptors)`，允许一次定义多个属性<br><br><br>- `Object.getOwnPropertyDescriptors(obj)`方法。一次获取所有属性描述符，(返回对象)<br><br>- 组合使用拷贝对象:<br><br>`let clone = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(obj));<br><br>和普通拷贝对象的区别: <br><br>for..in 会忽略 symbol 类型的属性，但是 Object.getOwnPropertyDescriptors 返回包含 symbol 类型的属性在内的所有属性描述符。  使用defineProperties可以拷贝不可枚举的属性<br><br> <br><br>- 还有一些限制访问 **整个** 对象的方法<br><br>##### 属性的 getter 和 setter<br>- 有两种类型的对象属性 : 1. 数据属性 2.  访问器属性<br> <br>- &gt; 访问器属性 : 本质上是用于获取和设置值的函数<br> <br>- 语法:<br> <br>在对象内定义get/set  funcname() 函数<br><br>使用Object.defineProperty() 函数在其中定义get/set函数<br><br>```javascript<br>Object.defineProperty(user, &#x27;fullName&#x27;, &#123;<br>get() &#123;<br>return `$&#123;this.name&#125; $&#123;this.surname&#125;`;<br>&#125;,<br>set(value) &#123;<br>[this.name, this.surname] = value.split(&quot; &quot;);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><ul><li><p>访问器属性的设计思想 : 我们不以函数的方式调用 user.fullName，我们正常读取它,相当于我们有了一个虚拟的属性</p></li><li><p>访问器属性名字 不能和对象数据属性名字一样,否则会被覆盖</p></li><li><p>一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</p></li></ul><ul><li><p>访问器属性的描述符与数据属性的不同,   </p><blockquote><p>对于访问器属性,没有value 和 writable，</p><p><strong>enumerable  configurable</strong> 与数据属性的相同 </p></blockquote></li></ul><ul><li><p>Getter/setter用途 : </p></li><li><ol><li>可以用作“真实”属性值的包装器，以便对它们进行更多的控制。例如限制属性值的长度 </li></ol></li><li><ol start="2"><li><p>它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性</p><blockquote><p>一些老的属性,我们不想删除他们, 我们可以改变操作</p><p>通过设置getter和 “旧的”数据属性相同的名字 , 来替换旧的属性</p></blockquote></li></ol></li></ul><h4 id="原型-继承"><a href="#原型-继承" class="headerlink" title="原型,继承"></a>原型,继承</h4><h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><ul><li><p>原型继承解决,在原来的对象基础上<strong>扩展构建</strong>新的对象</p></li><li><blockquote><p>因为构造函数只能是重复创建类似功能的对象,无法通过其进行扩展</p></blockquote></li><li><p>在 JavaScript 中，对象有一个特殊的隐藏属性 <code>[[Prototype]]</code>，它要么为 <code>null</code>，要么就是对另一个对象的引用。被引用的对象被称为“原型”</p></li><li><p>属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的,设置它的方式 :</p></li><li><blockquote><p>使用特殊的名字 <code>__proto__</code> .   可以获取和设置 ,每边是两个下划线</p><p><code>__proto__</code> 的存在是历史的原因。在现代编程语言中，将其替换为函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 也能 get/set 获得原型</p></blockquote></li></ul><ul><li><p>原型链中引用不能形成闭环, <code>__proto__</code> 的值可以是对象，也可以是 null,其他类型被忽略, 只能有一个 <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承。( 单继承)</p></li><li><p><strong>原型仅用于读取属性</strong>。对于写入/删除操作可以直接在对象上进行</p><blockquote><p>例如原型上有name 属性 ,在子类中是无法修改的, 尝试修改会在该对象上生成name属性</p><p>特殊的像访问器属性,可以调用原型的,如果调用set()结果还是会在自身创建属性</p></blockquote></li></ul><ul><li><p><code>Object.keys </code>只返回自己的 key,   <code>for..in</code> 循环会迭代继承的属性。</p><blockquote><p>如果排除继承的属性  <code>obj.hasOwnProperty(key)</code>   返回true/false</p><p><code> enumerable:false</code> 标志导致不可枚举,  for ..in..就不会列举了</p></blockquote></li><li><p>几乎所有其他键/值获取方法，例如 <code>Object.keys</code> 和 <code>Object.values</code> 等，都会忽略继承的属性。 它们只会对对象自身进行操作。<strong>不考虑</strong> 继承自原型的属性。</p></li></ul><h5 id="Func-prototype"><a href="#Func-prototype" class="headerlink" title="Func.prototype"></a>Func.prototype</h5><ul><li><p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p></li><li><p>JavaScript 从一开始就有了原型继承,但是在过去，没有直接对其进行访问的方式。唯一可靠的方法是构造函数的 <code>&quot;prototype&quot;</code> 属性。目前仍有许多脚本仍在使用它。</p></li><li><blockquote><p> <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 <code>&quot;prototype&quot;</code> 的常规属性听起来与“原型”这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。</p></blockquote></li><li><p>如果在创建之后，F.prototype 属性赋了其他值, 那么通过 new F 创建的新对象也将改变 [[Prototype]]，但已经存在的对象将保持旧有的值。</p></li></ul><ul><li><p>每个函数都有 “prototype” 属性，即使我们没有提供它。 默认的 “prototype” 是一个<strong>只有属性 constructor 的对象</strong>，属性 constructor 指向函数自身。</p></li><li><pre><code class="javascript">function Rabbit() &#123;&#125;/* default prototypeRabbit.prototype = &#123; constructor: Rabbit &#125;;*/<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  <br>- 如果我们什么都不做 , constructor 属性可以通过 <span class="hljs-literal">[[P<span class="hljs-identifier">rototype</span>]</span>] 给所有 rabbits 使用(继承),我们还可以利用此属性, 创建新对象<br><br>  &gt; <span class="hljs-keyword">new</span> rabbit.constructor(<span class="hljs-string">&quot;Black Rabbit&quot;</span>);    <span class="hljs-comment">// 两者相等</span><br>  &gt;<br>  &gt; <span class="hljs-keyword">new</span> <span class="hljs-constructor">Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>)</span>;<br>  &gt;<br>  &gt; 当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。<br><br><br><br>- JavaScript 自身并不能确保正确的 <span class="hljs-string">&quot;constructor&quot;</span> 函数值。 它存在于函数的默认 `<span class="hljs-string">&quot;prototype&quot;</span>` 中, 如果我们把默认的prototype 完全替换掉,就不存在constructor<br><br>  &gt; 为了确保正确的 <span class="hljs-string">&quot;constructor&quot;</span>，我们可以选择添加/删除属性到默认 <span class="hljs-string">&quot;prototype&quot;</span>，而不是将其整个覆盖. <br>  &gt;<br>  &gt; 也可以手动重新创建 `constructor` 属性<br>  &gt;<br>  &gt; <span class="hljs-keyword">function</span> <span class="hljs-constructor">Rabbit()</span> &#123;&#125;<br>  &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Rabbit</span>.</span></span>prototype.jumps = <span class="hljs-literal">true</span><br><br>- <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype =的值要么是一个对象，要么就是 null：其他值都不起作用。<br><br><br><br>-  注意一点:  更改prototype中的属性,和对prototype赋值的区别<br><br>  <br><br></code></pre></td></tr></table></figure>&gt;Rabbit.prototype.jumps = true  这种是改变prototype属性指向对象中的属性&gt; Rabbit.prototype = &#123;&#125; 或者对象名, 这是改变构造函数创建对象后[[prototype]]指向的对象&gt; &gt; 两者要分清楚区别, 一个是改变[[prototype]]  指向,一个仅仅改变其中的属性&gt; &gt; &gt; &gt; 还要清楚一点: Rabbit.prototype = animal;   是指向animal对象&gt; Rabbit.prototype = Animal .prototype; 是指向  animal构造函数的prototype&gt; (类似于原生的原型 ,内建对象都是指向自己构造函数的prototype, 而大部分的构造函数 prototype都指向Object()的prototype)&gt;  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs http"> <br><br>- 有一点需要注意,对象不存在prototype属性,只有构造函数 类 存在prototype属性,  对象只有[[prototype]];<br><br>##### 原生的原型<br><br>-  `&quot;prototype&quot;` 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内置构造函数都用到了它。<br><br>- 如何使用它为内建对象添加新功能???<br><br>通过构造函数new对象时, 对象的[[prototype]]默认指向构造函数的Prototype<br><br>String.prototype.show = function() &#123;  alert(this); &#125;;  <br><br>//这样 所有的字符串就可以使用该方法<br><br>-  **原生原型修改:**,通常是一个很不好的想法。原型是全局的,如果两个库都添加了相同的方法, 所以很容易造成冲突。<br><br>**在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。**<br><br>- **原型借用:**  通过*Array.prototype.join;* 获得该方法 赋值给创建的对象,  另一种方式是通过将 obj.__proto__设置为Array.prototyp，这样 Array 中的所有方法都自动地可以在 obj中使用了。<br><br></code></pre></td></tr></table></figure>&gt; 1. obj.join = Array.prototype.join;   &gt; 2. obj.__proto__  = Array.prototype ;&gt; <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs http"><br><br><br>-  内建对象，像 Array、Date、Function 及其他，都在 prototype 上挂载了方法, 数据类型对象 也有相应的prototype,但是null undefined没有对象包装器所以不存在 prototype<br><br>- 按照规范，所有的内建原型顶端都是 `Object.prototype`。这就是为什么有人说“一切都从对象继承而来”。<br> <br> &gt;即使是函数 —— 它们是内建构造器Function的对象<br><br> &gt;并且它们的方法(call/apply 及其他)都取自Function.prototyp函数也有自己的 toString方法。<br><br><br><br>- 所有的内建对象都遵循相同的模式（pattern）：<br><br>方法都存储在 prototype 中（`Array.prototype`、`Object.prototype`、`Date.prototype` 等）。<br><br>对象本身只存储数据（数组元素、对象属性、日期）。<br><br>##### 原型方法<br>- `__proto__` 被认为是过时且不推荐使用的，这里的不推荐使用是指 JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持。(实际上服务器端也支持)<br><br>- 现代方法 :<br><br>`Object.getPrototypeOf(obj)`  返回对象 obj 的 [[Prototype]]。<br><br>`Object.create(proto, [descriptors]) `,创建一个空的新对象, 新对象的[[Prototype]指向proto对象  ,  [descriptors] : 可选的属性描述  <br><br>`Object.setPrototypeOf(obj, proto)`  将对象 obj 的 [[Prototype]] 设置为 proto<br><br><br><br>- 我们可以使用 `Object.create` 来实现比复制 `for..in` 循环中的属性更强大的对象克隆方式: 包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters<br><br>```javascript<br>//Object.create 提供了一种简单的方式来浅拷贝一个对象的所有描述符：<br>let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));<br><br></code></pre></td></tr></table></figure></code></pre></li></ul><h5 id="原型简史"><a href="#原型简史" class="headerlink" title="原型简史"></a>原型简史</h5><blockquote><p>如果速度很重要，就请不要修改已存在的对象的 [[Prototype]] , 通常我们只在创建对象的时候设置它一次，自那之后不再修改, JavaScript 引擎对此进行了高度优化。</p><p>用 Object.setPrototypeOf 或 obj.<strong>proto</strong>= “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。</p></blockquote><ul><li><p>对象可以用作关联数组（associative arrays）来存储键/值对。,当用户存储—prototype– ,不会存储值,他只能是null  对象</p></li><li><p><code>__proto__</code> 不是一个对象的属性，只是 <code>Object.prototype</code> 的访问器属性,</p></li><li><blockquote><p><code>__proto__</code> 是一种访问 <code>[[Prototype]]</code> 的方式，而不是 <code>[[prototype]]</code> 本身。</p><p>如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调用，它会 set/get <code>[[Prototype]]</code>。</p></blockquote></li><li><p>当一个对象不继承 Object 对象时, –Prototype– 就不会当成访问器了,我们可以把这样的对象称为 “very plain” 或 “pure dictionary” 对象,缺点是没有内建对象的函数</p></li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-comment">// class 方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;...&#125;  <span class="hljs-comment">//new来新建对象时会自动调用该函数,初始化对象</span><br>  <span class="hljs-function"><span class="hljs-title">method1</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;<br>  <span class="hljs-function"><span class="hljs-title">method2</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;  <span class="hljs-comment">// 类的方法之间没有逗号</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>类的运行原理:</strong></p></li><li><p>在 JavaScript 中，类是一种函数。<code>class User &#123;...&#125;</code> 构造实际上做了如下的事儿：</p></li><li><pre><code class="javascript">class User &#123;  constructor(name) &#123; this.name = name; &#125;  sayHi() &#123; alert(this.name); &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>- &gt; 创建一个名为 `User` 的函数，该函数成为类声明的结果。该函数的代码来自于 `<span class="hljs-keyword">constructor</span>` 方法<br>  &gt;<br>  &gt; 存储类中的方法给 `User.prototype` , 包括 <span class="hljs-keyword">constructor</span>方法<br><br><br><br>- 人们常说 `<span class="hljs-class"><span class="hljs-keyword">class</span>` 是一个语法糖（旨在使内容更易阅读，但不引入任何新内容的语法, <span class="hljs-type">但是class 不仅仅是语法糖 :</span></span><br><br>  &gt; <span class="hljs-number">1.</span> 使用<span class="hljs-class"><span class="hljs-keyword">class</span> 创建的函数具有特殊的内部属性标记,<span class="hljs-type">[[FunctionKind]]:&quot;classConstructor&quot;</span>,  <span class="hljs-type">会检查该属性</span>,<span class="hljs-type">与普通函数不同，必须使用 `new` 来调用它：</span></span><br>  &gt;<br>  &gt; <span class="hljs-number">2.</span> 类方法不可枚举  ,类定义将 `<span class="hljs-string">&quot;prototype&quot;</span>` 中的所有方法的 `enumerable` 标志设置为 `<span class="hljs-literal">false</span>`<br>  &gt;<br>  &gt; <span class="hljs-number">3.</span> 类总是使用 `use strict`。 在类构造中的所有代码都将自动进入严格模式。<br><br><br><br><br>- 类表达式 : 就像函数一样，类可以在另外一个表达式中被定义，**被传递，被返回，被赋值等。**<br><br>  &gt; let User = <span class="hljs-class"><span class="hljs-keyword">class</span></span>&#123;&#125;  <br><br>- 类似于命名函数表达式（NamedFunctionExpressions）<br>  <br>  &gt; let User = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;&#125;  这个类名只在类内可见<br>  <br>- 类中可以也存在 getter/setter 在<span class="hljs-class"><span class="hljs-keyword">class</span>类中声明</span><br><br>- &gt; 也可以通过在 F.prototype中创建getter和setter来起作用。<br>  &gt;<br>  &gt; 不能在构造函数中声明<br><br>- 类字段 : 是一种允许直接在类中添加任何属性的语法,不再通过<span class="hljs-keyword">constructor</span>()<br><br>- &gt; 效果和在<span class="hljs-keyword">constructor</span>()中声明一样<br>  &gt;<br>  &gt; <span class="hljs-class"><span class="hljs-keyword">class</span>字段 :<span class="hljs-type">旧的浏览器可能需要 polyfill </span>, <span class="hljs-type">类字段（field）是最近才添加到语言中的。之前，我们的类仅具有方法</span></span><br><br>  <br><br>- 传递对象方法时,会出现丢失<span class="hljs-keyword">this</span>的现象, 类字段提供了另一种非常优雅的语法：<br><br>- &gt; 普通字段解决方法: <br>  &gt;<br>  &gt; <span class="hljs-number">1.</span>在类中 <span class="hljs-keyword">constructor</span> 中可以使用包装器<br>  &gt;<br>  &gt; <span class="hljs-number">2.</span>在类中 <span class="hljs-keyword">constructor</span> 中绑定 bind<br>  &gt;<br>  &gt; ```javascript<br>  &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  &gt; <span class="hljs-keyword">constructor</span>() &#123;<br>  &gt; <span class="hljs-keyword">this</span>.printName = <span class="hljs-keyword">this</span>.printName.bind(<span class="hljs-keyword">this</span>);<br>  &gt; click = () =&gt; &#123;<br>  &gt;       alert(<span class="hljs-keyword">this</span>.value);<br>  &gt;     &#125;<br>  &gt; &#125;<br>  &gt; <span class="hljs-comment">//..定义printName(); </span><br></code></pre></td></tr></table></figure></code></pre></li><li><h5 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h5></li><li><p>类继承是一个类扩展另一个类的一种方式。因此，我们可以在现有功能之上创建新功能。</p></li><li><p>关键字 extends 使用了很好的旧的原型机制进行工作,通过设置[[prototype]] 来进行继承操作 :</p></li><li><blockquote><p><code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 引用：</p><ol><li><p><code>Rabbit</code> 函数原型继承自 <code>Animal</code> 函数。 解释了静态属性为什么会被继承</p></li><li><p><code>Rabbit.prototype</code> 原型继承自 <code>Animal.prototype</code>。</p><p>—–来源于 (静态属性章节)</p></li></ol></blockquote></li><li><p>对于类字段 来说 ,相当于在constructor( ) 中定义变量一样,会被复制, 类中继承时, constructor()也会被继承,其中定义的变量 ,派生类和基类都会各自维护一份</p></li><li><p>类语法不仅允许指定一个类，在 extends 后可以指定任意表达式。</p></li></ul><ul><li><p><strong>重写方法:</strong></p></li><li><p>不希望完全替换父类方法，希望在父类方法的基础上进行调整或扩展其功能,Class 为此提供了 “super” 关键字。 </p></li><li><blockquote><ol><li>执行super.method(…) 来调用一个父类方法 </li><li>执行 super(…) 来调用一个父类 constructor（只能在我们的 constructor 中）</li></ol></blockquote></li><li><blockquote><p>箭头函数没有 super,在类中如果被访问，它会从外部函数获取,但是如果是普通函数调用, 将会抛出错误</p></blockquote></li></ul><ul><li><p><strong>重写constructor</strong>:</p></li><li><p>未提供constructor 时,默认生成:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(...args)</span> </span><br><span class="hljs-function"><span class="hljs-comment">&#123; super(...args); &#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>继承类提供constructor()<strong>必须调用</strong> super(…),<strong>并且 (!) 一定要在使用 <code>this</code> 之前调用。</strong></p></li><li><blockquote><p>继承类的构造函数:派生构造器具有特殊的内部属性 <code>[[ConstructorKind]]:&quot;derived&quot;</code>。该标签会影响它的 <code>new</code> 行为:</p><p>普通构造函数 new行为 : 当通过 <code>new</code> 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 <code>this</code>。</p><p>当继承的 constructor 执行时，<strong>它不会执行新建空对象并把this传给他的操作</strong>。它期望父类的 constructor 来完成这项工作。</p></blockquote></li><li><p>当我们在构造器中访问一个被重写的class字段时, <strong>父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong> (例如使用this.name 访问的都是父类构造器的name)</p><blockquote><p>原因 : 在于类字段初始化的顺序: </p><p>1.对于基类，在构造函数调用前初始化。</p><p>2.对于派生类，在 <code>super()</code> 后立刻初始化</p><p>如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题</p></blockquote></li></ul><h5 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h5><ul><li><p>我们可以把一个方法赋值给类的函数本身，而不是赋给它的 “prototype”。这样的方法被称为 静态的（static） 以 static 关键字开头</p></li><li><pre><code>class User &#123;  static staticMethod() &#123;    alert(this === User); //this是类构造器 User 自身  &#125;&#125;User.staticMethod = function() &#123;  alert(this === User);&#125;;   //在外面作为类的属性赋值作用相同<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br>- &gt; 从技术上讲，静态声明与直接给类本身赋值相同<br>  &gt;<br>  <br>- 静态属性和方法是可被继承的。详见继承过程<br><br>- &gt; 类的构造函数 也会通过[[prototype]] 链接起来,所以调用静态属性也会通过链进行查找     静态方法也可以<br><br>##### 私有 保护属性<br><br>- 在 JavaScript 中, 有两种类型的对象字段（属性和方法） : 公共 私有 <span class="hljs-comment">(**js语言实际实现的**)</span><br><br>- 受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中**模拟的类定义语法**。<br><br>- &gt;受保护的属性通常以下划线 _ 作为前缀。这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。<br>  &gt;<br>  &gt;受保护的字段是可以被继承的<br><br>- 只读属性 : 只需要设置 getter，而不设置 setter：<br><br>- 私有属性和方法应该以 # 开头。它们只在类的内部可被访问。我们无法从外部或从继承的类中访问它。<br><br>- &gt; getter/setter 访问器 可以让外部访问到私有属性<br><br>- &gt;  JavaScript引擎不支持或部分支持，需要进行填充。<br><br>- 私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 #waterAmount 和公共的 waterAmount 字段。<br><br>- &gt;私有字段不能通过 this[<span class="hljs-string">&#x27;#name&#x27;</span>] 访问<br><br>##### 扩展内建类<br>- 内建的类，例如 <span class="hljs-keyword">Array</span>，Map 等也都是可以扩展的<span class="hljs-comment">(**可被继承**)</span><br><br>- &gt; 继承自原生 `<span class="hljs-keyword">Array</span>` 的类 `PowerArray`<br>  &gt;<br></code></pre></td></tr></table></figure>&gt; class PowerArray extends Array &#123;&gt; isEmpty() &#123;&gt;  return this.length === 0;&gt; &#125;&gt; <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs monkey">- 内建的方法例如 `filter`，`map` 等 , 内部使用对象的  `constructor`  来实现这功能, 返回的正是子类 `PowerArray` 的新对象,<br><br>原因: 内部使用了对象的 `constructor` 属性来实现这一功能<br><br><br><br>- 通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承,但内建类却是一个例外。它们相互间不继承静态方法。<br><br><br><br><span class="hljs-meta">##### 类检查</span><br><br>- **instanceof 操作符** 用于检查一个对象是否属于某个特定的 <span class="hljs-class"><span class="hljs-keyword">class</span>。同时，它还考虑了继承。 还可以检查对象是否属于特定的构造函数</span><br><br> 算法的执行过程大致如下 :<br><br> <span class="hljs-number">1</span>. 如果这儿有静态方法 `Symbol.hasInstance`，那就直接调用这个方法<br> &gt;<span class="hljs-number">2</span>. 大多数 <span class="hljs-class"><span class="hljs-keyword">class</span> 没有 `<span class="hljs-title">Symbol</span>.<span class="hljs-title">hasInstance</span>`,使用 `<span class="hljs-title">obj</span> <span class="hljs-title">instanceOf</span> <span class="hljs-title">Class</span>` 检查 `<span class="hljs-title">Class</span>.<span class="hljs-title">prototype</span>` 是否等于 `<span class="hljs-title">obj</span>` 的原型链中的原型之一</span><br> <br><br> <br><br>**prototypeObj.isPrototypeOf(object)** 方法 , 在该对象object的原型链上搜寻,有的话返回<span class="hljs-literal">true</span><br><br>&gt; 例子 : Foo.prototype.isPrototypeOf(baz);<br><br> <br><br>- 可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的 toString 方法的行为。<br><br>- &gt; 如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 &#123;&#125;.toString.call 替代 instanceof<br><br><span class="hljs-meta">##### Mixin 模式</span><br>- 在 JavaScript 中，我们只能继承单个对象。每个对象只能有一个 [[Prototype]]。并且每个类只可以扩展另外一个类。但是有些时候这种设定（译注：单继承）会让人感到受限制。<br><br>- mixin 是一个包含其他类的方法的类,不需要继承<br><br>- &gt; 方法一 : 构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象,通过拷贝对象完成  Object.assign(User.prototype, sayHiMixin);<br><br> <br><br><span class="hljs-meta">#### 错误处理</span><br><br><span class="hljs-meta">##### try..catch</span><br><br>- <span class="hljs-keyword">try</span>..<span class="hljs-keyword">catch</span>，它使我们可以“捕获（<span class="hljs-keyword">catch</span>）”错误，因此脚本可以执行更合理的操作，而不是死掉<br><br>- &gt; 要使得 <span class="hljs-keyword">try</span>..<span class="hljs-keyword">catch</span> 能工作，代码必须是可执行的。对于代码中的语法错误等导致无法正常工作,<br><br><span class="hljs-keyword">try</span>..<span class="hljs-keyword">catch</span> 只能处理有效代码中出现的错误。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。<br><br>- 为了捕获到计划的（scheduled）函数中的异常，那么 <span class="hljs-keyword">try</span>..<span class="hljs-keyword">catch</span> 必须在这个函数内 例如:setTimeout()<br><br>- &gt;原因在于计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了 <span class="hljs-keyword">try</span>..<span class="hljs-keyword">catch</span> 结构<br><br>- 发生错误时，JavaScript 生成一个包含有关其详细信息的<span class="hljs-built_in">error</span> 对象。然后将该对象作为参数传递给 <span class="hljs-keyword">catch</span>, <br><br>- &gt; <span class="hljs-built_in">error</span> 对象具有两个主要属性： <br><br>name :  <span class="hljs-built_in">Error</span>名称    <br><br>message   : 关于 <span class="hljs-built_in">error</span> 的详细文字描述。 人类可读的 <span class="hljs-built_in">error</span> 信息  <br><br> stack : 当前的调用栈<br><br>- 如果我们不需要 <span class="hljs-built_in">error</span> 的详细信息，<span class="hljs-keyword">catch</span> 也可以忽略它：(新属性 可能有兼容性)  <span class="hljs-keyword">catch</span>不加括号即可<br><br><br><br>- **抛出自定义的<span class="hljs-built_in">error</span>:**<br><br>- `<span class="hljs-keyword">throw</span>` 操作符 : 通过 <span class="hljs-keyword">throw</span> 关键字 , 可以抛出自定义错误 <span class="hljs-built_in">error</span>对象<br><br> <br><br><br><br>- **自定义 <span class="hljs-built_in">error</span>**   : 技术上讲，我们可以将任何东西用作 <span class="hljs-built_in">error</span> 对象。  但最好使用对象，最好使用具有 name 和 message 属性的对象, <br><br>JavaScript 中有很多内建的标准 <span class="hljs-built_in">error</span> 的构造器：<span class="hljs-built_in">Error</span>，SyntaxError，ReferenceError，TypeError 等<br><br>- 对于内建的 <span class="hljs-built_in">error</span>,`name` 属性刚好就是构造器的名字。`message` 则来自于参数（argument）。<br><br>```javascript<br> &gt;let <span class="hljs-built_in">error</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Things happen o_O&quot;</span>);<br>alert(<span class="hljs-built_in">error</span>.name); // <span class="hljs-built_in">Error</span><br> &gt;alert(<span class="hljs-built_in">error</span>.message); // Things happen o_O<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p><strong>重新抛出 error</strong></p></li><li><p>catch 会捕获到 <strong>所有</strong> 来自于 <code>try</code> 的 error, 但是我们希望一个catch单独处理一个类型的error, 所以进行重新抛出</p><ul><li><p>具体操作:</p><blockquote><p>Catch 捕获所有 error。</p><p>在 <code>catch(err) &#123;...&#125;</code> 块中，我们对 error 对象 <code>err</code> 进行分析。我们可以使用 <code>instanceof</code> 操作符判断错误类型,还可以使用err.name 获取错误的类名</p><p>如果我们不知道如何处理它，那我们就 <code>throw err</code>。</p></blockquote></li></ul></li><li><p>使用err.name类名 还是 instanceof 分析error对象, 尽量使用instanceof,<code>instanceof</code> 检查对于新的继承类也适用。所以这是面向未来的做法。</p></li></ul><ul><li><p><strong>try…catch…finally 语句</strong>:</p></li><li><blockquote><p> finally 子句（clause）通常用在：当我们开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。  try存在显式的return   throw 也还是会执行finally </p></blockquote><p><strong>全局错误处理</strong></p><blockquote><p>设想一下，在 <code>try..catch</code> 结构外有一个致命的 error，然后脚本死亡了。这个 error 就像编程错误或其他可怕的事儿那样。我们可能想要记录这个 error，并向用户显示某些内容</p><p>这时需要全局错误处理程序,</p><p>全局错误处理程序 window.onerror 的作用通常不是恢复脚本的执行 — 如果发生编程错误，那这几乎是不可能的，它的作用是将错误信息发送给开发者。也有针对这种情况提供错误日志的 Web 服务</p></blockquote></li></ul><h5 id="自定义-Error，扩展-Error"><a href="#自定义-Error，扩展-Error" class="headerlink" title="自定义 Error，扩展 Error"></a>自定义 Error，扩展 Error</h5><ul><li><p>当我们在开发某些东西时，经常会需要我们自己的 error 类来反映在我们的任务中可能出错的特定任务.,这些类需要支持基本的error基本属性 : name,message ,还可能有属于它们自己的属性, 所以我们需要扩展ERROR</p></li><li><blockquote><p>JavaScript 允许将 <code>throw</code> 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 <code>Error</code> 中继承。但是，如果我们继承，那么就可以使用 <code>obj instanceof Error</code> 来识别 error 对象。因此，最好继承它。</p></blockquote></li><li><p>包装异常 : 多种error 会发生,但是没必要检查所有的error类型,新建一个抽象的erroer类型,用来表示一类的error , 如果需要更多 error 细节，那么可以检查 抽象异常类的 cause 属性</p></li></ul><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><ul><li><p>回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景</p></li><li><p>“基于回调”的异步编程风格: 异步执行某项功能的函数提供一个 callback 参数用于在相应事件完成时调用。</p><blockquote><p>这种风格有以下几种问题:</p><ol><li>异步函数之间的执行顺序,是谁先被处理完谁先调用,这使得我们无法控制调用顺序, 而当多个异步函数之间有依赖关系,必须控制回调函数的执行顺序, 我们只能通过嵌套的方式来实现控制顺序,但是会造成混乱的结构,所谓的’厄运金字塔’</li></ol><ol start="2"><li>我们提供的callback 参数中,必须要有两种方案,成功/失败的情况,这种情况只能传递二个callback ,或者一个函数多个参数,写起来也很繁琐</li></ol></blockquote></li><li><p>基于以上问题 es6 引入Promise,解决异步编程的回调问题</p></li></ul><h5 id="promise操作"><a href="#promise操作" class="headerlink" title="promise操作"></a>promise操作</h5><ul><li><p>promise 构造语法 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span><br><span class="hljs-function"></span>&#123;<br>      ....<br>      resolve()/reject()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> <code>new Promise()</code> 函数是同步函数, resolve/reject()函数调用后才会产生微任务,之后调用的then..是异步函数,也是微任务</p></li><li><p>特殊的我们可以在类中 使用then()函数创建一个promise对象</p><blockquote><p>class{  then(resolve,reject){ resolve()…}}</p></blockquote></li></ul><ul><li><p>由 new Promise 构造器返回的 promise 对象具有以下内部属性：</p><blockquote><ol><li><p>state — 初始值是 “pending”，然后在 resolve 被调用时变为 “fulfilled”，或者在 reject 被调用时变为 “rejected”。</p></li><li><p>result —初始值是 ‘undefined’，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。</p></li></ol><p>一个 ‘resolved ‘或 ‘rejected’ 的 promise 都会被称为 “settled”。promise的状态改变之后不可逆转</p></blockquote></li></ul><ul><li><p><code>resolve/reject</code> 只需要一个参数（或不包含任何参数），并且将忽略额外的参数</p></li><li><p>Promise 对象的 state 和 result 属性都是内部的。我们无法直接访问它们。但我们可以对它们使用 .then/.catch/.finally 方法</p></li></ul><ul><li><p><strong>then 、catch、finally函数:</strong>  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">  promise.then(<br>  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> </span>&#123; <span class="hljs-comment">/* handle a successful result */</span> &#125;,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123; <span class="hljs-comment">/* handle an error */</span> &#125;<br>);<br>如果我们只对成功完成的情况感兴趣，那么我们可以只为 .then 提供一个函数参数,如果我们只对 error 感兴趣，那么我们可以使用 <span class="hljs-literal">null</span> 作为第一个参数<br></code></pre></td></tr></table></figure></li><li><blockquote><p><code>.catch(func) </code>, 是.then(null, f) 的完全的模拟，它只是一个简写形式。只捕获错误情况,    当catch捕获错误之后, promise对象又会回到 resolve的状态,这也和then()有关</p></blockquote></li><li><blockquote><p><code>finally(func)</code> 是执行清理的很好的处理程序,  func函数中<strong>并没有参数</strong>,它的目的就是清理程序</p><p>finally 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject。</p><p>它会将 result 或者 error 传递给下一个处理程序(如果存在)</p></blockquote></li></ul><ul><li>如果 promise 为 pending 状态，**.then/catch/finally 处理程序（handler）将等待它。**</li></ul><h5 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h5><ul><li><p>Promise 链解决了控制异步函数顺序的问题</p></li><li><p>对 <code>promise.then</code> 的调用仍旧返回一个 promise对象,所以它才能链式调用</p><blockquote><p>当然我们也可以在then函数中,return一个值 或者return 新的 promise对象,</p><ol><li>.then中如果创建并返回一个新的promise。其他的处理程序(例如then..)将等待它 settled 后再获得其结果,  使我们能够构建异步行为链。</li><li>如果只是return 一个值,不在进行等待直接进行调用链的下一个处理函数</li></ol></blockquote></li></ul><ul><li><p><strong>默认情况下,  then() /catch()函数调用之后,总是返回一个 resolve 状态的Promise对象</strong>,换句话说就算传递给then()函数的Promise对象是reject的,下一个链式调用的then 收到的还是一个resolve 状态的Promise对象,  这种情况只限于默认情况,如果return一个Promise就需要看这个promise的状态</p></li><li><p>例子: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span>  <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span> &#123;<br>         reject(<span class="hljs-string">&quot;rejiec&quot;</span>);&#125;).then(<br>         value =&gt;&#123;<span class="hljs-built_in">console</span>.log(value); &#125;,<br>         reason =&gt; &#123;<span class="hljs-built_in">console</span>.log(reason)&#125;<br>     ).then(<br>         a =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;asdf&quot;</span>), <span class="hljs-comment">// 第一个then 不管进行那个处理,都会进行这一行操作</span><br>         b =&gt; <span class="hljs-built_in">console</span>.log(b)<br>     );<br>  <span class="hljs-comment">// 如果then中处理了error状况, then后面如果有catch就不再执行</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>确切地说，处理程序返回的不完全是一个 promise，而是返回的被称为 “thenable” 对象 — 一个具有方法 .then 的任意对象。它会被当做一个 promise 来对待。</p></blockquote></li><li><p>promise链是向下增长 , 嵌套式的promise调用是向右增长</p></li></ul><h5 id="promise-处理错误"><a href="#promise-处理错误" class="headerlink" title="promise 处理错误"></a>promise 处理错误</h5><ul><li><p>捕获所有 error 的最简单的方法是，将 .catch 附加到链的末尾,如果then把错误捕获,就不在调用catch</p><blockquote><p>在实际书写中,我们只在then里写成功的情况,用catch进行捕获</p></blockquote></li><li><p>抛出自定义异常: </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">reject(<span class="hljs-keyword">new</span> <span class="hljs-type">httpError</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>)); <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ParamsError</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>); <span class="hljs-comment">//在then处理程序中定义</span><br></code></pre></td></tr></table></figure></li><li><p>异常再次抛出:</p><blockquote><p>在常规的 try..catch 中，我们可以将其再次抛出。对于 promise 来说，如果我们在 .catch 中 throw error，那么它会忽略其他的处理程序跳转到下一个catch。如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 .then 处理程序</p></blockquote></li><li><p>当一个 error 没有被处理会发生什么？</p><blockquote><p>如果出现 error，promise 的状态将变为 “rejected”,   然后执行应该跳转至最近的 rejection 处理程序, 如果没有, JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error </p></blockquote></li><li><p>全局的error捕获:</p></li><li><blockquote><p>在浏览器中，我们可以使用 unhandledrejection 事件来捕获这类 error, 这个事件对象有两个特殊的属性</p><p>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  alert(event.promise); <span class="hljs-comment">// [object Promise] - 生成该全局 error 的 promise</span><br>  alert(event.reason); <span class="hljs-comment">// Error: Whoops! - 未处理的 error 对象</span><br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h5><ul><li><p>在 Promise 类中，有 5 种静态方法。</p></li><li><p><code>Promise.all()</code>:  如果任意一个 promise 被 reject，由 Promise.all 返回的 promise 就会立即 reject，并且带有的就是这个 error。都成功才算成功</p></li><li><p><code>Promise.allSettled()</code>：等待所有的 promise 都被 settle，无论结果如何。他自身始终返回一个 resolve的promise对象</p></li><li><p><code>Promise.race</code>: 只等待第一个 settled 的 promise 并获取其结果（或 error）</p></li><li><p><code>Promise.resolve(value)</code> 用结果 value 创建一个 resolved 的 promise。可以用来缓存数据,不再进行 promise() 中的运算 </p></li><li><p><code>Promise.reject(error)</code> 用 error 创建一个 rejected 的 promise。 </p></li></ul><h5 id="Promisification"><a href="#Promisification" class="headerlink" title="Promisification"></a>Promisification</h5><ul><li>“Promisification”   它指将一个接受回调的函数转换为一个返回 promise 的函数。</li></ul><h5 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h5><ul><li><p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法, 本质上是一种语法糖</p></li><li><p><code>async关键字</code>: async function()  这个函数总是返回一个 promise。return 其他值, 将自动被包装在一个 resolved 的 promise 中。</p></li><li><p><code>await关键字</code> :它只在 async 函数内工作, 等待直到 promise settle，接受结果/error,  还可以使用await newPromise() 返回一个新的promise对象</p><blockquote><p>使用await时 , 如果 promise 被 reject，它将 throw 这个 error，使用try ..catch 语法去捕获这个错误 ,或者使用 async函数().catch() </p></blockquote></li><li><p>async/await 可以和 Promise.all 一起使用 等待多个promise的结果</p></li><li><p>await 本质上就是then()函数</p></li><li><p>await 接受 “thenables”, await 允许我们使用 thenable 对象（那些具有可调用的 then 方法的对象)</p></li></ul><h4 id="Generator-异步迭代"><a href="#Generator-异步迭代" class="headerlink" title="Generator  异步迭代"></a>Generator  异步迭代</h4><ul><li><p>一般的函数只能返回一个单一值, Generator 函数可以按需一个接一个地返回（“yield”）多个值。它们可与 iterable 完美配合使用，从而可以轻松地创建数据流。</p></li><li><p>创建generator</p><blockquote><p>function* generateSequence(){ yield 1;  yield 2;  return 3}</p><p>它不会运行其代码。而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。</p></blockquote></li><li><p>一个 generator 的主要方法就是 next(),<code>generator object</code>每次调用函数,就返回一个值,</p></li><li><p>next() 的结果始终是一个具有两个属性的对象：</p><blockquote><p> value: 产出的（yielded）的值。</p><p>done: 如果 generator 函数已执行完成则为 true，否则为 false。</p></blockquote></li><li><p>generator 是 可迭代（iterable）的,我们可以使用 <code>for..of</code> 循环遍历它所有的值</p><blockquote><p>如果我们想要通过 <code>for..of</code> 循环显示所有的结果，我们必须使用 <code>yield</code> 返回它们,不可以使用return, 否则循环就不再显示最后一个</p></blockquote></li><li><p>我们可以通过提供一个 generator 函数作为 Symbol.iterator，来使用 generator 进行迭代</p><blockquote><p> <em>[Symbol.iterator] (){ }    // [Symbol.iterator]: function</em>() 的简写形式</p></blockquote></li><li><p>Generator 嵌套  ,可以迭代更复杂的输出</p><blockquote><p>我们可以使用 yield* 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中：</p></blockquote></li></ul><p><strong>异步迭代：</strong></p><ul><li>要使对象异步迭代：<ol><li>使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li><li><code>next()</code> 方法应该返回一个 <code>promise</code></li></ol></li><li>Generator 异步迭代 。。。。</li></ul><h4 id="模块-moudule"><a href="#模块-moudule" class="headerlink" title="模块 (moudule)"></a>模块 (moudule)</h4><ul><li><p>模块的核心功能:</p></li><li><blockquote><p>模块始终默认使用 use strict。</p><p>每个模块都有自己的块作用域</p><p><strong>模块代码仅在第一次导入时被执行</strong>,然后将导出的内容提供给所有的导入。当改变其中的对象时其他模块随之改变</p></blockquote></li><li><blockquote><p><code>import.meta</code> 对象包含关于当前模块的信息,   它包含当前脚本的 URL</p></blockquote></li><li><p><strong>浏览器模块:</strong></p></li><li><p>在浏览器中使用模块 , 必须有 type=”module”</p></li><li><blockquote><p>下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code></p></blockquote></li><li><p>在本地 外联引入模块化的脚本会出现跨域问题,解决方法开启本地服务器即可</p></li><li><p>模块脚本总是被延迟的 :</p></li><li><blockquote><p>下载外部模块脚本不会阻塞 HTML 的处理，它们会与其他资源并行加载。</p><p>模块脚本会等到 HTML 文档完全准备就绪,然后执行。而常规脚本则会立即运行，</p></blockquote></li><li><p>具有 <code>type=&quot;module&quot;</code> 的外部脚本（external script）在两个方面有所不同：</p><blockquote><p>具有相同 <code>src</code> 的外部脚本仅运行一次</p><p>从另一个源（例如另一个网站）获取的外部脚本需要 <a href="https://developer.mozilla.org/zh/docs/Web/HTTP/CORS">CORS</a> header，</p></blockquote></li><li><p>旧时的浏览器不理解 <code>type=&quot;module&quot;</code>。未知类型的脚本会被忽略。对此，我们可以使用 <code>nomodule</code> 特性来提供一个后备</p></li><li><p>对于非模块脚本，async 仅适用于外部脚本。异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档。 对于模块脚本，它也适用于内联脚本</p></li></ul><ul><li><p>浏览器模块很少单独使用，通常使用构建工具， </p></li><li><p><a href="https://zh.javascript.info/modules-intro#gou-jian-gong-ju">构建工具的必要性</a></p><blockquote><p>如果我们使用打包工具，那么脚本会被打包进一个单一文件（或者几个文件），在这些脚本中的 <code>import/export</code> 语句会被替换成特殊的打包函数（bundler function）。因此，最终打包好的脚本中不包含任何 <code>import/export</code>，它也不需要 <code>type=&quot;module&quot;</code>，我们可以将其放入常规的 <code>&lt;script&gt;</code>：</p></blockquote></li><li><p>还有的打包工具利用原生的 import 打包，不再使用打包函数进行替换了。。。</p></li></ul><h5 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h5><ul><li><p>导出</p><blockquote><p>在声明前导出  : <em>export</em> let months={}</p><p>导出与声明分开 :   export {sayHi, sayBye};    // 导出变量列表</p></blockquote></li><li><p>导入</p></li></ul><blockquote><p>import {sayHi} from ‘./say.js’; 明确导入</p><p>import * as say from ‘./say.js’;   所有内容导入为一个对象</p></blockquote><ul><li><p>使用 <code>as</code> 让导入具有不同的名字 , </p><blockquote><p> <strong>import {sayHi as hi, sayBye as bye} from ‘./say.js’;</strong></p><p><strong>export {sayHi as hi, sayBye as bye};</strong></p></blockquote></li></ul><ul><li><p>主要有两种模块: </p></li><li><blockquote><p>1.包含库或函数包的模块  </p><p>2.声明单个实体的模块,例如模块 <code>user.js</code> 仅导出 <code>class User</code></p></blockquote></li><li><p>export default 语法，以使“一个模块只做一件事”的方式看起来更好</p><blockquote><p>将 <code>export default</code> 放在要导出的实体前 或者分开<code>export &#123;sayHi as default&#125;</code>;</p><p><strong>import <em>User</em> from ‘./user.js’;</strong>  将其导入而不需要花括号</p></blockquote></li><li><p> 每个文件最多只能有一个默认的导出</p></li></ul><ul><li><p><strong>重新导出:</strong></p></li><li><blockquote><p>语法:   <strong>export {login, logout} from ‘./helpers.js’;</strong>  相当于</p><p>import {login, logout} from ‘./helpers.js’; </p><p>export {login, logout};</p></blockquote></li><li><p>重新导出中的 默认导出需要单独处理 , </p><blockquote><p> export User from ‘./user.js’  无效  我们必须明确写出 export {default as User}`</p><p> `export * from ‘./user.js  重新导出只导出了命名的导出，但是忽略了默认的导出。</p></blockquote></li></ul><h5 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h5><ul><li><blockquote><p>import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。</p><p><strong>let {hi, bye} = await import(‘./say.js’);</strong></p></blockquote></li><li><p>动态导入在常规脚本中工作时，它们不需要 script type=”module”. </p></li><li><p>尽管 import() 看起来像一个函数调用，但它只是一种特殊语法,不是真正的函数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础上</title>
    <link href="/2021/02/21/Node%20+%20JS/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8A/"/>
    <url>/2021/02/21/Node%20+%20JS/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="JS-入门精通"><a href="#JS-入门精通" class="headerlink" title="JS 入门精通"></a>JS 入门精通</h2><h3 id="JS基础知识"><a href="#JS基础知识" class="headerlink" title="JS基础知识"></a>JS基础知识</h3><h4 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h4><ul><li><p>JS在任意搭载了 JavaScript 引擎 的设备中都可以执行</p><blockquote><p>V8 —— Chrome 和 Opera 中的 JavaScript 引擎。<br>SpiderMonkey —— Firefox 中的 JavaScript 引擎。</p></blockquote></li><li><p>现代的 JavaScript 是一种“安全”语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能</p></li><li><p>“use strict” 严格模式 </p></li><li><blockquote><p>ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。 需要手动的使用 严格模式</p></blockquote></li><li><p>“classes” 和 “modules”  会自动调用 严格模式</p></li></ul><h4 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h4><ul><li>let var   变量</li><li>常量 : const   初始赋值之后就不会改变。</li><li><blockquote><p>大写命名的常量仅用作“硬编码（hard-coded）”值的别名。常规命名用作执行中被计算出的值<br>变量代码规范:  变量的名要尽量具体,远离a b这种,或者data value这种,相当于没说明这变量的用处,变量是重用还是新建: 额外声明一个变量绝对是利大于弊的</p></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4></li><li>在 JavaScript 中有 8 种基本的数据类型(7 种原始类型和 1 种引用类型)<blockquote><p>在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0(得到infinity)，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。</p></blockquote></li></ul><ol><li><p>number 类型代表整数和浮点数。</p></li><li><p>BigInt 类型，用于表示任意长度的整数(有些大数据超出了number表示范围)。可以通过将n附加到整数字段的末尾来创建 BigInt 值。</p></li><li><p>String 类型, JavaScript 中的字符串必须被括在引号里。有三种包含字符串的方式:单/双引号,反引号</p><blockquote><p>反引号是功能扩展引号。它们允许我们通过将变量和表达式包装在 ${…}中<br>可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。仅仅在反引号内有效</p></blockquote></li><li><p>boolean 类型仅包含两个值：true 和 false。</p></li><li><p>undefined 的含义是未被赋值。如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.</p></li><li><p>symbol 类型,(在ECMAScript 6 中新添加的类型)。一种实例是唯一且不可改变的数据类型。</p></li><li><p>null null类型值只有一个(null), (JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。) 例如 : let a = null;</p></li><li><p>Object类型(引用类型)</p></li></ol><ul><li><p>typeof 运算符返回参数的类型 支持两种方式  作为运算符：typeof x。 函数形式：typeof(x)。</p><blockquote><p>NaN 即 Not a Number 它是用来表示是否属于number类型的一种状态,不属于类型/值</p><p>infinity 表示数字无穷大 除以0得到  也是一种状态不是类型</p></blockquote><h4 id="交互函数"><a href="#交互函数" class="headerlink" title="交互函数"></a>交互函数</h4></li><li><p>alert、prompt 和 confirm</p></li><li><p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4></li><li><p>隐式类型转换</p><ul><li>大多数情况下，运算符和函数会自动将赋予他们的值转换为正确的类型。</li><li><blockquote><p>例如: alert 会自动将任何值都转换为字符串以进行显示。</p><p>算术运算符会将值转换为数字 ,   使用+运算符是特殊情况</p></blockquote></li></ul></li><li><p>显示类型转换:</p></li><li><p>字符串转换规则:</p><blockquote><p>显式地调用 String(value) 来将 value 转换为字符串类型</p></blockquote><blockquote><p>如果该字符串不是一个有效的数字，转换的结果会是 NaN .</p><p>例如:alert( Number(“123z”) );// NaN （从字符串“读取”数字，读到 “z” 时出现错误）</p></blockquote></li><li><p>number 类型转换规则： </p><blockquote><p>Number(value) 显式地将这个 value 转换为 number 类型,</p></blockquote><blockquote><p>undefined =&gt; NaN     null =&gt; 0      true和false =&gt; 1 and 0</p></blockquote></li><li><p>布尔型转换 转换规则如下：</p><blockquote><p>直观上为“空”的值 : 如 0、空字符串、null、undefined 和 NaN</p><p>其他值变成 true。</p><p>字符串 “0” 是 true</p></blockquote></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>“ ** “ 运算符  =&gt;   2**3 等于 2^3</p></li><li><p>“+” 运算符中(二元运算符), 只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</p></li><li><p>“+” 运算符中(一元运算符),会将其转化为数字。</p><blockquote><p>  一元运算符+ ,可以转换成数字  alert( +true ); // 1</p></blockquote></li><li><p>对于其他算术运算符,仅使用数字，并且始终将其操作数转换为数字。</p><blockquote><p>alert( 6 - ‘2’ ); // 4</p></blockquote></li><li><p>逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。</p><blockquote><p>例子 : for (a = 1, b = 3, c = a * b; a &lt; 10; a++)</p><p>let a = (1 + 2, 3 + 4);</p><p>请注意逗号运算符的优先级非常低，比 <code>=</code> 还要低，</p></blockquote></li><li><p>优先级:</p><blockquote><p>没有必要把这全记住，但要记住一元运算符优先级高于二元运算符</p></blockquote></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><p>“||” 运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</p></li><li><p>“&amp;&amp;” 运算的链中,返回第一个假值，如果没有假值, 就返回最后一个值。</p><blockquote><p>经常用来进行赋值操作</p></blockquote></li><li><p>! 表示布尔非运算 , 首先转换为布尔值,再给出相反值 </p></li><li><blockquote><p>!! 有时候用来将某个值转化为布尔类型：</p></blockquote></li><li><p> 空值合并运算符’??’   ….</p></li></ul><h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><ul><li><p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p><blockquote><p>所以会出现一种现象, 直接比较相等 转换为布尔值不同  例如 0  ‘0’</p></blockquote></li><li><p>普通的 <code>== </code>存在一个问题，它不能区分出 0 和 false,也同样无法区分空字符串和 false</p><blockquote><p>因为两侧的值会先被转化为数字,</p><p>如果想在进行比较时不会做<strong>任何的类型转换</strong>。使用 <code>=== </code>符号</p></blockquote></li><li><p>null 和 undefined 使用<code>==</code>进行比较时,JavaScript 存在一个特殊的规则，会判定它们相等。</p><blockquote><p>undefined 和 null 在相等性检查<code> ==</code>中不会进行任何的类型转换,所以除了他们之间相等不会等于任何值</p><p>在<code>===</code>中是不相等的 :    null === undefined    // false</p></blockquote></li><li><p>比较 null 和 0</p><blockquote><p>alert( null &gt; 0 );  // (1) false </p><p>alert( null == 0 ); // (2) false </p><p>alert( null &gt;= 0 ); // (3) <em>true</em>    </p><p>原因: <code>==</code>运算符是特殊的, <code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换, 但是使用&gt;= … 运算符 null 转换为0比较</p></blockquote></li><li><p><code>undefined</code> 不应该被与其他值进行比较：他和谁比都是false  除了null</p></li><li><p>“!=”  “!==” 之间的差别 : “!=” 会进行数据转换比较,” !== “不会,数据类型不同就不存在相等</p></li></ul><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ul><li><p>if判断 , 循环语句,  : ?语句</p></li><li><p>跳出嵌套循环  标签 + break/continue </p><blockquote><p>outer: for (let i = 0; i &lt; 3; i++) 标签后加循环语句<br>只有在循环内部才能调用 break/continue，并且标签必须位于指令上方的某个位置。</p></blockquote></li><li><p><code>switch</code> 语句可以替代多个 <code>if</code> 判断。</p></li><li><p>switch case中不会进行类型转换,如果类型不相等就不匹配</p><blockquote><p>case分组: </p><p>例如: case 4: case 5: 处理函数     </p></blockquote></li></ul><h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h4 id="函数参数-和返回值"><a href="#函数参数-和返回值" class="headerlink" title="函数参数  和返回值"></a>函数参数  和返回值</h4><ul><li><p>函数参数</p><blockquote><p>函数修改的是复制的变量值副本,对原来的值并没有影响(浅拷贝)</p></blockquote></li><li><p>如果调用带参数的函数,未提供参数也没有默认值, 参数默认 为undefined</p></li><li><p>函数参数的默认值 </p><blockquote><p>function showMessage(from, text = “no text given”)  在等号后给与默认参数</p></blockquote></li></ul><ul><li>空值的 return 或没有 return 的函数返回值为 undefined</li><li>函数命名: 一种普遍的做法是用动词前缀来开始,描述函数行为</li></ul><h4 id="函数表达式-函数声明-回调函数"><a href="#函数表达式-函数声明-回调函数" class="headerlink" title="函数表达式 函数声明  回调函数"></a>函数表达式 函数声明  回调函数</h4><ul><li><p><strong>函数声明和函数表达式的区别</strong></p></li><li><p>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</p><ul><li>函数声明,调用时不在乎函数声明的位置(这是内部算法的原故,当 JavaScript 准备 运行脚本时，首先会在脚本中寻找全局函数声明)</li></ul></li></ul><ul><li><p>在其他编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待 </p></li><li><blockquote><p>例如  可以用函数名进行赋值</p><p> alert(sayHi) 会输出函数的源码而不会被调用,想要调用需要有括号</p></blockquote></li></ul><ul><li><p>函数参数值是函数,这被称为<strong>回调函数</strong></p><blockquote><p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。</p></blockquote></li><li><p>函数参数可以是匿名函数,但是函数外无法调用,</p></li><li><blockquote><p>  这正是我们需要的,只在函数内有效</p></blockquote></li></ul><h4 id="箭头函数-深入理解箭头函数"><a href="#箭头函数-深入理解箭头函数" class="headerlink" title="箭头函数  深入理解箭头函数"></a>箭头函数  深入理解箭头函数</h4><ul><li><p>箭头函数:</p><blockquote><p>单行的箭头函数箭头后就是返回值, 不需要return值</p><p>对于表达式有多行的箭头函数,要有return值</p><p>参数只有一个时,不需要括号</p></blockquote></li><li><p>箭头函数可以像函数表达式一样使用</p><blockquote><p>let sum = (a,b)=&gt; a+b</p></blockquote></li></ul><ul><li><p>箭头函数 实现了在函数中不需要离开上下文, 随时创建一个函数并传递到当前位置</p></li><li><p>箭头函数没有 “this” , 如果访问 this，则会从外部获取。而对于普通函数来说,如果没有调用它,函数的 <code>this</code> 为默认值 <code>this=undefined</code></p><blockquote><p>例如: 回调函数是一个普通的函数,那么函数内this 是未定义的</p></blockquote></li><li><p>箭头函数 <code>=&gt;</code> 和使用 <code>.bind(this)</code> 调用的常规函数之间有细微的差别：</p><blockquote><p>bind(this) 创建了一个 函数绑定版本, 而箭头函数没有绑定,它只是从外部寻找</p></blockquote></li></ul><ul><li><p>不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器不能用 new 调用它们。</p></li><li><p>箭头函数没有 “arguments”</p></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h4><blockquote><p>let user = new Object(); // “构造函数” 的语法   创建空对象<br>let user = {};  // “字面量” 的语法</p></blockquote><h4 id="定义-操作对象属性"><a href="#定义-操作对象属性" class="headerlink" title="定义/操作对象属性"></a>定义/操作对象属性</h4><ul><li><p>我们可以随时添加、删除和读取文件。通过 .运算符    delete关键字 </p></li><li><p>对于多词属性，点操作就不能用了</p></li><li><blockquote><p>user.likes birds = true  // 报错 用方括号 user[“likes birds”] = true;</p><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方法</p><p>当属性名是已知且简单的时候，就是用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p></blockquote></li><li><p>带有cosnt的对象内容仍然可以被更改, 但是以对象为整体无法改变 </p><blockquote><p>例如: const user = { ame: “John”};  user=…  会出现报错,但是更改name的值是允许的</p></blockquote></li></ul><ul><li>计算属性  : 当创建一个对象时，我们可以在对象字面量中使用方括号</li><li><blockquote><p>let fruit = prompt(“Which fruit to buy?”, “apple”);</p><p>let bag = {</p><p>[ fruit]: 5, // 属性名是 fruit 计算得到的</p><p>};</p></blockquote></li></ul><p>属性的其他操作</p><ul><li><p> 属性值缩写 :</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">function</span></span> makeUser(<span class="hljs-keyword">name</span>, age) &#123;  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-keyword">name</span>, // 与 <span class="hljs-keyword">name</span>: <span class="hljs-keyword">name</span> 相同<br>    age,  // 与 age: age 相同<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>属性名称限制 :</p></li><li><blockquote><p>不能是保留字,其他类型会自动转换为字符串类型   , 如果是复杂的标识名,加上引号声明</p><p>例如: {0:test  “ee er”:22}  0转换为字符串  </p></blockquote></li><li><p>检查属性是否存在 :</p></li><li><blockquote><p>使用操作符 “in”  例如: “key” in objectname</p><p>为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：for..in</p></blockquote></li><li><p>js可以访问任何对象的属性,就算该属性不存在也不会发生错误,返回一个undefined类型</p></li><li><p>对象属性顺序 : 整数属性会被进行排序，其他属性则按照创建的顺序显示(保证在遍历对象时,它的顺序可预知)</p></li><li><blockquote><p>这里的“整数属性”指的是一个可以在不作任何更改的情况下转换为整数的字符串</p><p>“49” 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样。但是 “+49” 和 “1.2” 就不行了</p></blockquote></li></ul><h4 id="对象引用-复制"><a href="#对象引用-复制" class="headerlink" title="对象引用  复制"></a>对象引用  复制</h4><ul><li><p>对象与原始类型其中一个基本的区别是：对象“<code>通过引用的形式</code>”被存储和拷贝,所以对象只有一份</p></li><li><p>变量存储的不是对象自身，而是该对象的“内存地址”，换句话说就是一个对该对象的“引用”, <strong>当一个对象变量被复制 —— 引用则被复制，而该对象并没有被复制。</strong></p></li><li><p>对象<code>==</code>比较</p><blockquote><p>仅当两个对象为同一对象时，两者才相等。</p><p>跟一个原始类型值的比较 <code>obj == 5</code>，对象会被转换为原始值</p><p>对于对象来说，普通相等 == 和严格相等 === 是两个作用结果完全一样的运算符</p></blockquote></li></ul><ul><li><p><strong>对象拷贝 合并 :</strong></p></li><li><p>JS并没有提供内置的方法实现对象拷贝,我们通过 for…in进行对象属性的逐一复制</p></li><li><blockquote><p>通过<code> Object.assign(dest, [src1, src2, src3...])</code> 来达成同样的效果,    src : 对象, 可以是多个对象合并到dest,  结果返回dest</p><p>dest 为空对象时, 完成对象简单拷贝</p></blockquote></li><li><p>该方法只能拷贝简单的对象, 当对象中的值是一个对象,只会拷贝引用</p><blockquote><p>想要完成’深度拷贝’,   我们可以用递归来实现。或者不自己造轮子，使用现成的实现，例如 JavaScript 库 <a href="https://lodash.com/">lodash</a> 中的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p></blockquote></li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li><p>可达性</p></li><li><blockquote><p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。</p><p>对于不可达的对象数据,进行垃圾处理</p></blockquote></li><li><p>不能被释放值 (称为根):</p><blockquote><p>当前函数的局部变量和参数。</p><p>嵌套调用时，当前调用链上所有函数的变量与参数。</p><p>全局变量。</p><p>（还有一些内部的）   </p></blockquote></li><li><p>垃圾回收算法: </p></li><li><blockquote><p>垃圾收集器找到所有的根，并“标记”（记住）它们。然后它遍历并“标记”来自它们的所有引用用,没有被标记的就被删除。 算法还有很多优化这里不再提及</p></blockquote></li></ul><h4 id="对象方法-方法中的”this”"><a href="#对象方法-方法中的”this”" class="headerlink" title="对象方法  方法中的”this”"></a>对象方法  方法中的”this”</h4><ul><li><p>作为对象属性的函数被称为 方法。</p><blockquote><p>通过属性名添加函数:   user.sayHi = function() {alert(“Hello!”);};<br>在对象中简写方法      user = {  sayHi: function() { alert(“Hello”);}};<br>更简单的书写          user = {  sayHi(){alert(“fog);} }<br>通过属性名添加函数名  function sayHi() { alert(“Hello!”);};  user.sayHi = sayHi;</p></blockquote></li><li><p>方法中的this</p></li><li><blockquote><p>为了访问该对象，方法中可以使用 <code>this</code> 关键字。<code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p></blockquote></li><li><p>为什么在方法中使用this 而不是对象名字?</p></li><li><blockquote><p>当我们新建一个新对象访问该方法,以前的数据还是旧数据</p></blockquote></li></ul><ul><li><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数不一定非要是对象方法。<code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p><blockquote><p>当函数分配给对象调用时,this的值才会计算出来</p><p>它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p></blockquote></li></ul><ul><li><blockquote><p>甚至在没有对象时也可以使用this, 在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong></p></blockquote></li></ul><h4 id="构造函数-new"><a href="#构造函数-new" class="headerlink" title="构造函数  new"></a>构造函数  new</h4><ul><li><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要<strong>创建许多类似</strong>的对象,</p><blockquote><p>例如多个用户. 这时需要构造函数, 构造器的主要目的 —— 实现可重用的对象创建代码</p></blockquote></li><li><p>构造函数在技术上是常规函数。不过有两个约定：</p></li><li><blockquote><ol><li>它们的命名以大写字母开头。</li><li>它们只能由 “new” 操作符来执行。</li></ol></blockquote></li><li><p>new通过构造函数创建对象的过程</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let user= <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(<span class="hljs-string">&quot;john&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span></span>(name) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;（隐式创建）</span><br>  <span class="hljs-comment">// 添加属性到 this</span><br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.isAdmin = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// return this;（隐式返回）</span><br>&#125;<br>构造函数只能使用 `<span class="hljs-keyword">new</span><span class="hljs-type"></span>` 来调用。这样的调用意味着在开始时创建了空的 `<span class="hljs-built_in">this</span>`，并在最后返回填充了值的 `<span class="hljs-built_in">this</span>`。<br></code></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行</p></blockquote><blockquote><p>在一个函数内部，我们可以使用 <code>new.target 属性</code>来检查它是否被使用 new 进行调用了。返回布尔值</p></blockquote></li><li><p>如果我们有许多行用于创建<strong>单个复杂对象</strong>的代码，我们可以将它们封装在构造函数中: </p></li><li><pre><code class="javascript">let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码&#125;;<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">  <br>- 通常，构造器没有 <span class="hljs-keyword">return</span> 语句。它们的任务是将所有必要的东西写入 <span class="hljs-built_in">this</span>，并自动转换为结果<br><br>- &gt; 带有对象的 <span class="hljs-keyword">return</span> 返回该对象，在所有其他情况下返回 <span class="hljs-built_in">this</span>。<br><br><br><br><br><br><span class="hljs-comment">#### 可选链运算</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- 可选链 `?.` 是一种访问**嵌套对象属性**的防错误方法。即使中间的属性不存在，也不会出现错误。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      可选链 ?. 语法有三种形式：</span><br><span class="hljs-comment">      obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。</span><br><span class="hljs-comment">      obj?.[ prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。</span><br><span class="hljs-comment">      obj?.method() —— 如果 obj 存在则调用 obj.method()，否则返回 undefined。</span><br><span class="hljs-comment">      ?. 检查左边部分是否为 null/undefined，如果不是则继续运算。?. 链使我们能够安全地访问嵌套属性。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&gt; 但是，我们应该谨慎地使用 ?.，仅在当左边部分不存在也没问题的情况下使用为宜。以保证在代码中有编程上的 error 出现时，也不会对我们隐藏</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment"># Symbol 类型</span><br>- “<span class="hljs-built_in">Symbol</span>” 值表示**唯一的标识符**,即使我们创建了许多具有相同描述的 <span class="hljs-built_in">Symbol</span>，它们的值也是不同。<br><br>- &gt; let id = <span class="hljs-built_in">Symbol</span>();  <br>  &gt;<br>  &gt; 添加描述 let id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>- &gt; <span class="hljs-built_in">Symbol</span> 不会被自动转换为字符串,为了防止字符串和<span class="hljs-built_in">Symbol</span>类型混淆<br>  &gt;<br>  &gt; 可以通过函数 toString()转换为字符串显示 <br>  &gt;<br>  &gt; 通过symbol.description 属性，只显示描述.<br><br>  <br><br>- <span class="hljs-built_in">Symbol</span> 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能**意外访问**或重写这些属性。<br><br>- &gt; <span class="hljs-string">&quot;隐藏&quot;</span> 指的是<span class="hljs-built_in">Symbol</span> 类型的属性,不会被`<span class="javascript"><span class="hljs-keyword">for</span>..in </span>`列举出来 `<span class="javascript"><span class="hljs-built_in">Object</span>.keys(user)</span>` 也会忽略它们。<br>  &gt;<br>  &gt; 使用enumberable属性标志也不会被枚举, 但是<span class="hljs-built_in">console</span>.log还是会显示<br>  &gt;<br>  &gt; `<span class="javascript"><span class="hljs-built_in">Object</span>.assign</span>`会同时复制字符串和 symbol 属性, 但不会复制enumberable : <span class="hljs-literal">false</span>的属性<br>&gt; 如果我们使用的是属于第三方代码的 user 对象，我们想要给它们添加一些属性。<br>&gt;<br>&gt; 如果使用 字符串添加, 很容易引起冲突, 但是使用<span class="hljs-built_in">Symbol</span> 创建,就算描述一样,返回的也是不同的值,不会引起冲突<br><br>- 创建<span class="hljs-built_in">Symbol</span>返回值名字 和 属性名一样, 也不会有问题, 但是调用<span class="hljs-built_in">Symbol</span>属性必须加上[], 如果有点符号调用则是普通的属性名<br><br>&gt; ```<span class="javascript">javascript</span><br><span class="javascript">&gt; <span class="hljs-keyword">let</span> vip =&#123;</span><br><span class="javascript">&gt;  id:<span class="hljs-number">3</span>,</span><br><span class="javascript">&gt;  name:<span class="hljs-string">&quot;vip&quot;</span>,</span><br><span class="javascript">&gt; &#125;</span><br><span class="javascript">&gt; <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);</span><br><span class="javascript">&gt; vip[id] = <span class="hljs-string">&quot;er&quot;</span>;</span><br><span class="javascript">&gt; </span><br><span class="javascript">&gt; <span class="hljs-built_in">console</span>.log(vip[id]) <span class="hljs-comment">//   er   用点符号进行调用显示3</span></span><br></code></pre></td></tr></table></figure>&gt;&gt; </code></pre></li></ul><ul><li><p>全局 symbol使用  : </p></li><li><blockquote><p>有时我们想要名字相同的 Symbol 具有相同的实体。</p><p>例如，应用程序的不同部分想要访问的 Symbol “id” 指的是完全相同的属性。 注册表内的 Symbol 被称为 全局 Symbol。</p><p>Symbol.for(key)。  key:描述   通过描述返回symbol  (在注册表中查找,不存在则创建) </p><p>Symbol.keyFor(sym) 通过全局 Symbol返回一个描述。 sym: 一个symbol</p></blockquote></li><li><blockquote><p>Symbol.keyFor 内部使用全局 Symbol 注册表来查找 Symbol 的键, 如果 Symbol 不是全局的，它将无法找到它并返回 undefined。</p></blockquote></li></ul><blockquote><p>symbol(“”)  和 Symbol.for(key)  使用相同的描述 创建的symbol 依然不相等</p><p>局部的Symbol  和全局的Symbol仍然不相等</p></blockquote><ul><li>JavaScript 使用了许多系统 Symbol. 可以用来改变一些内置行为</li></ul><blockquote><p>Symbol 主要运用 : </p><p>1.“隐藏” 对象属性 : 向对象添加 属性</p><p>2.系统Symbol :改变内置行为</p></blockquote><h4 id="对象-原始值转换"><a href="#对象-原始值转换" class="headerlink" title="对象 原始值转换"></a>对象 原始值转换</h4><ul><li><p><strong>所有的对象在布尔上下文（context）中均为 true</strong>。所以对于对象，不存在 to-boolean 转换，只有字符串和数值转换。</p></li><li><p>数值转换发生在对象相减或应用数学函数时。至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。</p></li><li><blockquote><p>三个类型转换的变体，被称为 “hint” :  “String” “number” “default”</p><p>根据对象的使用情况向这三种类型转换</p></blockquote></li><li><p>对象 在上下文 需要转换时,会根据转换类型尝试调用内置函数进行转换</p></li><li><blockquote><ol><li><p>调用 <code>obj[Symbol.toPrimitive](hint)</code> 内置函数 (如果存在的话) ,我们可以进行自定义该属性</p><blockquote><p>[Symbol.toPrimitive] = function(hint){…..}</p></blockquote></li><li><p>根据 hint 类型 , 调用 tostring / valueOf() …</p></li></ol></blockquote></li></ul><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><ul><li><p>人们想操作原始数据类型 string number…,像操作方法一样,这时候需要对象支持,但是对象有需要额外的资源支持,因为需要原始数据尽量小,所以提出解决方法:</p></li><li><p>创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</p></li><li><blockquote><p>特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外。</p><p>它们没有对应的“对象包装器”，也没有提供任何方法。</p></blockquote></li></ul><ul><li><p>“对象包装器”的类型:  String、Number、Boolean 和 Symbol。它们提供了不同的方法。</p></li><li><blockquote><pre><code class="javascript">let str = &quot;Hello&quot;;alert( str.toUpperCase() ); // HELLO<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br> &gt;访问其属性时，会创建一个包含字符串字面值的特殊对象, 进行调用函数, 调用结束后销毁对象,留下字符串原始值<br> <br> <br><br>- <span class="hljs-keyword">new</span> <span class="hljs-constructor">Boolean(<span class="hljs-params">false</span>)</span> 等语法，明确地为原始类型创建“对象包装器”。但是极其不推荐,因为他返回一个对象,而不是返回转换过的值, 对象在判断语句中一直 <span class="hljs-literal">true</span><br><br>另一方面，调用不带 <span class="hljs-keyword">new</span>（关键字）的 String/Number/Boolean 函数是完全理智和有用的,这进行显式转换数据类型  <span class="hljs-keyword">let</span> num = <span class="hljs-constructor">Number(<span class="hljs-string">&quot;123&quot;</span>)</span>; <span class="hljs-comment">// 将字符串转成数字</span><br><br>#### 数字类型<br><br>- 在 JavaScript 中，我们通过在数字后附加字母 “e”，并指定零的数量来缩短数字：<br><br><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">// 10的9次方  </span><br><br>- <span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">base</span>)</span> 方法  base: 给定base 进制 返回一个字符串形式的base进制数,默认值为<span class="hljs-number">10</span><br><br>数字也可以直接调用该方法 ,使用两个点   <span class="hljs-number">1234.</span>.tostring(base)<br><br>- Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。值 “NaN” 是独一无二的，它不等于任何东西，包括它自身：不能使用===<br><br>它们属于 number 类型，但不是“普通”数字，是两种状态,所以使用特殊的函数检测:<br><br>- is<span class="hljs-constructor">NaN(<span class="hljs-params">value</span>)</span> 将其参数转换为数字，然后测试它是否为 NaN：<br><br>- is<span class="hljs-constructor">Finite(<span class="hljs-params">value</span>)</span> 将其参数转换为数字，如果是常规数字，则返回 <span class="hljs-literal">true</span><br><br> <br><br>- **舍入（rounding）计算精度缺失:** <br><br>- 取整:<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor  向下(小)舍入   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil 向上(大)舍入   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round 向最近的整数舍入  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入<br><br>- 舍入到小数点后几位:<br><br><span class="hljs-keyword">to</span><span class="hljs-constructor">Fixed(<span class="hljs-params">n</span>)</span> 将数字舍入到小数点后 n 位，**返回字符串**。<br><br>如果小数部分比所需要的短，则在结尾添加零：<br><br>舍入时根据数字判断向上 向下进行舍入<br><br></code></pre></td></tr></table></figure>let num = 12.34;alert( num.toFixed(5) ); // &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后5位<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>计算精度缺失 :<br><br><span class="hljs-bullet">- </span>alert( 0.1 + 0.2 == 0.3 ); // false      计算精度缺失<br><br><span class="hljs-bullet">- </span>原因 : 一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。<br><br>最可靠的方法是 使用 toFixed(n) 对结果进行舍入,再使用一元加号将其强制转换为一个数字  <br><br>let sum = 0.1 <span class="hljs-code">+ 0.2; alert( +</span>sum.toFixed(2) ); // 0.30       <br><br><span class="hljs-bullet">- </span>alert( 6.35.toFixed(1) ); // 6.3 而不是6.4    舍入精度缺失<br><br><span class="hljs-bullet">- </span>原因: 在内部，6.35 的小数部分是一个无限的二进制<br><span class="hljs-code"> </span><br>如果我们希望以正确的方式进行舍入，在进行舍入前，我们应该使其更接近整数<br><br><span class="hljs-code"> &gt;alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000  63.5 完全没有精度损失。这是因为小数部分 0.5 实际上是 1/2。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，</span><br><span class="hljs-code"> </span><br><span class="hljs-bullet">- </span>在处理小数时避免相等性检查 精度缺失导致小数计算时发生意外<br><br><span class="hljs-code"> </span><br><br><span class="hljs-bullet">- </span>*<span class="hljs-strong">*praseInt/praseFloat*</span><span class="hljs-strong">*:</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 使用加号 + 或 Number() 的数字转换是严格的。如果一个值不完全是一个数字，就会失败</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- &gt;alert( +&quot;100px&quot; ); // NaN</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 而 parseInt 和 parseFloat 的作用 :它们可以*</span><span class="hljs-strong">*从字符串中“读取”数字*</span><span class="hljs-strong">*，直到无法读取为止,如果发生 error，则返回收集到的数字。</span><br><span class="hljs-strong"> </span><br><span class="hljs-strong">函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数：</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- parseInt/parseFloat 当没有数字可读时会返回  NaN。</span><br><span class="hljs-strong"> </span><br><span class="hljs-strong">例如 :  alert( parseInt(&#x27;a123&#x27;) ); // NaN，第一个符号停止了读取</span><br><span class="hljs-strong"></span><br><span class="hljs-strong"> </span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- parseInt(str, radix) 的第二个参数 它指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- &gt; 如果 parseInt() 的参数是数字的话,它的效果类似Math.trunc() ,移除小数点之后的数只取整数 ,因为小数点也算读取失败</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 其他函数</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">*</span><span class="hljs-strong">*Math.random()*</span>*    *<span class="hljs-strong">*Math.max/min(a, b, c...)*</span>*  *<span class="hljs-strong">*Math.pow(n, power)*</span>*  三角函数..<br><br><br>#### 字符串<br><br><span class="hljs-bullet">- </span>反引号它们允许字符串跨行(单/双引号不行),在输入时也会是换行效果,反引号允许我们通过 <span class="hljs-code">`$&#123;…&#125;`</span> 将任何表达式嵌入,可以是个函数<br><br><span class="hljs-bullet">- </span>特殊字符 (转义):   使用<span class="hljs-code">`\`</span>  输出<br><br><br><span class="hljs-bullet">- </span>*<span class="hljs-strong">*字符串基本操作*</span><span class="hljs-strong">*:</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 访问字符 :使用方括号[ pos] 或者调用 `str.charAt(pos)` 方法。pos从零开始 </span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- &gt;它们之间的唯一区别是，如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 获得字符串长度 `.length`, </span><br><span class="hljs-strong"></span><br><span class="hljs-strong">特殊字符,如\n 则算一个单独的字符    alert( &#x27;My\n&#x27;.length ); // 3</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 使用` for..of `遍历字符串和`for..in`区别:</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">for in得到的是索引,根据索引得到内容,  for of 直接得到内容</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- 在 JavaScript中，*</span><span class="hljs-strong">*字符串不可更改*</span><span class="hljs-strong">*,通常解决创建一个新字符串.</span><br><span class="hljs-strong"></span><br><span class="hljs-strong"> ```javascript</span><br><span class="hljs-strong"> let a=&quot;jsonp&quot;;</span><br><span class="hljs-strong"> a[2] = &quot;h&quot;;</span><br><span class="hljs-strong"> console.log(a); // jsonp</span><br><span class="hljs-strong"> // 就算改变字符, 也不会发送变化</span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p><strong>字符串方法:</strong></p></li><li><p>改变大小写</p><blockquote><p><code>toLowerCase()</code> 和<code> toUpperCase()</code></p></blockquote></li><li><p>查找字符串:</p><blockquote><p><code>str.indexOf(substr, [pos])</code>  它从给定位置pos开始,没有找到返回 -1，否则返回匹配成功的位置。<br><code>str.lastIndexOf(substr, [position])</code>，从给定位置开始, 从字符串的末尾开始搜索到开头。<br><code>str.includes(substr, [pos]) </code>  返回 true/false。</p><p><code>str.startsWith</code> 和 <code>str.endsWith</code> 的功能与其名称所表示的意思相同</p></blockquote></li><li><p>获取子字符串:</p><blockquote><p><code>str.slice(start [, end] </code>  返回字符串从 start（不包括end）end 的部分。如果没有第二个参数，slice 会一直运行到字符串末尾, start/end 是负值。起始位置从字符串结尾计算<br><code>str.substring(start [, end])</code> 返回字符串在 start 和 end 之间 的部分。这与 slice几乎相同，但它允许 start大于end<br><code>str.substr(start [, length])</code>   返回字符串从 start 开始的给定 length 的部分.</p></blockquote><blockquote><p>推荐使用 slice  更灵活 </p></blockquote></li></ul><ul><li><p>所有的字符串都使用 UTF-16编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码</p></li><li><blockquote><p><code>String.fromCodePoint</code> 和 <code>str.codePointAt</code> 是几种处理代理对的少数方法, 处理特殊符号</p><p>alert( “z”.codePointAt(0) ); // 122</p><p>alert( String.fromCodePoint(90) ); // Z</p></blockquote></li></ul><h4 id="数组-数组方法"><a href="#数组-数组方法" class="headerlink" title="数组 + 数组方法"></a>数组 + 数组方法</h4><ul><li><h5 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明 :"></a>数组声明 :</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [ ]<br><span class="hljs-keyword">let</span> arr =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() 默认是没有任何项的数组, 但是接受单个参数<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>数组可以存储任何类型的元素,以逗号结尾.</p><p>length属性的值是数组中元素的总个数, </p></blockquote><ul><li><h5 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用 :"></a>数组使用 :</h5></li><li><p>队列(queue)是最常见的使用数组的方法之一。</p><blockquote><p>push  :末端添加</p><p> shift : 取出首端  </p></blockquote></li><li><p>数组作为栈使用:</p><blockquote><p>push 末端添加</p><p>pop 末端取出</p></blockquote></li><li><p>数组可以同时当做队列 栈使用, 允许在首段末段/添加删除元素, 我们叫这样的数据结构成为双端队列, 对头进行工作时,元素会整体向前移动,意味着更多的 内存操作</p></li><li><blockquote><p>unshift : 首端添加元素</p><p><code>push</code> 和 <code>unshift</code> 方法都可以一次添加多个元素：</p><p><code>shift</code> 和<code>pop</code>方法,都没有参数</p></blockquote></li><li><h5 id="数组内部"><a href="#数组内部" class="headerlink" title="数组内部:"></a>数组内部:</h5></li><li><p><strong>数组是一种特殊的对象</strong>。使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法. 它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象.</p></li><li><blockquote><p>数组的行为很像一个对象,  比如可以直接使用  “=” , 进行引用复制,两个变量引用同一个数组</p></blockquote><blockquote><p>我们可以像常规对象一样使用数组, 添加属性等等, 但是js针对数组有优化,如果像常规对象使用, 这种优化就不再使用</p></blockquote></li><li><h5 id="数组-length-toString"><a href="#数组-length-toString" class="headerlink" title="数组 length   toString"></a>数组 length   toString</h5></li><li><blockquote><p>当我们修改数组的时候，length属性会自动更新.</p><p>length可写,如果我们减少它，数组就会被截断.清空数组 :  arr.length = 0;</p><p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p></blockquote></li><li><h5 id="不要使用-比较数组"><a href="#不要使用-比较数组" class="headerlink" title="不要使用 == 比较数组"></a>不要使用 == 比较数组</h5></li><li><blockquote><p>该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组</p><p>仅当两个对象引用的是同一个对象时 才会相同</p><p>如果我们使用 <code>==</code> 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</p></blockquote></li><li><blockquote><p>应该使用迭代 逐项比较 , === 也不能比较数组</p></blockquote></li><li><h5 id="数组循环-for-in-for-of-for"><a href="#数组循环-for-in-for-of-for" class="headerlink" title="数组循环 : for..in  for..of  for()"></a>数组循环 : for..in  for..of  for()</h5></li><li><blockquote><p>建议使用for ..of  ,   for()</p><p>for..in 有很多潜在问题 : 会遍历所有属性(对于类数组不好,类数组存在索引属性…) ,</p><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。</p><p>for..in .. 返回索引</p></blockquote></li><li><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5></li><li><blockquote><pre><code class="javascript">let matrix = [[1, 2, 3],[4, 5, 6],[7, 8, 9]];<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"> <br>- ##### 数组方法<br><br>- ##### 从数组中添加,删除,插入元素:<br><br>- &gt;  `arr.splice(<span class="hljs-keyword">index</span>[, deleteCount, elem1, ..., elemN])<span class="hljs-symbol">`   </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> 既可以单独删除 也可以删除插入,  从索引index开始操作 , 返回被删除的元素,没有返回空数组[]</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> 在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> 使用delete arr[1];  可以删除数组中的值,但不会自动释放占据的空间 </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- ##### 数组部分拷贝: </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- `</span>arr.slice([ <span class="hljs-keyword">start</span>], [ <span class="hljs-keyword">end</span>])<span class="hljs-symbol">` 返回一个新数组，新数组的索引是 start 到 end（不包括 end）   </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- `</span>arr.concat(arg1, arg2...)<span class="hljs-symbol">` 返回一个连接过的新数组，其中包含来自于其他数组和其他项的值。arg 可以是数组/元素</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- &gt;concat() 方法返回的数组结果, 不会进行排序</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> &gt;如果类数组具有 `</span>Symbol.isConcatSpreadable<span class="hljs-symbol">` =true 属性，那么它就会被 `</span>concat<span class="hljs-symbol">` 当作一个数组来处理</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- slice  concat 方法的拷贝注意事项: </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">数组里存储 对象 时 , `</span>concat<span class="hljs-symbol">`将对象引用复制到新数组中, 原始数组和新数组都引用相同的对象</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">对象不使用复制方法,操作的都是引用类型,都是对象自身</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">当用来`</span>拷贝二维数组<span class="hljs-symbol">`时注意,不要直接进行拷贝,因为多维数组里的数组,被当成了对象引用</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- ##### 数组遍历</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- arr.forEach 方法允许为数组的每个元素都运行一个函数。不会改变数组的值,也没有返回值</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">`</span><span class="hljs-symbol">``</span>javascript<br>arr.forEach(callback(currentValue [, <span class="hljs-keyword">index</span> [, <span class="hljs-keyword">array</span>]])[, thisArg])<br>&#123;<br>//  <span class="hljs-keyword">index</span> : 正在处理元素的索引, <span class="hljs-keyword">array</span> 正在处理的数组<br>&#125;<br>//该函数如果返回结果会被抛弃和忽略。<br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><ul><li><h5 id="数组搜索"><a href="#数组搜索" class="headerlink" title="数组搜索"></a>数组搜索</h5><blockquote><p>arr.indexOf、arr.lastIndexOf 和 arr.includes 方法 检查内容返回索引 ,没有返回-1</p><p>与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同</p></blockquote></li><li><p><code>arr.find(function(item, index, array) </code>方法, 找到特定条件的对象: find 方法搜索的是使函数返回 true 的第一个（单个）元素。没有返回 undefined</p></li><li><p><code>arr.findIndex </code>方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。</p></li><li><p><code>arr.filter(fn) </code>方法   : 返回匹配元素组成的数组</p></li><li><pre><code class="javascript"> arr.filter(function(item, index, array)&#123;&#125;   //如果 true item 被 push 到 results，迭代继续   // 如果什么都没找到，则返回空数组 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- ##### 数组转换(分割 联结 倒置) 排序<br><br>&gt;  `arr.map(fn)`* 方法,它对每个元素都调用函数，回调函数的返回值（包括 undefined）组合起来形成一个新数组, 并返回这个新数组。如果函数没有返回值,则新数组默认都是undefined<br>&gt;<br>&gt;  ```javascript<br>&gt;  let result = arr.map(function(item, index, array)<br>&gt;   &#123;<br>&gt;      // 返回新值而不是当前元素, arr也不会被改变<br>&gt;  &#125;<br></code></pre></td></tr></table></figure>&gt;  &gt;`arr.sort(fn)` 方法对数组进行排序，更改元素的顺序,不会生成一个新数组.它还返回排序后的数组&gt;  排序方法默认按照**字符串**进行排序。需要使用`自定义排序顺序`,提供一个fn函数作为参数&gt;  &gt;`arr.reverse( )`方法  返回arr颠倒过的数组</code></pre></li></ul><ul><li><p><strong>字符串转换为数组:</strong> </p><blockquote><p><code>str.split(delim)</code> 方法。它通过给定的分隔符 delim 将<strong>字符串</strong>分割成一个数组。</p><p>有一个可选的第二个数字参数 —— 对数组长度的限制</p><p>调用带有空格的 <code>split(&#39; &#39;)</code>，方法, 会将字符串拆分为字母数组</p></blockquote></li><li><p>数组转化为字符串:</p></li><li><blockquote><p><code>arr.join(glue) </code>与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。</p></blockquote></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 方法</p></li><li><blockquote><p>遍历数组, 然后计算单个值,并把结果传递给下一次计算</p><p>arr.reduce(function(accumulator, item, index, array) {  // … }, [initial]);</p><p><code>accumulator</code> —— 是上一个函数调用的结果, 本质上是一个累加器</p></blockquote></li></ul><ul><li><p><strong>判断是否为数组</strong> : 数组是基于对象的，不构成单独的语言类型。所以 typeof 不能帮助从数组中区分出普通对象：</p></li><li><blockquote><p>Array.isArray(value)。如果 value 是一个数组，则返回 true；否则返回 false。</p></blockquote></li><li><p>thisArg 参数解释:</p></li></ul><blockquote><p>几乎所有需要回调函数的数组方法(除了sort),都接受一个可选的附加参数 thisArg, </p><p><code>thisArg</code> 参数的值在 <code>func</code> 中变为 <code>this</code>。</p><p> 用处: 当我们传递army.canJoin 对象方法,往往会丢失this,这个参数绑定了this</p><p>可以用users.filter(user =&gt; army.canJoin(user)) 替换对 users.filter(army.canJoin, army)的调用。前者的使用频率更高</p></blockquote><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><ul><li><p>任何对象都可以被定制为可迭代的,换句话说,都可以被定制为在<code>for..of</code>循环中使用</p><blockquote><p>内置的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。</p><p>对于对象来说for..in..都是可以调用的,但是只有可迭代对象可以使用for..of</p></blockquote></li><li><p>通过设置<strong>obj[ Symbol.iterator]</strong> 属性, 来进行定制对象可迭代的迭代过程</p></li><li><blockquote><p>在对象外/内设置属性,  <code>obj[Symbol.iterator] =func()</code>  函数内返回一个含有 next() 函数的迭代器对象</p><p><code>next()</code> 方法返回的结果的格式必须是 <code>&#123;done: Boolean, value: any&#125;</code>,</p><p>当 done=true时，表示迭代结束，否则 value是下一个值。</p></blockquote></li><li><p>在对象内/外设置设置属性的区别:</p><blockquote><p>在对象内设置属性, 同时在对象上运行两个 <code>for..of</code> 循环了：它们将共享迭代状态，因为只有一个迭代器</p><p>但是两个并行的 <code>for..of</code> 是很罕见的</p></blockquote></li><li><p>我们还可以显式调用迭代器, 对象名[Symbol.iterator] ()会返回一个迭代器对象</p></li></ul><ul><li><h5 id="可迭代（iterable）和类数组（array-like）"><a href="#可迭代（iterable）和类数组（array-like）" class="headerlink" title="可迭代（iterable）和类数组（array-like）"></a>可迭代（iterable）和类数组（array-like）</h5></li><li><blockquote><ul><li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li><li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组</li></ul><blockquote><p>一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代,两者没有关系</p></blockquote></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">类数组 : 有索引和 length 属性<br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;World&quot;</span>,<br>  length: <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>转化可迭代对象, 转化类数组为数组:</strong></p></li><li><blockquote><p>全局方法 <code>Array.from()</code>可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组</p><p>Array.from(obj[, mapFn, thisArg])可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素</p></blockquote></li></ul><h4 id="Map-Set-映射和集合"><a href="#Map-Set-映射和集合" class="headerlink" title="Map Set (映射和集合)"></a>Map Set (映射和集合)</h4><ul><li><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map <strong>允许任何类型</strong>的键（key）</p></li><li><blockquote><p>Objct 的键只允许 是字符串 或者 Symbol 类型, 如果是其他的也会转化为字符串类型</p></blockquote></li><li><p><strong>定义 使用map</strong> : </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(key, value);  —— 根据键存储值<br>map.get(key) ;       —— 根据键来返回值如果 map 中不存在对应的 key，则返回 <span class="hljs-literal">undefined</span>。<br>map.has(key) —— 如果 key 存在则返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。<br>map.delete(key) —— 删除指定键的值。<br>map.clear() —— 清空 map。<br>map.size —— 返回当前元素个数。<br></code></pre></td></tr></table></figure></li><li><blockquote><p>map[ key] 不是使用 Map 的正确方式 , 因为map的键值可以存储任何类型,包括对象, </p><p>所以当用[ object] 调用时会发生错误, 不存在对象键.</p><p>每一次 map.set 调用都会返回 map 本身，所以我们可以进行<strong>“链式”调用</strong></p></blockquote></li></ul><ul><li><p><strong>Map 迭代</strong> :(使用for..of 结合以下函数进行遍历)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.keys() —— 返回含有所有的键 的 map iterable  <br>map.values() —— 返回含有所有的值 的 map iterable  <br>map.entries() —— 遍历并返回所有的实体 [key, value], <span class="hljs-keyword">for</span>..of 在默认情况下使用的就是这个。<br><br>map.forEach( (value, key, map)&#123;&#125;  <span class="hljs-comment">//与 Array 类似</span><br></code></pre></td></tr></table></figure></li><li><blockquote><p>迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。</p></blockquote></li></ul><ul><li><p><strong>通过可迭代对象 数组创建map</strong></p></li><li><pre><code class="javascript">传入一个带有键值对的数组初始化let map = new Map([ [&#39;1&#39;,  &#39;str1&#39;], [1,    &#39;num1&#39;], [true, &#39;bool1&#39;] ]); <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>- &gt; 使用内建方法 <span class="hljs-built_in">Object</span>.entries(obj)，将对象转换为键/值对数组，该数组格式完全按照 <span class="hljs-built_in">Map</span> 所需的格式。<br>  &gt;<br>  &gt; *let map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));*<br><br>- **从<span class="hljs-built_in">Map</span> 创建对象**:<br><br>- `<span class="hljs-built_in">Object</span>.fromEntries()` ：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象<br><br>- &gt; 从 <span class="hljs-built_in">Map</span> 创建对象 : let obj = <span class="hljs-built_in">Object</span>.fromEntries(map.entries()); <span class="hljs-comment">// 创建一个普通对象;</span><br>  &gt;<br>  &gt; 简化为:  let obj = <span class="hljs-built_in">Object</span>.fromEntries(map);   <br>  &gt;<br>  &gt; 原因 :  <span class="hljs-built_in">Object</span>.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组<br><br>  ##### <span class="hljs-keyword">set</span><br><br><br>- <span class="hljs-keyword">set</span> : <span class="hljs-built_in">Set</span> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。<br><br>- **<span class="hljs-keyword">set</span>方法** : <br><br>  - `<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(iterable)` —— 创建一个 `<span class="hljs-keyword">set</span>`，如果提供了一个 `iterable` 对象（通常是数组），将会从数组里面复制值到 `<span class="hljs-keyword">set</span>` 中。<br>  - `<span class="hljs-keyword">set</span>.add(value)` —— 添加一个值，返回 <span class="hljs-keyword">set</span> 本身<br>  - `<span class="hljs-keyword">set</span>.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `<span class="hljs-keyword">true</span>` ，否则返回 `<span class="hljs-keyword">false</span>`。<br>  - `<span class="hljs-keyword">set</span>.has(value)` —— 如果 `value` 在 <span class="hljs-keyword">set</span> 中，返回 `<span class="hljs-keyword">true</span>`，否则返回 `<span class="hljs-keyword">false</span>`。<br>  - `<span class="hljs-keyword">set</span>.clear()` —— 清空 <span class="hljs-keyword">set</span>。<br>  - `<span class="hljs-keyword">set</span>.size` —— 返回元素个数。<br>  <br>  <br><br><br>- &gt; 重复使用同一个值调用 <span class="hljs-keyword">set</span>.add(value) 并不会发生什么改变,<span class="hljs-keyword">set</span>中每个值还是一个<br><br><br>```javascript<br>我们可以使用 <span class="hljs-keyword">for</span>..of 或 forEach 来遍历 <span class="hljs-built_in">Set</span>：<br><span class="hljs-keyword">set</span>.forEach((value, valueAgain, <span class="hljs-keyword">set</span>) =&gt; &#123;<br>  alert(value);<br>&#125;);<br><br><span class="hljs-keyword">set</span>.keys(); 遍历并返回所有的值<br><span class="hljs-keyword">set</span>.values(); 与 <span class="hljs-keyword">set</span>.keys() 作用相同，这是为了兼容 <span class="hljs-built_in">Map</span><br><span class="hljs-keyword">set</span>.entries();  遍历并返回所有的实体[value, value]，它的存在也是为了兼容 <span class="hljs-built_in">Map</span>。<br></code></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p>forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。  是为了与 Map 兼容。</p></blockquote><h4 id="WeakMap-and-WeakSet"><a href="#WeakMap-and-WeakSet" class="headerlink" title="WeakMap and WeakSet"></a>WeakMap and WeakSet</h4><ul><li><p>如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。类似的，如果我们使用对象作为常规 Map 的键，那么当 Map 存在时，该对象也将存在.</p></li><li><p>WeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。</p></li><li><p>WeakMap 和 Map 的第一个不同点就是<strong>，WeakMap 的键必须是对象</strong>，不能是原始值</p></li><li><p>WeakMap <strong>不支持迭代</strong> 以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。</p></li><li><blockquote><ul><li><code>weakMap.get(key)</code></li><li><code>weakMap.set(key, value)</code></li><li><code>weakMap.delete(key)</code></li><li><code>weakMap.has(key)</code></li></ul><p><code>WeakMap</code> 只有以上的方法  支持size() ???</p></blockquote></li><li><blockquote><p>当需要对象 和它附加的数据共存亡时,可以用到weakmap</p></blockquote></li><li><p>WeakSet <strong>只能存储对象</strong>,<strong>不支持迭代</strong> 无法使用size 和迭代用函数 keys()</p></li><li><blockquote><p><code>WeakSet</code> 支持 <code>add</code>，<code>has</code> 和 <code>delete</code> 方法</p></blockquote></li></ul><ul><li><blockquote><p>WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。</p><p><code>WeakMap</code> 和 <code>WeakSet</code> 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 <code>WeakMap</code> 或 <code>WeakSet</code> 的键，那么它将被自动清除。</p></blockquote></li></ul><h4 id="Object-keys，values，entries"><a href="#Object-keys，values，entries" class="headerlink" title="Object.keys，values，entries"></a>Object.keys，values，entries</h4><ul><li> 这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。</li></ul><blockquote><p> 它们支持： Map  Set Array  </p><p> 普通对象也支持类似的方法，但是语法上有一些不同  :map.keys()    ==&gt;    Object.keys(obj)， </p><p> 为了自己创建的对象方法不会被覆盖,使用Object.keys(obj)更灵活</p></blockquote><ul><li><p>对于普通对象，下列这些方法是可用的 :</p></li><li><blockquote><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> —— 返回一个包含该对象所有的键的数组。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> —— 返回一个包含该对象所有的值的数组。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> —— 返回一个包含该对象所有 [key, value] 键值对的数组。</li></ul><p><strong>Object.keys/values/entries 会忽略 symbol 属性</strong>, 如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>，它会返回一个只包含 Symbol 类型的键的数组</p></blockquote></li><li><p>转换对象,调用数组方法 :</p></li><li><blockquote><p>对象缺少数组存在的许多方法,我们可以转换对象来调用</p><p>1.使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。<br>2.对该数组使用数组方法</p><p>3.对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。</p></blockquote></li></ul><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><blockquote><p>基本语法 : </p><ol><li>let {prop : varName = default, …rest} = object</li><li>let [item1 = default, item2, …rest] = array</li></ol></blockquote><ul><li><p>对象让我们能够创建通过键来存储数据项的单个实体，数组则让我们能够将数据收集到一个有序的集合中。<br>但是，当我们把它们传递给函数时，它可能不需要一个整体的对象/数组，而是需要单个块。</p></li><li><p>解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便</p></li><li><p>“解构”并不意味着“破坏” 因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 数组解构<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Ilya&quot;</span>, <span class="hljs-string">&quot;Kantor&quot;</span>]<br><span class="hljs-keyword">let</span> [firstName, surname] = arr;   =&gt; 相当于 <span class="hljs-keyword">let</span> firstName = arr[<span class="hljs-number">0</span>]; <span class="hljs-keyword">let</span> surname = arr[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">let</span> [firstName, , title] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>];<span class="hljs-comment">///数组中不想要的元素也可以通过添加额外的逗号来把它丢弃</span><br>alert( title ); <span class="hljs-comment">// Consul</span><br><br><span class="hljs-number">2.</span> 可迭代对象解构      <span class="hljs-comment">//等号右侧可以是任何可迭代对象,而不仅限于数组,  等号左侧使用任何“可以被赋值的”东西</span><br><br><span class="hljs-keyword">let</span> [one, two, three] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">let</span> user = &#123;&#125;;<br>[user.name, user.surname] = <span class="hljs-string">&quot;Ilya Kantor&quot;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>);<br><br></code></pre></td></tr></table></figure><ul><li><blockquote><p>使用 .entries() 转换对象为键值对数组,可以进行遍历操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (let [key, value] of Object.entries(user)) &#123;<br><br> alert(`$&#123;key&#125;:$&#123;value&#125;`); <span class="hljs-comment">// name:John, then age:30</span><br><br> &#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>交换变量</p></li><li><blockquote><pre><code class="javascript">let guest = &quot;Jane&quot;; let admin = &quot;Pete&quot;;   // 交换值：让 guest=Pete, admin=Jane [guest, admin] = [admin, guest];<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><br>- 把后面的元素收集成数组,通过 <span class="hljs-string">&#x27;...&#x27;</span><br><br>- &gt; ```javascript<br>let [<span class="hljs-symbol">name1</span>, <span class="hljs-symbol">name2</span>, ...rest] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>]; <br>alert<span class="hljs-comment">(rest[0])</span>; <span class="hljs-comment">// Consul   rest 的值会被组成一个数组</span><br><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p>如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供,如果赋值语句中，变量的数量多于数组中实际元素的数量，赋值不会报错。未赋值的变量被认为是 undefined</p></li><li><blockquote><p>let [name = “Guest”, surname = “Anonymous”] = [ “Julius”];</p></blockquote></li></ul><ul><li><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5></li><li><pre><code class="javascript">let &#123;var1, var2&#125; = &#123;var1:&quot;er&quot;, var2: &quot;fef&quot;&#125;;let &#123;title, width, height&#125; = options; // options 对象名<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><br>- 变量的顺序并不重要,会根据两侧相同的名称赋值, <br><br>- &gt; 如果我们想把一个属性赋值给不同名字的变量:<br>  &gt;<br>  &gt;  <span class="hljs-built_in">let</span> &#123;<span class="hljs-built_in">width</span>: w, <span class="hljs-built_in">height</span>: h, <span class="hljs-built_in">title</span>&#125; = options;   // 把 options.<span class="hljs-built_in">width</span> 属性赋值给变量 w<br><br>- 对象解构 也可以提供默认值 , 可以把剩余元素通过&#x27;...&#x27; 收集成一个对象<br><br>- 不使用<span class="hljs-built_in">let</span> 进行 对象解构时 会出现错误, 原因:  因为&#123;&#125;会被解释成普通代码块 而不是解析语法<br><br>```javascript<br>// 这一行发生了错误<br>&#123;<span class="hljs-built_in">title</span>, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>&#125; = &#123;<span class="hljs-built_in">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">200</span>, <span class="hljs-built_in">height</span>: <span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>解决方法 : 要把整行用括号括住</p></blockquote></li><li><h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5></li><li><blockquote><p>如果一个对象或数组嵌套了其他的对象和数组,我们可以在等号左侧来提取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;<br>  size: &#123; <span class="hljs-comment">// 把 size 赋值到这里</span><br>    width,<br>    height<br>  &#125;,<br>  items: [item1, item2], <span class="hljs-comment">// 把 items 赋值到这里</span><br>  title = <span class="hljs-string">&quot;Menu&quot;</span> <span class="hljs-comment">// 在对象中不存在（使用默认值）</span><br>&#125; = options;<br><br>alert(title);  <span class="hljs-comment">// Menu</span><br>alert(width);  <span class="hljs-comment">// 100</span><br>alert(height); <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>智能函数参数: </p></li><li><blockquote><p>对于拥有很多参数的函数,在调用时我们会传递一个对象,而不是所有参数,</p><p>对象会进行解构,赋值给函数中的参数,  调用函数时,参数直接传一个对象即可</p></blockquote></li></ul><h4 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期 时间"></a>日期 时间</h4><ul><li>创建Date对象:</li></ul><blockquote><p>new Date() </p><p>new Date(datestring)   </p><p>new Date(year, month, date, hours, minutes, seconds, ms) </p></blockquote><ul><li>Date常用方法:</li></ul><blockquote><p>getFullYear()  获取年份（4 位数）</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth">getMonth()</a> 获取月份，<strong>从 0 到 11</strong>。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate">getDate() </a>获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours">getHours()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes">getMinutes()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds">getSeconds()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds">getMilliseconds()</a>获取相应的时间组件。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay">getDay()</a>获取一周中的第几天，从 <code>0</code>（星期日）到 <code>6</code>（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变</p></blockquote><ul><li><p><strong>以上的所有方法返回的组件都是基于当地时区的。</strong> 得到与当地时区的 UTC 对应项只需要在 <code>&quot;get&quot;</code> 之后插入 <code>&quot;UTC&quot;</code> 即可。</p></li><li><p>set..方法和get基本一致,不在赘述</p></li><li><p>自动校准 ,是 Date 对象的一个非常方便的特性,在设置超过范围的值,他会自动调整,比如闰年</p></li><li><p>日期转换为数字 ,当 Date 对象被转化为数字时，得到的是对应的时间戳(从1970到现在的毫秒数), 日期对象前面有+号完成转换</p></li><li><blockquote><p>日期可以相减，相减的结果是以毫秒为单位时间差。</p></blockquote></li><li><p>只想要得到时间间隔使用,  Date.now() 会返回当前的时间戳。两个相减得到时间间隔</p></li><li><p>Date.parse(str) 方法可以从一个字符串中读取日期。返回时间戳(毫秒数);</p></li><li><blockquote><p>let date = new Date( Date.parse(‘2012-01-26T13:51:50.417-07:00’) );</p></blockquote></li></ul><h4 id="JSON-之后在研究"><a href="#JSON-之后在研究" class="headerlink" title="JSON(之后在研究)"></a>JSON(之后在研究)</h4><ul><li><blockquote><p>JSON.stringify(obj) 将对象转换为 JSON。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify(value[, replacer, space])<br><br><span class="hljs-comment">/*replacer :如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化</span><br><span class="hljs-comment">space :指定缩进用的空白字符串，用于美化输出（pretty-print）*/</span><br></code></pre></td></tr></table></figure><p>JSON.parse 将 JSON 转换回对象。 返回一个js对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">JSON</span>.parse(str, [reviver]);<br><span class="hljs-comment">//reviver : 转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过,例如:</p><p>函数属性（方法）。 Symbol 类型的属性。存储 undefined 的属性。</p></li><li><p>JSON 支持嵌套对象转换, 但是不能有循环引用</p></li><li><p>像 <code>toString</code> 进行字符串转换，对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它。</p></li><li><blockquote><p>JSON 支持以下数据类型：</p><ul><li>Objects <code>&#123; ... &#125;</code></li><li>Arrays <code>[ ... ]</code></li><li>Primitives：<ul><li>strings，</li><li>numbers，</li><li>boolean values <code>true/false</code>，</li><li><code>null</code>。</li></ul></li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络请求</title>
    <link href="/2021/02/21/Md%20Js%20dom/js%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <url>/2021/02/21/Md%20Js%20dom/js%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><ul><li><p><strong>传统网页的网络请求:</strong></p></li><li><p>最初加载页面很简单 —- 你为网站发送一个请求到服务器， 只要没有出错你将会获取资源并显示网页到你的电脑上。</p></li><li><blockquote><p>这种方法导致不管 用户是否需要全部数据,都会重新加载整个页面</p><p>例如 : </p><p>填写表单时错误,跳转网页后重定向回注册表单,但是信息消失</p><p>只需要加载部分内容,(例如:导航栏侧边栏一样不在加载),但仍然会加载整个页面,导致资源浪费</p></blockquote></li></ul><ul><li>这时出现了AJAX技术, 允许网页请求小块数据,实现局部刷新而不是重新加载</li></ul><h2 id="AJAX-Asynchronous-JavaScript-and-XML-早期称呼"><a href="#AJAX-Asynchronous-JavaScript-and-XML-早期称呼" class="headerlink" title="AJAX (Asynchronous JavaScript and XML 早期称呼)"></a>AJAX (Asynchronous JavaScript and XML 早期称呼)</h2><ul><li><p>使用诸如 <strong>XMLHttpRequest</strong> 之类的API或者<strong>Fetch API</strong> 来实现,这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。</p></li><li><p><strong>AJAX原理:</strong></p></li><li><blockquote><p>通过xml /fetch api 作为中间件, 帮客户端发送数据,接收数据,使客户端可以做其他的事,数据接收之后再进行处理,不再堵塞等待数据</p></blockquote></li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><ul><li><p>在现代 Web 开发中，出于以下三种原因，我们还在使用 XMLHttpRequest：</p></li><li><blockquote><p>我们需要支持现有的使用了 XMLHttpRequest 的脚本。<br>我们需要兼容旧浏览器，并且不想用 polyfill（例如为了使脚本更小）。<br>我们需要做一些 fetch 目前无法做到的事情，例如跟踪上传进度。</p></blockquote></li></ul><h5 id="异步网络请求过程"><a href="#异步网络请求过程" class="headerlink" title="异步网络请求过程"></a>异步网络请求过程</h5><ul><li><ol><li><em>建立连接</em>:</li></ol></li><li><pre><code class="javascript">let xhr = new XMLHttpRequest();xhr.open(method, URL, [async, user, password])// open 调用与其名称相反，不会建立连接。它仅配置请求，而网络活动仅以 send 调用开启, xhr.send([body])// 可选参数 body 包含了 request body。像例如post传递才需要,get没有body<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">  <br>- &gt; method —— HTTP 方法。通常是 <span class="hljs-string">&quot;GET&quot;</span> 或 <span class="hljs-string">&quot;POST&quot;</span>。<br>  &gt;<br>  &gt; <span class="hljs-built_in">URL</span> —— 要请求的 <span class="hljs-built_in">URL</span>，通常是一个字符串，也可以是 <span class="hljs-built_in">URL</span> 对象。<br>  &gt; async —— 如果显式地设置为 <span class="hljs-literal">false</span>，那么请求将会以同步的方式处理，我们稍后会讲到它。<br>  &gt; user，password —— HTTP 基本身份验证（如果需要的话）的登录名和密码。  如果填写该功能 请求地址会加上该参数   `<span class="hljs-keyword">http</span>://user:pass@domain.com` 类似这种,但是有些浏览器可能不支持 ,<br>&gt;<br>  &gt; 这时我们需要在<span class="hljs-built_in">open</span> 方法之后 设置头setRequestHeader(<span class="hljs-string">&quot;Authorization&quot;</span>,..)<br><br>- &gt; 如果在 <span class="hljs-built_in">open</span> 方法中将第三个参数 async 设置为 <span class="hljs-literal">false</span>，那么请求就会以**同步的方式进行**。JavaScript 执行在 <span class="hljs-built_in">send</span>() 处暂停，并在收到响应后恢复执行。这有点儿像 alert 或 prompt 命令<br><br><br><br>- <span class="hljs-number">2.</span> *监听事件*<br><br>- 网络请求是异步的,所以我们需要监听`xhr`事件来获取响应:<br><br>- ```js<br>  xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>() &#123;&#125;</span><br>  xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">event</span>)&#123;&#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p> load —— 当请求完成（即使 HTTP 状态为 400 或 500 等），并且响应已完全下载。<br>  error —— 当无法发出请求，例如网络中断或者无效的 URL。<br>  progress —— 在下载响应期间定期触发，报告已经下载了多少。progerss 事件存在两个对象属性 event.loaded 已经下载了多少字节  event.total 总字节数</p></blockquote></li></ul><ul><li><ol start="3"><li><em>获得数据</em></li></ol></li></ul><ul><li><p>一旦服务器有了响应，我们可以在以下 <strong>xhr 属性中</strong>接收结果：</p></li><li><pre><code class="js"> xml.onload=function()&#123;   if(xml.status ==200)&#123;     console.log(xml.responseText);   &#125;<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> &gt;status  : HTTP 状态码（一个数字）：<span class="hljs-number">200</span>，<span class="hljs-number">404</span>，<span class="hljs-number">403</span> 等，如果出现非 HTTP 错误，则为 <span class="hljs-number">0</span>。</span><br><span class="ruby">  &gt;</span><br><span class="ruby">  &gt;statusText : HTTP 状态消息（一个字符串）：状态码为 <span class="hljs-number">200</span> 对应于 OK，<span class="hljs-number">404</span> 对应于 Not Found，<span class="hljs-number">403</span> 对应于 Forbidden。</span><br><span class="ruby">  &gt;</span><br><span class="ruby">  &gt;response（旧脚本可能用的是 responseText）  : 服务器的 response body。</span><br><span class="ruby">  </span><br><span class="ruby">  </span><br><br><span class="ruby">- **xhr 其他属性<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- <span class="hljs-string">`timeout属性`</span> 指定超时：xhr.timeout = <span class="hljs-number">10000</span>;  <span class="hljs-regexp">//</span> timeout 单位是 ms，此处即 <span class="hljs-number">10</span> 秒, 如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件。</span><br><br><span class="ruby">- <span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="ruby">  xhr.timeout = <span class="hljs-number">10000</span>;   <span class="hljs-regexp">//</span> 在建立连接时设置使用, 在监听事件时监听 timeout事件</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>**<code>xhr.responseType 属性</code>**来设置响应格式：</p></li><li><pre><code class="js">xhr.responseType = &#39;json&#39;;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- &gt;&quot;&quot;（默认）—— 响应格式为字符串，<br>  &gt;&quot;text&quot; —— 响应格式为字符串，<br>  &gt;&quot;arraybuffer&quot; —— 响应格式为 ArrayBuffer（对于二进制数据，请参见 ArrayBuffer，二进制数组），<br>  &gt;&quot;blob&quot; —— 响应格式为 Blob（对于二进制数据，请参见 Blob），<br>  &gt;&quot;document&quot; —— 响应格式为 <span class="hljs-type">XML</span> document（可以使用 XPath 和其他 <span class="hljs-type">XML</span> 方法），<br>  &gt;&quot;json&quot; —— 响应格式为 <span class="hljs-type">JSON</span>（自动解析）。<br>  &gt;<br>  &gt;<br>  &gt;<br>  &gt;使用response属性, 通过设置responseType 属性,会进行自动解析, 获取响应后可以直接使用<br>&gt;<br>  &gt;老的脚本使用 responseTEXT  responseXML 获取响应, 响应只以文本字符/<span class="hljs-type">xml</span>的形式返回 , 使用时要进行解析  <br><br>  <br><br>- **`XMLHttpRequest` 的state属性**<br><br>- XMLHttpRequest 的状态（state）会随着它的处理进度变化而变化。可以通过 **xhr.readyState** 来了解当前状态。<br><br>- &gt; UNSENT = <span class="hljs-number">0</span>; // 初始状态<br>  &gt; OPENED = <span class="hljs-number">1</span>; // <span class="hljs-keyword">open</span> 被调用<br>  &gt; HEADERS_RECEIVED = <span class="hljs-number">2</span>; // 接收到 response <span class="hljs-keyword">header</span><br>  &gt; LOADING = <span class="hljs-number">3</span>; // 响应正在被加载（接收到一个数据包）<br>  &gt; DONE = <span class="hljs-number">4</span>; // 请求完成<br>  &gt;<br>  &gt; XMLHttpRequest 对象以 <span class="hljs-number">0</span> → <span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → … → <span class="hljs-number">3</span> → <span class="hljs-number">4</span> 的顺序在它们之间转变。每当通过网络接收到一个数据包，就会重复一次状态 <span class="hljs-number">3</span>。我们可以使用 readystatechange 事件来跟踪它们：<br>- &gt; readystatechange 事件 存在于很老的代码中, 现在被<span class="hljs-keyword">load</span>/error/progress事件替代<br><br><br><br><br>- 调用 `xhr.<span class="hljs-keyword">abort</span>()` ,  我们可以随时**终止请求**。<br><br><br><br>- XMLHttpRequest 允许发送自定义 <span class="hljs-keyword">header</span>，并且可以从响应中读取 <span class="hljs-keyword">header</span>。<br><br>  ```javascript<br>  setRequestHeader(<span class="hljs-type">name</span>, <span class="hljs-keyword">value</span>), //使用给定的 <span class="hljs-type">name</span> 和 <span class="hljs-keyword">value</span> 设置 request <span class="hljs-keyword">header</span>。<br>  xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>  <br>  getResponseHeader(<span class="hljs-type">name</span>) : 获取具有给定 <span class="hljs-type">name</span> 的 <span class="hljs-keyword">header</span>（<span class="hljs-keyword">Set</span>-Cookie 和 <span class="hljs-keyword">Set</span>-Cookie2 除外）。<br>  getAllResponseHeaders()  返回除 <span class="hljs-keyword">Set</span>-Cookie 和 <span class="hljs-keyword">Set</span>-Cookie2 外的所有 response <span class="hljs-keyword">header</span>。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>一些 header 是由浏览器专门管理的，例如 Referer 和 Host 为了用户安全和请求的正确性，XMLHttpRequest 不允许更改它们。</p><p>XMLHttpRequest 的另一个特点是不能撤销 setRequestHeader。一旦设置了 header，就无法撤销了。其他调用会向 header 中添加信息，但不会覆盖它</p><p>xhr.setRequestHeader(‘X-Auth’, ‘123’);<br>xhr.setRequestHeader(‘X-Auth’, ‘456’);</p></blockquote></li></ul><h5 id="post方法-和-FormData-对象"><a href="#post方法-和-FormData-对象" class="headerlink" title="post方法 和 FormData 对象:"></a><strong>post方法 和 FormData 对象:</strong></h5><ul><li><p>建立一个 POST 请求，可以使用内建的 FormData 对象来传递信息</p></li><li><pre><code class="javascript">let formData = new FormData([form]); // 创建一个对象，可以选择从 &lt;form&gt; 中获取数据 formData.append(name, value); // 附加一个字段formData.append(&quot;middle&quot;, &quot;Lee&quot;); xhr.open(&#39;POST&#39;, ...);xhr.send(formData); // 将表单发送到服务器。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <br>- &gt; send发送 FormData 对象,它会自动以 Content-<span class="hljs-keyword">Type</span>: multipart/form-data 发送数据,不用在设置Content-<span class="hljs-keyword">Type</span><br>  <br><br>  <br>- **post方法:**<br><br>- 如果我们想用其他的数据类型发送,那就不再使用FormData 对象,使用普通的post即可,但是不要忘记`Content-<span class="hljs-keyword">Type</span>`: <br><br>- &gt; 因为客户端只能发送字符串格式, 设置`Content-<span class="hljs-keyword">Type</span>`告诉服务器你发送的数据是什么格式的，然后服务器才能以对应格式解析请求.  <br><br>- ```js<br>  let <span class="hljs-type">json</span> = <span class="hljs-type">JSON</span>.stringify(&#123;<br>    <span class="hljs-type">name</span>: &quot;John&quot;,<br>    surname: &quot;Smith&quot;<br>  &#125;);<br>  <br>  xhr.<span class="hljs-keyword">open</span>(&quot;POST&quot;, <span class="hljs-string">&#x27;/submit&#x27;</span>)<br>  xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>);<br>  <br>  xhr.send(<span class="hljs-type">json</span>);<br>  // 如果我们更喜欢 <span class="hljs-type">JSON</span>，那么可以使用 `<span class="hljs-type">JSON</span>.stringify` 并以字符串形式发送( 客户端只能发送字符串)但是不要忘记设置 <span class="hljs-keyword">header</span> `Content-<span class="hljs-keyword">Type</span>: application/<span class="hljs-type">json</span>`<br>  // *<span class="hljs-string">&#x27;Content-type&#x27;</span>,<span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>* 发送 <span class="hljs-string">&#x27;name=fef&amp;age=23&#x27;</span>格式数据<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><strong>.send(body) 方法,它几乎可以发送任何 body</strong>，包括 Blob 和 BufferSource 对象。</li></ul><h5 id="上传进度"><a href="#上传进度" class="headerlink" title="上传进度:"></a><strong>上传进度:</strong></h5><ul><li><p>也就是说：如果我们 POST 一些内容，XMLHttpRequest 首先上传我们的数据（request body），然后下载响应。如果我们要上传的东西很大，那么我们肯定会对跟踪上传进度感兴趣。但是 xhr.onprogress 在这里并不起作用。(progress 事件仅在下载阶段触发。)</p></li><li><p>xhr.upload。它会生成事件，类似于 xhr，但是 xhr.upload 仅在上传时触发它们：</p></li><li><blockquote><p>loadstart —— 上传开始。<br>progress —— 上传期间定期触发。<br>abort —— 上传中止。<br>error —— 非 HTTP 错误。<br>load —— 上传成功完成。<br>timeout —— 上传超时（如果设置了 timeout 属性）。<br>loadend —— 上传完成，无论成功还是 error。</p></blockquote></li><li><pre><code class="js">xhr.upload.onprogress = function(event) &#123;alert(`Uploaded $&#123;event.loaded&#125; of $&#123;event.total&#125; bytes`);&#125;;<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- &gt; xhr 自身还具有 上述事件,(不需要调用.upload属性)<br>  &gt; loadstart —— 请求开始。<br>    &gt; progress —— 一个响应数据包到达，此时整个 response body 都在 response 中。<br>    &gt; abort —— 调用 xhr.abort() 取消了请求。<br>    &gt; error —— 发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。<br>    &gt; load —— 请求成功完成。<br>    &gt; timeout —— 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。<br>    &gt; loadend —— 在 load，error，timeout 或 abort 之后触发。<br>    &gt;<br>    &gt; <br>    &gt;<br>    &gt; error，abort，timeout 和 load 事件是互斥的。其中只有一种可能发生。<br>  <br>    <br><br>##### **带有凭证的跨源请求:**<br><br>- XMLHttpRequest 可以使用和 fetch 相同的 CORS 策略进行跨源请求。<br><br>- &gt; 就像 fetch 一样，默认情况下不会将 cookie 和 HTTP 授权发送到其他域。<br>  &gt;<br>  &gt; 要启用它们，可以将` xhr.withCredentials` 设置为 true, 服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true。<br><br><br><br>#### Fetch<br><br><br><br>#####   网络连接过程<br><br>- 1. 建立连接<br><br>- 基本语法 :<br><br>- ```js<br>  let promise = fetch(url, [options])<br>  // options —— 可选参数：method，header , body等,<br>  //没有 options，那就是一个简单的 GET 请求，下载 url 的内容。<br>  <br>  fetch(url, &#123;<br>      body: JSON.stringify(data), <br>      headers: &#123;<br>        &#x27;content-type&#x27;: &#x27;application/json&#x27;<br>      &#125;,<br>      method: &#x27;POST&#x27;,<br>      ....<br>      &#125;)<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><ol start="2"><li>获取响应 (promise 的原因不再监听事件)</li></ol></li></ul><ul><li><blockquote><p>获取响应通常需要经过两个阶段:</p><p><strong>第一阶段</strong>，当<strong>服务器</strong>发送了响应头（response header），fetch 返回的 promise 就使用内建的 <strong>Response class</strong> 对象来对响应头进行解析。 请求成功相当于 promise resolve(Response class),失败相当于reject(Response class)</p><p>在这个阶段，我们可以通过检查响应头，来检查 HTTP 状态以确定请求是否成功，当前还没有响应体</p><p>我们可以在 response 的属性中看到 HTTP 状态：</p><ul><li><strong><code>status</code></strong> —— HTTP 状态码，例如 200。</li><li><strong><code>ok</code></strong> —— 布尔值，如果 HTTP 状态码为 200-299，则为 <code>true</code>。</li></ul></blockquote></li><li><pre><code class="js">let response = await fetch(url);if (response.ok) &#123; // 如果 HTTP 状态码为 200-299  // 获取 response body（此方法会在下面解释）  let json = await response.json();&#125; else &#123;  alert(&quot;HTTP-Error: &quot; + response.status);&#125;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> &gt; **第二阶段**，为了获取 **<span class="hljs-selector-tag">response</span> <span class="hljs-selector-tag">body</span>**，我们需要使用一个其他的方法调用。`<span class="hljs-selector-tag">Response</span>` 提供了多种基于 <span class="hljs-selector-tag">promise</span> 的方法，来以不同的格式访问 <span class="hljs-selector-tag">body</span>：<br>  &gt;<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.text</span>() ——读取 <span class="hljs-selector-tag">response</span>，并以文本形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.json</span>() —— 将 <span class="hljs-selector-tag">response</span> 解析为 <span class="hljs-selector-tag">JSON</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.formData</span>() —— 以 <span class="hljs-selector-tag">FormData</span> 对象（在 下一章 有解释）的形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.blob</span>() —— 以 <span class="hljs-selector-tag">Blob</span>（具有类型的二进制数据）形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.arrayBuffer</span>() —— 以 <span class="hljs-selector-tag">ArrayBuffer</span>（低级别的二进制数据）形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt;<br>  &gt; <br>  &gt;<br>  &gt; 我们只能选择一种读取 <span class="hljs-selector-tag">body</span> 的方法。 多种后面的会失效<br><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">js</span><br>  <span class="hljs-comment">//使用纯promise语法演示</span><br>  <br>  <span class="hljs-selector-tag">fetch</span>(<span class="hljs-string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#x27;</span>)<br>    <span class="hljs-selector-class">.then</span>(response =&gt; response.json())<br>    <span class="hljs-selector-class">.then</span>(commits =&gt; alert(commits[<span class="hljs-number">0</span>].author.login));<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>如果 fetch 无法建立一个 HTTP 请求，例如网络问题，亦或是请求的网址不存在，那么 promise 就会 reject。异常的 HTTP 状态，例如 404 或 500，不会导致出现 error。 导致try catch 无法处理</p><blockquote><p>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</p></blockquote></li></ul><h5 id="Response-request-header"><a href="#Response-request-header" class="headerlink" title="Response/request header:"></a>Response/request header:</h5><ul><li><p><strong>Response header</strong> :</p></li><li><p>response.headers 返回一个类似于 Map 的 header 对象,可以使用Map类似的方法,headers相当于response  class的属性</p></li><li><pre><code class="js">let response = await fetch(&#39;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#39;);// 获取一个 header　alert(response.headers.get(&#39;Content-Type&#39;)); <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- **request <span class="hljs-keyword">header</span>:**<br><br>- 使用<span class="hljs-keyword">fetch</span>方法中<span class="hljs-keyword">option</span>参数 中 headers 选项设置请求头<br><br>- ```js<br>  let response = <span class="hljs-keyword">fetch</span>(protectedUrl, &#123;<br>    headers: &#123;<br>      Authentication: <span class="hljs-string">&#x27;secret&#x27;</span><br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>但是有一些我们无法设置的headers , 它们仅由浏览器控制, 详见 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name">forbidden HTTP headers</a></p></blockquote></li></ul><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求:"></a><strong>POST请求:</strong></h5><ul><li><pre><code class="js">let response = await fetch(&#39;/article/fetch/post/user&#39;, &#123;  method: &#39;POST&#39;,  headers: &#123;    &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;  &#125;,  body: JSON.stringify(user)&#125;);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 请注意，如果请求的 `body` 是字符串，则 `Content-Type` 会默认设置为 `text/plain<span class="hljs-comment">;charset=UTF-8`。 所以我们发送数据时要显式的设置  `Content-Type`.</span><br><br>- &gt; **body** —— request body，其中之一：<br>  &gt;<br>  &gt; 字符串（例如 JSON 编码的），<br>  &gt;<br>  &gt; FormData` 对象，以 `form/multipart` 形式发送数据，<br>  &gt;<br>  &gt; Blob`/`BufferSource` 发送二进制数据，<br>  &gt;<br><span class="hljs-title">  &gt; URLSearchParams](https:</span>//zh.javascript.info/url)，以 `x-www-form-urlencoded` 编码形式发送数据，很少使用<br><br><br><br><span class="hljs-title">#### **Fetch：下载进度:</span>**<br><br>- fetch 方法允许去跟踪下载进度,  到目前为止，fetch 方法无法跟踪 上传 进度。对于这个目的，请使用 XMLHttpRequest<br><br>- &gt; 要跟踪下载进度，我们可以使用 response.body 属性。它返回一个 ReadableStream 特殊的对象，它可以逐块（chunk）提供 body <br><br>- `response.body.getReader()`返回读取器,具备两个属性<br><br>- &gt; - **`done`** —— 当读取完成时为 `true`，否则为 `false`。<br>  &gt;<br>  &gt; - **`value`** —— 字节的类型化数组：`Uint8Array`。<br>  &gt;<br>  &gt;   我们在循环中接收响应块（response chunk），直到加载完成，也就是：直到 `done` 为 `true`。<br>- ```<br>  // 获得总长度（length）<br>const contentLength = +response.headers.get(&#x27;Content-Length&#x27;)<span class="hljs-comment">;</span><br>  // 通过计算读取器的属性 value.length    两者的比例就是下载的进度<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="fetch-终止"><a href="#fetch-终止" class="headerlink" title="fetch 终止:"></a><strong>fetch 终止:</strong></h4><ul><li><p><code>fetch</code> 返回一个 promise。JavaScript 通常并没有“中止” promise 的概念。使用<code>AbortController</code>。它不仅可以中止 <code>fetch</code>，还可以中止其他异步任务</p></li><li><p>创建控制器 (作用于普通的异步任务):</p></li><li><pre><code class="js">let controller = new AbortController();// controller 它具有单个方法 abort()，和单个属性 signal。// 当 abort() 被调用时：abort 事件就会在 controller.signal 上触发,  controller.signal.aborted 属性变为 true。// 在promise中注册事件 controller.signal.addEventListener(&#39;abort&#39;, ...);//调用 controller.abort() ,终止promise<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs">  <br><br>  <br>- 控制器和fetch一起使用:<br><br>- ```js<br>  let controller = new AbortController();<br>  fetch(url, &#123;<br>    signal: controller.signal<br>  &#125;);<br>  controller.abort();<br>  // 调用 controller.abort() 来中止fetch 请求<br>  //当一个 fetch 被中止，它的 promise 就会以一个 error AbortError reject<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>AbortController 是可扩展的，它允许一次取消多个 fetch。使用promise.all 并行请求url,将 signal 属性传递给 fetch 选项, 调用abort()函数可以终止请求</p></li><li><p>如果我们有自己的与 fetch 不同的异步任务(自己新建一个promise任务)，我们可以使用单个 AbortController 中止这些任务以及 fetch。</p></li></ul><h4 id="Fetch-API选项"><a href="#Fetch-API选项" class="headerlink" title="Fetch API选项"></a>Fetch API选项</h4><ul><li><p>这些选项 (option) 大多都很少使用。即使跳过本章，你也可以很好地使用 fetch。</p></li><li><p>这是所有可能的 fetch 选项及其默认值（注释中标注了可选值）的完整列表：</p></li><li><pre><code class="javascript">let promise = fetch(url, &#123;  method: &quot;GET&quot;, // POST，PUT，DELETE，等。  headers: &#123;    // 内容类型 header 值通常是自动设置的    // 取决于 request body    &quot;Content-Type&quot;: &quot;text/plain;charset=UTF-8&quot;  &#125;,  body: undefined // string，FormData，Blob，BufferSource，或 URLSearchParams  referrer: &quot;about:client&quot;, // 或 &quot;&quot; 以不发送 Referer header，  // 或者是当前源的 url  referrerPolicy: &quot;no-referrer-when-downgrade&quot;, // no-referrer，origin，same-origin...  mode: &quot;cors&quot;, // same-origin，no-cors  credentials: &quot;same-origin&quot;, // omit，include  cache: &quot;default&quot;, // no-store，reload，no-cache，force-cache，或 only-if-cached  redirect: &quot;follow&quot;, // manual，error  integrity: &quot;&quot;, // 一个 hash，像 &quot;sha256-abcdef1234567890&quot;  keepalive: false, // true  signal: undefined, // AbortController 来中止请求  window: window // null&#125;);<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- referrer，referrerPolicy , 这些选项决定了 fetch 如何设置 HTTP 的 Referer header。<br><br>- mode 选项是一种安全措施，可以防止偶发的跨源请求：<br><br>- credentials 选项指定 fetch 是否应该随请求发送 cookie 和 HTTP-Authorization header<br><br>- 使用 cache 选项可以忽略 HTTP 缓存或者对其用法进行微调<br><br>- 通常来说，fetch 透明地遵循 HTTP 重定向，例如 301，302 等。redirect 选项允许对此进行更改<br><br>- integrity 选项允许检查响应是否与已知的预先校验和相匹配<br><br>- keepalive   当访问者离开我们的网页时 —— 我们希望能够将数据保存到我们的服务器上。keepalive 选项告诉浏览器，即使在离开页面后，也要在后台执行请求。所以，此选项对于我们的请求成功至关重要。<br><br><br><br>####  跨源请求 和 CORS(跨源资源共享)<br><br>- **跨源请求** —— 那些发送到其他域（即使是子域）、协议或端口的请求<br><br>- 跨源域资源共享（ [CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行<br><br><br><br>- **跨源请求方法 :**<br><br>- `“JSONP (JSON with padding)”`协议:<br><br>- 原理: **script可以具有任何域的 src**, 使用jsonp必须需要服务器端支持,后端接口要改变返回的数据格式才行,数据格式不能是`applicition/ json` 应该为`text/javascript` , 格式设置错误显示`MIME 类型（“application/json”）不是有效的 JavaScript MIME 类型`<br><br>  <br><br>- 方法:<br><br>- &gt; 1.我们先声明一个全局函数gotWeather(...)来接收数据<br>  &gt;<br>  &gt; 2.我们动态创建一个`&lt;script&gt;` 标签 ,属性`src=&quot;http://another.com/weather.json?callback=gotWeather&quot;` 的，使用我们的函数名作为它的 `callback` URL-参数<br>  &gt;<br>  &gt; 3.**服务器端**处理请求,传递`callback(...)`的**字符串**，实际上传给客户端的是gotWeather字符串, 参数里写我们服务器端想要传递的数据,把字符串传递给客户端<br>  &gt;<br>  &gt; 4.当远程脚本加载并执行时，客户端找到`gotWeather` 函数运行，我们也获得了需要的数据。<br><br>- 现在仍然有提供这种访问的服务，因为即使是非常旧的浏览器它依然适用<br><br><br><br>- `CORS`跨源资源共享:<br><br>- **有两种类型的跨源请求**：<br><br>- &gt; 1. 简单的请求。 <br>  &gt; 2.  所有其他请求。<br><br>-  `简单的请求`:   简单的方法：GET，POST 或 HEAD,  简单的 header —— 仅允许自定义下列 header：<br>  <br>- &gt; ​    Accept，<br>  &gt; ​    Accept-Language，<br>  &gt; ​    Content-Language，<br>  &gt; ​    Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。<br><br>- &gt; **本质区别在于，可以使用 `&lt;form&gt;` 或 `&lt;script&gt;` 进行“简单请求”，而无需任何其他特殊方法。**因此，即使是非常旧的服务器也能很好地接收简单请求。<br><br>  <br><br>- `所有其他请求`: 任何其他请求都被认为是“非简单请求”。例如，具有 PUT 方法或 API-Key HTTP-header 的请求就不是简单请求。<br><br>- &gt; 当我们尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器 —— 询问服务器，你接受此类跨源请求吗？并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送。<br><br>  <br><br>- **简单请求的CORS:**<br><br>- 如果一个请求是跨源的，浏览器始终会向其添加 `Origin` header。`Origin` 包含了确切的源（domain/protocol/port）, 服务器可以检查 `Origin`，如果同意接受这样的请求，就会在响应中添加一个特殊的 header `Access-Control-Allow-Origin`。该 header 包含了允许的源,或者一个星号 `*`。然后响应成功，否则报错。<br><br>- 浏览器扮演受信任的中间人的角色:<br><br>- &gt; 1.确保发送的跨源请求带有正确的orgin,<br>  &gt;<br>  &gt;  2.它检查响应中的许可 Access-Control-Allow-Origin(包含一个源,或者*)，如果存在，则允许 JavaScript 访问响应，否则将失败并报错。<br><br><br>- 对于跨源请求，默认情况下，JavaScript 只能访问“简单” response header：<br>  <br>- &gt; Cache-Control<br>    &gt; Content-Language<br>    &gt; Content-Type<br>    &gt; Expires<br>    &gt; Last-Modified<br>    &gt; Pragma<br>    &gt; 访问任何其他 response header 都将导致 error<br><br>    <br>  <br>- 要授予 JavaScript 对任何其他 response header 的访问权限，服务器必须发送 Access-Control-Expose-Headers  header。<br><br><br><br><br>- **非简单的跨源请求:**<br><br>- 我们可以使用任何 HTTP 方法：不仅仅是 GET/POST，也可以是 PATCH，DELETE 及其他。可能仍然存在有些 Web 服务将非标准方法视为一个信号,为了避免误解，任何“非标准”请求 —— 浏览器不会立即发出,即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可。<br><br>- 预检请求 :使用 OPTIONS 方法，它没有 body，但是有两个 header：<br><br>- &gt; Access-Control-Request-Method header 带有非简单请求的方法。<br>  &gt; Access-Control-Request-Headers header 提供一个以逗号分隔的非简单 HTTP-header 列表。<br><br>- 预检响应 :如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：<br><br>- &gt; Access-Control-Allow-Methods 必须具有允许的方法。<br>  &gt; Access-Control-Allow-Headers 必须具有一个允许的 header 列表。<br><br>- 预检成功后，浏览器现在发出主请求, 然后才是实际响应<br><br>- &gt; 预检响应会缓存一段时间，该时间由 `Access-Control-Max-Age` header 指定,因此，后续请求将不会导致预检<br><br>- 实际响应中也要添加`Access-Control-Allow-Origin`。成功的预检并不能免除此要求<br><br>- &gt; 预检请求发生在“幕后”，它对 JavaScript 不可见。<br><br>  <br><br>**带有凭据(cookie https的请求):**<br><br>- 默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。<br><br>- &gt; 要在 fetch 中发送凭据，我们需要添加` credentials: &quot;include&quot; `选项, <br>  &gt;<br>  &gt; 如果服务器同意接受 带有凭据 的请求，则除了 Access-Control-Allow-Origin 外，服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true。<br>- &gt; 对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 *。它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁<br><br>  <br><br>- 拓展: 服务器方法绕过同源检测<br><br>- &gt;  同源策略只存在于ajax,不存在与服务器端开发:<br>  &gt;<br>  &gt; 1号网站客户端访问1号网站服务端, 1号服务器端访问2号服务端, 1号服务端把数据响应给1号客户端,此方法可以绕过同源策略<br><br>#### FormData<br><br>- 表示 HTML 表单数据的对象 ,传递表单中的数据, 带文件或不带文件<br><br>- ```js<br>  let formData = new FormData([form]);<br>  // 如果提供了 HTML form 元素，它会自动捕获 form 元素字段。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>FormData 的特殊之处在于网络方法（network methods），例如 fetch 可以接受一个 FormData 对象作为 body。它会被编码并发送出去，带有 Content-Type: multipart/form-data。从服务器角度来看，它就像是一个普通的表单提交。</p></blockquote></li></ul><ul><li><p>如果内容不是表单,我们也可以new FormData() , 然后通过append()添加,  然后发送,向一个普通表单一样发送</p></li><li><p>使用以下方法修改 FormData 中的字段：</p></li><li><blockquote><p>formData.append(name, value) —— 添加具有给定 name 和 value 的表单字段，<br>formData.append(name, blob, fileName) —— 添加一个字段，就像它是 <input type="file">，第三个参数 fileName 设置文件名（而不是表单字段名），因为它是用户文件系统中文件的名称，<br>formData.delete(name) —— 移除带有给定 name 的字段，<br>formData.get(name) —— 获取带有给定 name 的字段值，<br>formData.has(name) —— 如果存在带有给定 name 的字段，则返回 true，否则返回 false。</p></blockquote></li><li><blockquote><p>一个表单可以包含多个具有相同 name 的字段，因此，多次调用 append 将会添加多个具有相同名称的字段。</p></blockquote></li></ul><ul><li><p> set 方法，语法与 append 相同。不同之处在于 .set 移除所有具有给定 name 的字段，然后附加一个新字段,它确保了只有一个具有这种 <code>name</code> 的字段</p></li><li><blockquote><p>formData.set(name, value)，</p><p>formData.set(name, blob, fileName);</p></blockquote></li></ul><ul><li><p>我们也可以使用 for..of 循环迭代 formData 字段：</p></li><li><blockquote><p>for(let [name, value] of formData) </p><p>{  alert(<code>$&#123;name&#125; = $&#123;value&#125;</code> ); // key1=value1，然后是 key2=value2 }</p></blockquote></li></ul><h4 id="URL-对象"><a href="#URL-对象" class="headerlink" title="URL 对象"></a>URL 对象</h4><ul><li><p>内建的 URL 类提供了用于创建和解析 URL 的便捷接口。没有任何一个网络方法一定需要使用 URL 对象，字符串就足够了。</p></li><li><blockquote><p>new URL(url, [base])</p><p> base —— 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL。</p></blockquote></li><li><p>URL 对象立即允许我们访问其结构组成，因此这是一个解析 url 的好方法 :</p></li><li><blockquote><p>通过属性访问URL结构: </p><p>href 是完整的 URL，与 url.toString() 相同<br>host : hostname + port   域名加端口号<br>protocol 以冒号字符 : 结尾      协议(http…)<br>host+potocol  : origin<br>pathname : 路径名字, 端口后面的<br>search —— 以问号 ? 开头的一串参数  (请求传递的参数)<br>hash 以哈希字符 # 开头<br>如果存在 HTTP 身份验证，则这里可能还会有 user 和 password 属性：<a href="http://login:password@site.com/">http://login:password@site.com</a></p></blockquote></li><li><p>URL 对象可以替代字符串传递给任何方法，因为大多数方法都会执行字符串转换</p></li></ul><ul><li><p><strong>SearchParams “?…”</strong></p></li><li><p>我们想要创建一个具有给定搜索参数的 url，: new URL(‘<a href="https://google.com/search?query=JavaScript&#39;">https://google.com/search?query=JavaScript&#39;</a>) , 如果参数中包含空格，非拉丁字母等，<strong>参数就需要被编码。url.searchParams</strong> 属性解决问题, </p></li><li><blockquote><p>append(name, value) —— 按照 name 添加参数，<br>delete(name) —— 按照 name 移除参数，<br>get(name) —— 按照 name 获取参数，<br>getAll(name) —— 获取相同 name 的所有参数（这是可行的，例如 ?user=John&amp;user=Pete），<br>has(name) —— 按照 name 检查参数是否存在，<br>set(name, value) —— set/replace 参数，<br>sort() —— 按 name 对参数进行排序，很少使用，<br>……并且它是可迭代的，类似于 Map。</p></blockquote></li><li><pre><code class="javascript">let url = new URL(&#39;https://google.com/search&#39;);url.searchParams.set(&#39;tbs&#39;, &#39;qdr:y&#39;); // 添加带有一个冒号 : 的参数// 参数会被自动编码alert(url); // https://google.com/search?q=test+me%21&amp;tbs=qdr%3Ay</code></pre></li></ul><ul><li><p>如果我们不使用URL对象, 而是字符串就要手动对特殊字符进行编码 : </p><blockquote><p>下面是用于编码/解码 URL 的内建函数：</p></blockquote><p>  encodeURI —— 编码整个 URL。<br>  decodeURI —— 解码为编码前的状态。<br>  encodeURIComponent —— 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname。<br>  decodeURIComponent —— 解码为编码前的状态。</p></li></ul><h4 id="长轮询-websocket-Server-Sent-Events"><a href="#长轮询-websocket-Server-Sent-Events" class="headerlink" title="长轮询 websocket  Server Sent Events"></a>长轮询 websocket  Server Sent Events</h4><ul><li><p>常规轮询 : 从服务器获取新信息的最简单的方式是定期轮询。每个周期发送请求,看看服务器有没有信息<br>缺点:两个请求之间延迟是一个周期,不管有没有消息, 在一定时间服务器都会被请求轰炸</p></li><li><p>所谓“长轮询”是轮询服务器的一种更好的方式。它也很容易实现，并且可以无延迟地传递消息它不使用任何特定的协议，例如 WebSocket 或者 Server Sent Event。</p></li><li><p>其流程为：</p></li><li><blockquote><p>请求发送到服务器。<br>服务器在有消息之前不会关闭连接。<br>当消息出现时 —— 服务器将对其请求作出响应。<br>浏览器立即发出一个新的请求。</p><blockquote><p>对于此方法，浏览器发出一个请求并与服务器之间建立起一个挂起的（pending）连接的情况是标准的。仅在有消息被传递时，才会重新建立连接。</p></blockquote></blockquote></li><li><blockquote><p>如果连接丢失，可能是因为网络错误，浏览器会立即发送一个新请求。</p></blockquote></li></ul><p><strong>WebSocket:</strong> </p><ul><li><p> WebSocket 协议提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法。数据可以作为“数据包”在两个方向上传递，而不会断开连接和其他 HTTP 请求。</p></li><li><blockquote><p>对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，WebSocket 尤其有用。</p></blockquote></li></ul><ul><li><p> 语法: </p></li><li><blockquote><p>let socket = new WebSocket(“<em>ws</em>://javascript.info”);   // 同样也有一个加密的 <code>wss://</code> 协议。类似于 WebSocket 中的 HTTPS。 <code>wss://</code> 协议不仅是被加密的，而且更可靠</p></blockquote></li><li><p>一旦 socket 被建立，我们就应该监听 socket 上的事件。一共有 4 个事件：</p></li><li><blockquote><ul><li><strong><code>open</code></strong> —— 连接已建立，</li><li><strong><code>message</code></strong> —— 接收到数据，</li><li><strong><code>error</code></strong> —— WebSocket 错误，</li><li><strong><code>close</code></strong> —— 连接已关闭。</li></ul><p>想发送一些东西，那么可以使用 <code>socket.send(data)</code>。data:字符串或二进制格式无需设置直接发送, </p></blockquote></li><li><p>WebSocket 对象是原生支持跨源的。没有特殊的 header 或其他限制。旧的服务器无法处理 WebSocket，因此不存在兼容性问题。</p></li><li><p>WebSocket 通信由 “frames”（即数据片段）组成，可以从任何一方发送:</p></li><li><blockquote><p>有以下几种类型：</p><p>文本或二进制 frames……,浏览器中只是用二进制和文本类型</p></blockquote></li><li><p><strong>当我们收到数据时，文本总是以字符串形式呈现。而对于二进制数据，我们可以在 <code>Blob</code> 和 <code>ArrayBuffer</code> 格式之间进行选择。它是由 <code>socket.bufferType</code> 属性设置的，默认为 <code>&quot;blob&quot;</code>，</strong></p></li></ul><ul><li><p><strong>关闭连接:</strong></p></li><li><blockquote><p>当一方想要关闭连接时（浏览器和服务器都具有相同的权限），它们会发送一个带有数字码（numeric code）和文本形式的原因的 “connection close frame”。</p><p>socket.close([code], [reason]);</p><ul><li><code>code</code> 是一个特殊的 WebSocket 关闭码（可选）</li><li><code>reason</code> 是一个描述关闭原因的字符串（可选）</li></ul></blockquote></li><li><p><strong>连接状态:</strong></p></li><li><p>要获取连接状态，可以通过带有值的 <code>socket.readyState</code> 属性：</p></li><li><blockquote><ul><li><strong><code>0</code></strong> —— “CONNECTING”：连接还未建立，</li><li><strong><code>1</code></strong> —— “OPEN”：通信中，</li><li><strong><code>2</code></strong> —— “CLOSING”：连接关闭中，</li><li><strong><code>3</code></strong> —— “CLOSED”：连接已关闭。</li></ul></blockquote></li></ul><ul><li>在使用时,服务器端也有处理websocket的方法,要查看服务端的算法</li></ul><p><strong>Server-Sent Events:</strong></p><ul><li><p><a href="https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface">Server-Sent Events</a> 规范描述了一个内建的类 <code>EventSource</code>，它能保持与服务器的连接，并允许从中接收事件。与 <code>WebSocket</code> 类似，其连接是持久的。</p></li><li><p>和websocket区别:</p></li><li><blockquote><p>单向：仅服务端能发送消息</p><p>仅传输文本数据</p><p>使用常规的http协议</p></blockquote></li></ul><ul><li><p>我们为什么要使用它？主要原因：简单。在很多应用中，<code>WebSocket</code> 有点大材小用。</p></li><li><p>我们需要从服务器接收一个数据流：可能是聊天消息或者市场价格等。这正是 <code>EventSource</code> 所擅长的。它还支持自动重新连接，而在 <code>WebSocket</code> 中这个功能需要我们手动实现。此外，它是一个普通的旧的 HTTP，不是一个新协议</p></li><li><p><strong>链接过程</strong>:</p></li><li><blockquote><p>创建 <code>let eventSource = new EventSource(&quot;/events/subscribe&quot;);</code>, 开始接收消息,浏览器将会连接到 <code>url</code> 并保持连接打开，等待事件。</p><p>服务器响应状态码应该为 200，header 为 <code>Content-Type: text/event-stream</code>，然后保持此连接并以一种特殊的格式写入消息，对于每个这样的消息，传递时都会生成 <code>message</code> 事件:</p><p>eventSource.onmessage = function(event) </p></blockquote></li><li><p><code>EventSource</code> 支持跨源请求,就像 <code>fetch</code> 任何其他网络方法,应该设置附加选项 <code>withCredentials</code>,远程服务器将会获取到 <code>Origin</code> header，并且必须以 <code>Access-Control-Allow-Origin</code> 响应</p></li><li><p>创建之后，<code>new EventSource</code> 连接到服务器，如果连接断开 —— 则<strong>重新连接</strong>。这非常方便，我们不用去关心重新连接的事情。</p></li><li><blockquote><p>服务器可以使用 <code>retry:</code> 来设置需要的延迟响应时间（以毫秒为单位）</p></blockquote></li><li><p><strong>链接断开</strong>:</p></li><li><blockquote><ul><li><p>如果服务器想要浏览器停止重新连接，那么它应该使用 HTTP 状态码 204 进行响应。</p></li><li><p>如果浏览器想要关闭连接，则应该调用 <code>eventSource.close()</code>：</p></li></ul><p>  如果响应具有不正确的 <code>Content-Type</code> 或者其 HTTP 状态码不是 301，307，200 和 204，则不会进行重新连接。在这种情况下，将会发出 <code>&quot;error&quot;</code> 事件，并且浏览器不会重新连接</p></blockquote></li></ul><ul><li><p>当一个连接由于网络问题而中断时，客户端和服务器都无法确定哪些消息已经收到哪些没有收到。为了正确地恢复连接，每条消息都应该有一个 <code>id</code> 字段</p></li><li><blockquote><p>当收到具有 <code>id</code> 的消息时，浏览器会：</p><ul><li>将属性 <code>eventSource.lastEventId</code> 设置为其值。</li><li>重新连接后，发送带有 <code>id</code> 的 header <code>Last-Event-ID</code>，以便服务器可以重新发送后面的消息。</li></ul></blockquote></li><li><p><strong>连接状态：readyState</strong></p></li><li><p><code>EventSource</code> 对象有 <code>readyState</code> 属性，该属性具有下列值之一：</p></li><li><blockquote><p>EventSource.CONNECTING = 0; // 连接中或者重连中</p><p> EventSource.OPEN = 1;       // 已连接</p><p> EventSource.CLOSED = 2;     // 连接已关闭</p></blockquote></li><li><p>默认情况下 <code>EventSource</code> 对象生成三个事件：</p></li><li><blockquote><ul><li><code>message</code> —— 收到消息，可以用 <code>event.data</code> 访问。</li><li><code>open</code> —— 连接已打开。</li><li><code>error</code> —— 无法建立连接，例如，服务器返回 HTTP 500 状态码。</li></ul></blockquote></li><li></li></ul><h4 id="RESTful-风格API"><a href="#RESTful-风格API" class="headerlink" title="RESTful 风格API"></a>RESTful 风格API</h4><ul><li>如何设计请求地址的规范格式</li></ul><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><ul><li>把获得的数据拼接在html上进行展示</li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM 基础</title>
    <link href="/2021/02/21/Md%20Js%20dom/DOM%20%E5%86%8D%E5%BC%80/"/>
    <url>/2021/02/21/Md%20Js%20dom/DOM%20%E5%86%8D%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><ul><li><p>JavaScript 语言已经发展成为一种具有多种用途和平台的语言。平台可以是一个浏览器，一个 Web 服务器，或其他主机（host）, 如果它能运行 JavaScript 的话。它们每个都提供了特定于平台的功能。JavaScript 规范将其称为 <strong>主机环境</strong>。</p></li><li><blockquote><p>主机环境提供了自己的对象和语言核心以外的函数。Web 浏览器提供了一种控制网页的方法。Node.JS 提供了服务器端功能 等</p></blockquote></li><li><p>window 代表一个”根”对象,是 JavaScript 代码的全局对象,又代表“浏览器窗口”，并提供了控制它的方法。(查看窗口高度等)</p></li></ul><h4 id="DOM-BOM"><a href="#DOM-BOM" class="headerlink" title="DOM  BOM"></a>DOM  BOM</h4><ul><li><p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。</p></li><li><blockquote><p>document 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</p></blockquote></li><li><p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。</p></li><li><blockquote><p>location 对象允许我们读取当前 URL , navigator 对象提供了有关浏览器和操作系统的背景信息。</p></blockquote></li><li><blockquote><p>函数 alert/confirm/prompt 也是 BOM 的一部分,它代表了与用户通信的纯浏览器方法。</p></blockquote></li></ul><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><ul><li><p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象(元素节点)</p></li><li><p>文本节点中,空格和换行符都是完全有效的字符，就像字母和数字</p></li><li><blockquote><p>**所以在标签和标签之间的空格 换行符会被解析成文本节点 **</p><p>例外 : &lt; head&gt; 之前的空格和换行符均被忽略 , </p></blockquote></li><li><blockquote><p>HTML规范要求所有内容必须位于 &lt; body&gt; 内. 所以 &lt;/ body&gt;之后不能有空格, body之后的内容会被自动移动到body中,并处在最下面</p></blockquote></li><li><p>与 DOM 一起使用的浏览器工具,通常不会在文本的开始/结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。</p></li></ul><ul><li><p>自动修正 : 如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p></li><li><blockquote><p>表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 &lt; tbody&gt;,在形成DOM时,如果没有会给加上</p></blockquote></li><li><p>常用的节点 :  </p><pre><code>  document — DOM 的“入口点”。  元素节点 — HTML 标签，树构建块。  文本节点 — 包含文本。  注释 </code></pre></li></ul><h4 id="遍历DOM"><a href="#遍历DOM" class="headerlink" title="遍历DOM"></a>遍历DOM</h4><ul><li><p>对 DOM 的所有操作都是以 document 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p><pre><code>  &lt;html&gt; = document.documentElement  &lt;body&gt; = document.body  &lt;head&gt; = document.head</code></pre></li><li><blockquote><p>document.body有可能为空,脚本无法访问在运行时不存在的元素。尤其是，如果一个脚本是在 &lt; head&gt; 中，那么脚本是访问不到 document.body 元素的(其他元素也访问不到。获得null值)</p></blockquote></li><li><p>在 DOM 中，null 值就意味着“不存在”或者“没有这个节点”</p></li></ul><ul><li><p><strong>遍历节点属性</strong></p><blockquote><p>子节点 :<br>childNodes : 返回集合(一个类数组的可迭代对象)列出了所有子节点，包括文本节点。<br>firstChild<br>lastChild     </p><p>兄弟节点和父节点:<br>parentNode<br>nextSibling<br>previouSibling</p></blockquote></li></ul><ul><li><blockquote><p>遍历DOM属性都是只读的，只能通过函数对节点进行操作，不能直接通过 “=” 赋值进行更改节点</p><p>几乎所有的 DOM 集合都是 <strong>实时</strong> 的。换句话说，它们反映了 DOM 的当前状态。当保留引用时,节点更新自动会出现在集合中</p></blockquote></li><li><blockquote><p>elem.hasChildNodes() 用于检查节点是否有子节点。</p></blockquote></li></ul><ul><li><p><strong>遍历元素节点属性 ：</strong></p><blockquote><p>children — 仅那些作为元素节点的子代的节点。 返回实时更新的DOM集合<br>firstElementChild，lastElementChild — 第一个和最后一个子元素。<br>previousElementSibling，nextElementSibling — 兄弟元素。<br>parentElement — 父元素。</p></blockquote></li><li><blockquote><p>parentElement 属性返回的是“元素类型”的父节点，而 parentNode 返回的是“任何类型”的父节点,这些属性通常来说是一样的 </p><p>唯一的例外就是 document.documentElement  因为document.documentElement.parentNode       //document   </p><p> parentElement 属性则返回null  因为document不是一个元素节点</p></blockquote></li><li><p>某些类型的 DOM 元素还可能会提供特定于其类型的其他属性。表格（Table）是一个很好的例子  。</p><pre><code>  table.rows — &lt;tr&gt; 元素的集合。  table.caption/tHead/tFoot — 引用元素 &lt;caption&gt;，&lt;thead&gt;，&lt;tfoot&gt;。  table.tBodies — &lt;tbody&gt; 元素的集合  &lt;thead&gt;，&lt;tfoot&gt;，&lt;tbody&gt; 元素提供了 rows 属性  tr.cells — 在给定 &lt;tr&gt; 中的 &lt;td&gt; 和 &lt;th&gt; 单元格的集合。  tr.sectionRowIndex — 给定的 &lt;tr&gt; 在封闭的 &lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt; 中的位置（索引）。  tr.rowIndex — 在整个表格中 &lt;tr&gt; 的编号（包括表格的所有行）。  td.cellIndex — 在封闭的 &lt;tr&gt; 中单元格的编号。</code></pre><blockquote><p>HTML 表单（form）还有其它导航（navigation）属性</p></blockquote></li></ul><h4 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h4><ul><li>节点查找方法</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getElementById</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">getElementsByTagname</span><span class="hljs-params">()</span></span> 返回一个类数组,类数组只能使用下标 和length不具备其他功能<br><span class="hljs-function"><span class="hljs-title">getElementsByClassName</span><span class="hljs-params">()</span></span> 返回一个类数组<br><span class="hljs-function"><span class="hljs-title">getElementsByName</span><span class="hljs-params">()</span></span> 返回在文档范围内具有给定 name 特性的元素,返回类数组<br><span class="hljs-function"><span class="hljs-title">querySelector</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">querySelectorAll</span><span class="hljs-params">()</span></span> 采用了css选择器的格式, 当元素只有一个,使用两个方法效果一样<br></code></pre></td></tr></table></figure><ul><li><p>可以直接使用和元素id相同名字的全局变量 来访问元素</p><blockquote><p>这种容易和相同命名的全局变量冲突,不建议使用</p></blockquote></li><li><p>所有的 <code>getElementsBy</code> 方法都会返回一个 <code>实时的（live） 集合</code>。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。</p><blockquote><p> 相反，<code>querySelectorAll </code>返回的是一个 静态的 集合。就像元素的固定数组</p></blockquote></li></ul><ul><li><p><code>elem.matches(css)</code> 不会查找任何内容，它只会检查 elem 是否与给定的 CSS 选择器匹配。它返回 true 或 false。</p></li><li><blockquote><p>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</p></blockquote></li><li><p><code>elem.closest(css) </code>  向上查找与 CSS 选择器匹配的最近的祖先。elem 自己也会被搜索。与选择器匹配，则停止搜索并返回该祖先。</p></li><li><p><code>elemA.contains(elemB)</code>  用来检查子级与父级之间关系的方法 ,返回Boolen</p></li></ul><h4 id="节点属性：type，tag-和-content"><a href="#节点属性：type，tag-和-content" class="headerlink" title="节点属性：type，tag 和 content"></a>节点属性：type，tag 和 content</h4><ul><li><p>DOM 节点类 : 不同的 DOM 节点可能有不同的属性 例如文本节点与元素节点不同,但是所有这些标签对应的 DOM节点之间也存在共有的属性和方法，每个 DOM 节点都属于相应的内建类。</p></li><li><p>层次结构（hierarchy）的根节点是 EventTarget，Node 继承自它，其他 DOM 节点继承自 Node。</p><pre><code>  EventTarget-&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTMLBodyElement                  |  \          \               Text  Comment   SVGElement</code></pre></li></ul><ul><li><blockquote><p>EventTarget — 是根的“抽象（abstract）”类。该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”.  为事件（包括事件本身）提供支持，</p></blockquote></li><li><blockquote><p>Node — 也是一个“抽象”类，充当 DOM 节点的基础。它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）。 提供通用 DOM 节点属性，</p></blockquote></li><li><blockquote><p>Element — 是 DOM 元素的基本类。它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法,Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement。   提供通用（generic）元素方法</p></blockquote></li><li><blockquote><p>HTMLElement — 最终是所有 HTML 元素的基本类。各种 HTML 元素均继承自它 ,它提供了通用（common）的 HTML 元素方法（以及 getter 和 setter）</p></blockquote></li><li><p>给定节点的全部属性和方法都是继承的结果。  </p></li><li><p>正如我们所看到的，DOM 节点是常规的 JavaScript 对象。它们使用基于原型的类进行继承</p></li></ul><ul><li><p>查看 DOM 节点类名:</p></li><li><blockquote><p>对象通常都具有 constructor 属性。</p><p>alert( document.body.constructor.name ); // HTMLBodyElement</p><p>或者我们可以对其使用 toString 方法</p><p>我们还可以使用 instanceof 来检查继承</p></blockquote></li></ul><ul><li><blockquote><p>console.log(elem) 显示元素的 DOM 树。</p><p>console.dir(elem) 将元素显示为 DOM 对象适合探索其属性。  </p></blockquote></li></ul><h5 id="节点属性-nodetype-nodeName-和-tagName属性"><a href="#节点属性-nodetype-nodeName-和-tagName属性" class="headerlink" title="节点属性 :nodetype nodeName 和 tagName属性"></a>节点属性 :nodetype nodeName 和 tagName属性</h5><ul><li><p>nodeType 属性返回数值表示节点类型, 我们只能读取 nodeType 而不能修改它。它是一种过时的方法</p></li><li><p>从 nodeName 或者 tagName 属性中读取它的标签名：</p><blockquote><p>tagName 属性仅适用于 Element 节点。nodeName 是为任意 Node 定义的：对于元素，它的意义与 tagName 相同。</p><p>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。#text #comment…</p></blockquote></li></ul><h5 id="节点内容-inner-outerHTML属性"><a href="#节点内容-inner-outerHTML属性" class="headerlink" title="节点内容: inner/outerHTML属性"></a>节点内容: inner/outerHTML属性</h5><ul><li><p><code>innerHTML</code> 属性允许将元素内的 HTML 获取为<strong>字符串形式</strong>。我们也可以修改它。(替换原来的元素)</p></li><li><p>“innerHTML+=” 会进行完全重写,移除旧的内容。然后写入新的 innerHTML（新旧结合）。</p></li><li><blockquote><p>移除内容的副作用: 因为内容已“归零”并从头开始重写，因此所有的图片和其他资源都将重写加载</p></blockquote></li><li><p>innerHTML 不包括外围的元素标签,只在元素内中作用</p></li><li><p><code>outerHTML</code> 属性包含了元素的完整 HTML。就像 innerHTML 加上元素本身一样。</p></li><li><blockquote><p>与 <code>innerHTML</code> 不同，写入 <code>outerHTML</code> 不会改变元素。而是在 DOM 中替换它。 换句话说 div.outerHTML = ‘&lt; p&gt;..&lt; /p&gt;’   这时Dom被替换了,但是div.outerHTML的值还是不会改变</p></blockquote></li></ul><ul><li><p><strong>nodeValue/data</strong>：读取/设置文本节点内容 , <strong>仅对文本节点有效</strong></p><blockquote><p>和innerHTML  的区别: innerHTML 属性仅对元素节点有效</p></blockquote><h5 id="textContent-纯文本"><a href="#textContent-纯文本" class="headerlink" title="textContent: 纯文本"></a>textContent: 纯文本</h5></li><li><blockquote><p>textContent  对所有节点有效, 获取文本,去掉所有 &lt; tags&gt;</p></blockquote></li><li><p>写入 textContent 要有用得多，因为它允许以“安全方式”写入文本。 所有符号（symbol）均按字面意义处理。例如可以写入 &lt; b&gt; 等标签像普通字符一样</p></li></ul><ul><li><blockquote><p>innerText 和textContent  区别, textContent 可以输出所有文本内容,innerText只能输出哪些在页面渲染出来的文本, 如果部分文本隐藏,无法显示</p><p>innerHTML 和textContent 区别在于, innerHtml会连同标签一起输出</p></blockquote></li></ul><ul><li>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见。我们可以在 HTML 中使用它，或者使用 JavaScript 进行赋值</li></ul><h4 id="特性和属性（Attributes-and-properties）"><a href="#特性和属性（Attributes-and-properties）" class="headerlink" title="特性和属性（Attributes and properties）"></a>特性和属性（Attributes and properties）</h4><ul><li><p>特性（attribute）— 写在 HTML 中的内容。属性（property）— DOM 对象中的内容。</p></li><li><p>对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）, </p></li><li><blockquote><p>但是 特性 — 属性映射并不是一一对应的</p></blockquote></li><li><p>DOM 属性 :  DOM 节点是常规的 JavaScript 对象,我们可以创建一个新的属性(属性值 函数…),还可以修改内建属性的原型，例如修改 Element.prototype 为所有元素添加一个新方法</p></li><li><p>HTML特性 :  在HTML中，标签可能拥有特性（attributes）。当浏览器解析HTML文本，并根据标签创建 DOM 对象时，浏览器会辨别 标准的 特性并以此创建 DOM 属性。但是非 标准的 特性则不会。</p><blockquote><p>如果一个特性不是标准的，那么就没有相对应的 DOM 属性</p></blockquote></li><li><blockquote><p>一个元素的标准的特性对于另一个元素可能是未知的。例如 “type” 是 &lt; input&gt; 的一个标准的特性（HTMLInputElement），但对于 &lt; body&gt;（HTMLBodyElement）来说则不是。</p></blockquote></li></ul><pre><code>##### 特性操作 (所有特性都可以通过使用以下方法进行访问):    elem.hasAttribute(name) — 检查特性是否存在。    elem.getAttribute(name) — 获取这个特性值。  elem.setAttribute(name, value) — 设置这个特性值。    elem.removeAttribute(name) — 移除这个特性。    elem.attributes 读取所有特性, 属于内建 Attr 类的对象的集合,具有 name 和 value 属性。(可迭代对象)</code></pre><ul><li>HTML特性有以下几个特征：它们的名字是大小写不敏感的（id 与 ID 相同）。它们的值总是字符串类型的(使用alert输出总是字符串)。</li><li><blockquote><p>  使用get…获取时大小写不敏感 ; </p><p>  将任何东西赋值set..给特性，这些东西会变成字符串类型 ;</p></blockquote></li></ul><ul><li>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</li><li><blockquote><p>例如 input.value 只能从特性同步到属性，反过来则不行：</p><p>这个“功能”在实际中会派上用场，因为用户行为可能会导致 value 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。</p></blockquote></li></ul><ul><li>DOM 属性不总是字符串类型的 :   input.checked 属性（对于 checkbox 的）是布尔型的。 style 属性是一个对象</li><li><blockquote><p>尽管大多数 DOM 属性都是字符串类型的。有一种非常少见的情况，即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的。 href 属性 : 一直是一个完整的 URL  href特性 : 标签中的值</p></blockquote></li></ul><h5 id="自定义-非标准-特性"><a href="#自定义-非标准-特性" class="headerlink" title="自定义(非标准)特性"></a>自定义(非标准)特性</h5><ul><li><p>有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。但是自定义的特性也存在问题,名字之间可能会有冲突。</p></li><li><p>如果我们出于我们的目的使用了非标准的特性，之后它被引入到了标准中并有了其自己的用途，该怎么办？ 为了避免冲突，存在 data-* 特性。</p></li><li><blockquote><p>所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。如果一个 elem 有一个名为 “data-about” 的特性，那么可以通过 elem.dataset.about 取到它</p></blockquote></li></ul><ul><li><p>在大多数情况下，最好使用 DOM 属性。仅当 DOM 属性无法满足开发需求，并且我们真的需要特性时，才使用特性</p><blockquote><p>例如：我们需要一个非标准的特性。但是如果它以 data- 开头，那么我们应该使用 dataset。</p><p>我们想要读取 HTML 中“所写的”值。对应的 DOM 属性可能不同，例如 href 属性一直是一个 完整的 URL，但是我们想要的是“原始的”值。</p></blockquote></li><li><p>自定义属性可以和 样式结合起来,  通过css属性选择符,规定特定的属性有特定的样式</p></li></ul><hr><h4 id="修改文档-document"><a href="#修改文档-document" class="headerlink" title="修改文档(document)"></a>修改文档(document)</h4><ul><li><p>创建元素 : </p></li><li><blockquote><p>document.createElement(tag) //元素节点</p><p>document.createTextNode(text) //文本节点</p></blockquote></li><li><p>插入元素 :</p><pre><code>node.append(...nodes or strings) — 在 node 末尾 插入节点或字符串，  node.prepend(...nodes or strings) — 在 node 开头 插入节点或字符串，  node.before(...nodes or strings) — 在 node 前面 插入节点或字符串，  node.after(...nodes or strings) — 在 node 后面 插入节点或字符串，  node.replaceWith(...nodes or strings) — 将 node 替换为给定的节点或字符串。</code></pre></li><li><blockquote><p>这些方法可以在单个调用中一次<strong>插入多个节点列表</strong>和文本片段。</p><p> div.before(‘<p>Hello</p>‘,document.createElement(‘hr’)); 这里的文字都被“作为文本”插入，而不是“作为 HTML 代码”</p><p>这些方法只能用来插入 DOM 节点或文本片段。</p></blockquote></li></ul><ul><li><p>如果我们想要将内容“作为 HTML 代码插入”，像使用 <code>elem.innerHTML</code> 所表现的效果一样,我们可以使用另一个非常通用的方法：elem.insertAdjacentHTML(where, html)。</p></li><li><p>**elem.insertAdjacentHTML(where, html): **</p></li><li><p>第一个参数是代码字（code word），指定相对于 elem 的插入位置。第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;beforebegin&quot;</span> — 将 html 插入到 elem 前插入，<br><span class="hljs-string">&quot;afterend&quot;</span> — 将 html 插入到 elem 后。<br><span class="hljs-string">&quot;afterbegin&quot;</span> — 将 html 插入到 elem 开头，<br><span class="hljs-string">&quot;beforeend&quot;</span> — 将 html 插入到 elem 末尾，<br></code></pre></td></tr></table></figure></li><li><blockquote><p>elem.insertAdjacentText(where, text) — 语法一样，但是将 text 字符串“作为文本”插入而不是作为 HTML，    </p><p>elem.insertAdjacentElement(where, elem) — 语法一样，但是插入的是一个元素。  </p></blockquote><blockquote><p>它们的存在主要是为了使语法“统一”。因为对于元素和文本，我们有 append/prepend/before/after 方法 </p></blockquote></li></ul><ul><li><p>节点移除:</p></li><li><p>想要移除一个节点 :  node.remove()。</p></li><li><blockquote><p>如果我们要将一个元素移动到另一个地方,不需要删除后再添加,插入方法会自动从旧位置删除该节点。在新的位置添加</p></blockquote></li><li><p>克隆节点：</p></li><li><blockquote><p> 调用 <code>elem.cloneNode(true)</code> 来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。     </p><p>  如果我们调用<code> elem.cloneNode(false)</code>，那克隆就不包括子元素。</p></blockquote></li></ul><ul><li>DocumentFragment 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。….之所以提到 DocumentFragment ，主要是因为它上面有一些概念，例如 <a href="https://zh.javascript.info/template-element">template</a> 元素，我们将在以后讨论。</li></ul><h5 id="老式的-insert-remove-方法"><a href="#老式的-insert-remove-方法" class="headerlink" title="老式的 insert/remove 方法"></a>老式的 insert/remove 方法</h5><ul><li><p>由于历史原因，还存在“老式”的 DOM 操作方法。我们在这儿列出这些方法的唯一原因是，你可能会在许多就脚本中遇到它们。</p><blockquote><p>parentElem.appendChild(node)  将 node 附加为 parentElem 的最后一个子元素。</p><p>parentElem.insertBefore(node, nextSibling)  在 parentElem 的 nextSibling 前插入 node。</p><p>parentElem.replaceChild(node, oldChild)  将 parentElem 的后代中的 oldChild 替换为 node。</p><p>parentElem.removeChild(node) 从 parentElem 中删除 node（假设 node 为 parentElem 的后代）。</p></blockquote></li><li><blockquote><p>所有这些方法都会返回插入/删除的节点。换句话说，parentElem.appendChild(node) 返回 node。</p></blockquote></li></ul><ul><li><p>还有一个非常古老的向网页添加内容的方法：document.write 调用 document.write(html) 意味着将 html “就地马上”写入页面。document.write`调用只在页面加载时工作,如果我们稍后调用它，则现有文档内容将被擦除。</p></li><li><blockquote><p>调用 <code>document.write</code> 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它。所以它运行起来出奇的快，因为它 <strong>不涉及 DOM 修改</strong>。它直接写入到页面文本中，而此时 DOM 尚未构建。</p></blockquote></li></ul><h4 id="样式和类"><a href="#样式和类" class="headerlink" title="样式和类"></a>样式和类</h4><ul><li><p>JavaScript 既可以修改类，也可以修改 style 属性。相较于将样式写入 style 属性，我们应该首选通过 CSS 类的方式来添加样式。仅当类“无法处理”时，才应选择使用 style 属性的方式。</p></li><li><p>className 和 classList </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">elem.className 对应于 <span class="hljs-string">&quot;class&quot;</span> 特性（attribute）。<br>类似 setAttribute()操作,整体替换<br><br>如果我们对 elem.className 进行赋值，它将替换类中的整个字符串。有时，这正是我们所需要的，但通常我们希望添加/删除单个类。 (某个元素可能有多个类名),我们既可以使用 className 对完整的类字符串进行操作，也可以使用使用 classList 对单个类进行操作<br><br>elem.classList 是一个特殊的对象，它具有 add/remove/toggle 单个类的方法。<br></code></pre></td></tr></table></figure></li><li><blockquote><p>elem.classList.contains(class) — 检查给定类，返回 true/false。</p></blockquote></li><li><p>classList 是可迭代的 可以使用for of 进行输出所有类名</p><h5 id="元素样式"><a href="#元素样式" class="headerlink" title="元素样式"></a>元素样式</h5></li><li><p>elem.style 属性是一个对象，它对应于 “style” 特性（attribute）中所写的内容</p></li><li><blockquote><p>对于多词（multi-word）属性，使用驼峰式 . 前缀属性像 -moz-border-radius 和 -webkit-border-radius 这样的浏览器前缀属性，也遵循同样的规则</p></blockquote></li><li><p><strong>重置样式属性</strong> : </p><ul><li>不应该使用 delete elem.style.display，而应该使用 elem.style.display = “” 将其赋值为空。</li></ul></li><li><p><strong>设置多个样式属性</strong> : </p><ul><li><p>我们不能像这样的 div.style=”color: red; width: 100px” 设置完整的属性，因为 div.style 是一个对象，并且它是只读的</p></li><li><p>想要以字符串的形式设置完整的样式，可以使用特殊属性 style.cssText ,这样的赋值会删除所有现有样式：它不是进行添加样式，而是替换所有样式。</p></li><li><blockquote><p>可以通过设置一个特性（attribute）来实现同样的效果：div.setAttribute(‘style’, ‘color: red…’)。</p></blockquote></li></ul></li></ul><ul><li>style 属性仅对 “style” 特性（attribute）值起作用,不能获取在style外应用的样式,如果想要获得<strong>当前应用的css样式</strong>使用以下 :</li></ul><ul><li><p><strong>计算样式</strong>：getComputedStyle(element, [pseudo])  </p></li><li><blockquote><p>结果是一个具有样式属性的对象 ,通过 . 调用获得当前应用样式</p><p>pseudo : 表示一个伪元素  ::before    要添加引号</p></blockquote></li></ul><ul><li><p>计算值和解析值</p><blockquote><p>计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，它看起来像 height:1em 或 font-size:125%。</p></blockquote><blockquote><p>解析 (resolved) 样式值是最终应用于元素的样式值值。浏览器将使用计算（computed）值，并使所有单位均为固定的,且为绝对单位，例如：height:20px 或 font-size:16px</p></blockquote></li><li><blockquote><p>现在 getComputedStyle 实际上返回的是属性的解析值（resolved）。</p></blockquote></li></ul><ul><li><p>getComputedStyle 需要完整的属性名,我们应该总是使用我们想要的确切的属性，例如 paddingLeft、marginTop 或 borderTopWidth。否则，就不能保证正确的结果。</p></li><li><blockquote><p>如果有 paddingLeft/paddingTop 属性，那么对于getComputedStyle(elem).padding，我们会得到什么？什么都没有，或者是从已知的 padding 中“生成”的值？这里没有标准的规则。</p></blockquote></li><li><p>  getComputedStyle 没有办法是用伪类获取 样式</p></li><li><blockquote><p>JavaScript 看不到 <code>:visited</code> 所应用的样式。此外，CSS 中也有一个限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式</p></blockquote></li></ul><h4 id="元素大小-滚动"><a href="#元素大小-滚动" class="headerlink" title="元素大小 滚动"></a>元素大小 滚动</h4><ul><li>JavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。</li></ul><ul><li><p>一些浏览器（并非全部）通过从内容大小中获取空间来为滚动条保留空间。 如果有padding在padding中出现滚动条  </p></li><li><blockquote><p>google 内容宽度计算会减去滚动条的宽度   火狐则是 内容大小不变(但实际滚动条仍是占据了内容宽度)   不管有无padding都遵循上述内容</p></blockquote></li><li><blockquote><p>如果元素中有很多文本，并且溢出了，那么浏览器会在 padding-bottom 处显示“溢出”文本，这是正常现象。</p></blockquote></li><li><p>如果一个元素（或其任何祖先）具有 display:none 或不在文档中，则所有几何属性均为零（或 offsetParent 为 null）。 我们可以用它来检查一个元素是否被隐藏 :    </p></li><li><pre><code class="javascript">return !elem.offsetWidth &amp;&amp;!elem.offsetHeight;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs"><br>    <br><br>    <br><br>     **offsetParent，offsetLeft/Top ,offsetWidth/Height  :**<br><br>- offsetParent 返回一个最接近的祖先<br><br>    ```html<br>    最近的祖先为下列之一：<br>    CSS 定位的（position 为 absolute，relative 或 fixed），<br>    或 &lt;td&gt;，&lt;th&gt;，&lt;table&gt;，<br>    或 &lt;body&gt;。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>属性 offsetLeft/offsetTop 提供相对于 offsetParent 左上角的 x/y 坐标。</p><p>offsetWidth/Height 提供了元素的完整大小（包括边框）。</p></blockquote><p>  <strong>clientTop/Left,clientWidth/Height :</strong></p></li><li><p>clientTop/Left  : 在元素内部，我们有边框（border)。为了测量它们，可以使用 clientTop 和 clientLeft。</p></li><li><blockquote><p>但准确地说 — 这些属性不是边框的 width/height，而是内侧与外侧的相对坐标。当文档从右到左显示（操作系统为阿拉伯语或希伯来语）时，影响就显现出来了。此时滚动条不在右边，而是在左边，此时 clientLeft 则包含了滚动条的宽度。</p></blockquote></li><li><p>clientWidth/Height : 这些属性提供了元素边框内区域的大小。 它们包括了 “content width” 和 “padding”，但不包括滚动条宽度（scrollbar）：</p></li><li><blockquote><p>如果这里没有 padding，那么 clientWidth/Height 代表的就是内容区域，即 border 和 scrollbar（如果有）内的区域。</p></blockquote></li></ul><p><strong>scrollWidth/Height, scrollLeft/scrollTop :</strong></p><ul><li><p>scrollWidth/Height :  这些属性就像 clientWidth/clientHeight，但它们还包括滚动出（隐藏）的部分：</p></li><li><blockquote><p>scrollHeight : 是内容区域的完整内部高度，包括滚动出的部分。  </p><p>scrollWidth  : 是完整的内部宽度，没有水平滚动时，它等于 clientWidth。</p></blockquote></li><li><p>scrollLeft/scrollTop :  是元素的隐藏、滚动部分的 width/height。 换句话说，scrollTop 就是“已经滚动了多少”。</p></li><li><blockquote><p>除了 scrollLeft/scrollTop 外，所有属性都是只读的。如果我们修改 scrollLeft/scrollTop，浏览器会滚动对应的元素。</p></blockquote></li></ul><ul><li>不要从 CSS 中获取 width/height<ol><li>首先，CSS width/height 取决于另一个属性：box-sizing，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 box-sizing 进行的更改可能会破坏此类 JavaScript 操作</li><li>其次，CSS 的 width/height 可能是 auto，例如内联（inline）元素： 在 JavaScript 中，我们需要一个确切的 px 大小，以便我们在计算中使用它。因此，这里的 CSS 宽度没什么用</li><li>滚动条问题:使用 getComputedStyle(elem).width 时，有些返回实际宽度, 有些返回的宽度中包含滚动条</li></ol></li></ul><h4 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h4><ul><li><p><strong>获取窗口（window）的宽度和高度</strong>:，我们可以使用 document.documentElement 的 clientWidth/clientHeight </p></li><li><blockquote><p><strong>clientWidth/clientHeight</strong> 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height</p><p><strong>window.innerWidth/innerHeight</strong> 属性。 则包括了滚动条的宽度高度</p></blockquote></li><li><p><strong>获取文档的 width/height:</strong>, 从理论上讲，由于根文档元素是 document.documentElement，并且它包围了所有内容，因此我们可以通过使用 documentElement.scrollWidth/scrollHeight 来测量文档的完整大小。<br>但是在该元素上，对于整个文档，这些属性均无法正常工作。</p></li></ul><blockquote><p>为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-built_in">Math</span>.max(<br>  <span class="hljs-built_in">document</span>.body.scrollHeight, <span class="hljs-built_in">document</span>.documentElement.scrollHeight,<br>  <span class="hljs-built_in">document</span>.body.offsetHeight, <span class="hljs-built_in">document</span>.documentElement.offsetHeight,<br>  <span class="hljs-built_in">document</span>.body.clientHeight, <span class="hljs-built_in">document</span>.documentElement.clientHeight<br>);<br><br></code></pre></td></tr></table></figure><ul><li><strong>获得当前滚动</strong> :</li><li>DOM 元素的当前滚动状态在 elem.scrollLeft/scrollTop 中。</li><li><blockquote><p>对于文档滚动，在大多数浏览器中，我们可以使用 document.documentElement.scrollLeft/Top，但在较旧的基于 WebKit 的浏览器中则不行</p><p>我们根本不必记住这些特性，因为滚动在 <code>window.pageXOffset/pageYOffset</code> 中可用</p><p>这些属性是只读的</p></blockquote></li></ul><ul><li><strong>更改滚动</strong>：</li><li><blockquote><p>scrollTo，scrollBy，scrollIntoView</p><p>window.scrollBy(x,y),将页面滚动至相对于当前位置(针对窗口)的 (x, y) 位置  </p><p>window.scrollTo(pageX,pageY)。将页面滚动至绝对坐标(针对文档)        这些方法适用于所有浏览器。</p><p>对 elem.scrollIntoView(top) 的调用将滚动页面以使 elem 可见 ,  top=true（默认值） 页面滚动，使 elem 出现在窗口顶部  top=false，页面滚动，使 elem 出现在窗口底部。</p></blockquote></li></ul><ul><li> 禁止滚动 :要使文档不可滚动，只需要设置 document.body.style.overflow = “hidden”。该页面将冻结在其当前滚动上。 document.body.style.overflow = ‘’ 恢复滚动</li><li><blockquote><p>我们还可以使用相同的技术来“冻结”其他元素的滚动，而不仅仅是 document.body。</p></blockquote></li></ul><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><ul><li><p>大多数 JavaScript 方法处理的是以下<strong>两种坐标系</strong>中的一个：</p></li><li><blockquote><p>相对于窗口 — 类似于 position:fixed，从窗口的顶部/左侧边缘计算得出。我们将这些坐标表示为<code> clientX/clientY</code></p><p>相对于文档 — 与文档根中的 position:absolute 类似，从文档的顶部/左侧边缘计算得出。我们将它们表示为 <code>pageX/pageY</code>。</p></blockquote></li></ul><ul><li><p><strong>元素坐标</strong>：elem.getBoundingClientRect() </p></li><li><blockquote><p>方法 <code>elem.getBoundingClientRect()</code> 返回最小矩形的窗口坐标，该矩形将 <code>elem</code> 作为内建 <a href="https://www.w3.org/TR/geometry-1/#domrect">DOMRect</a> 类的对象</p></blockquote></li><li><blockquote><p>返回值是一个 DOMRect 对象</p><p>主要 DOMRect 属性 :</p><p>x/y — 矩形原点相对于窗口的 X/Y 坐标，<br>width/height — 矩形的 width/height（可以为负）。<br>此外，还有派生（derived）属性：</p><p>top/bottom — 顶部/底部矩形边缘的 Y 坐标，<br>left/right — 左/右矩形边缘的 X 坐标。    </p><p>窗口的所有坐标都从左上角开始计数 ,与CSS position top/bottom属性不同</p></blockquote></li></ul><ul><li><p>elementFromPoint(x, y), 会返回在窗口坐标 (x, y) 处嵌套最多（the most nested）的元素。</p></li><li><blockquote><p>方法 document.elementFromPoint(x,y) 只对在可见区域内的坐标 (x,y) 起作用。</p></blockquote></li></ul><ul><li><p><strong>文档坐标:</strong></p></li><li><p>文档相对坐标从文档的左上角开始计算，而不是窗口。</p></li><li><p>这两个坐标系统通过以下公式相连接：</p></li><li><blockquote><p>pageY = clientY + 文档的垂直滚动出的部分的高度。  pageX = clientX + 文档的水平滚动出的部分的宽度。</p></blockquote></li><li><blockquote><p>窗口坐标非常适合和 position:fixed 一起使用，文档坐标非常适合和 position:absolute 一起使用。</p></blockquote></li></ul><h3 id="事件简介"><a href="#事件简介" class="headerlink" title="事件简介"></a>事件简介</h3><h4 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h4><ul><li><p>常用事件:      </p><blockquote><p>Document 事件 : DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</p><p>CSS 事件：transitionend —— 当一个 CSS 动画完成时。</p><p>键盘事件  鼠标事件  表单事件</p></blockquote></li></ul><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><ol><li><p>事件处理程序可以设置在 HTML 中名为 on&lt; event&gt; 的特性（attribute）中。</p><blockquote><p>如果在HTML特性中写处理程序,this表示全局对象 </p><p>window 在严格模式中为 undefined。 </p></blockquote></li></ol><ul><li><p>不要对处理程序使用 setAttribute。</p><blockquote><p> document.body.setAttribute(‘onclick’, function() { alert(1) });   //失效</p></blockquote></li><li><p>如果一个处理程序是通过 HTML 特性（attribute）分配的，浏览器读取特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）</p></li></ul><ol start="2"><li><p>我们还可以使用 DOM 属性（property）on&lt; event&gt; 来分配处理程序。</p><blockquote><p>elem.onclick = function() {}  </p><p>要移除一个处理程序 —— 赋值 elem.onclick = null。</p><p>使用dom属性分配处理程序, 如果为此事件分配两个处理程序,新的 DOM 属性将覆盖现有的 DOM 属性  </p></blockquote></li><li><p>addEventListener 和 removeEventListener 来管理处理程序的替代方法,可以为一个事件分配多个处理程序</p><blockquote><p><code>element.addEventListener(event, handler[, options]);</code>  </p><p>和<code>removeEventListener</code>语法相同</p><p>options具有以下属性的附加可选对象：<br>once：如果为 true，那么会在被触发后自动删除监听器。<br>capture：事件处理的阶段，true :捕获阶段处理程序<br>passive：如果为 true，那么处理程序将不会调用 preventDefault()，</p><p>由于历史原因，options 也可以是 false/true，它与 {capture: false/true} 相同。</p></blockquote></li></ol><ul><li><p>要移除处理程序，我们需要传入与分配的函数完全相同的函数</p></li><li><blockquote><p>直接给于匿名函数(或箭头函数)来移除处理程序无法实现,过程中相当于创建了两个相同内容的不同的函数,</p><p><strong>所以如果我们不将函数存储在一个变量中，那么我们就无法移除它</strong></p><p>对于某些事件，只能通过 addEventListener 设置处理程序,例如 transtionend 和 DOMContentLoaded</p></blockquote></li></ul><ul><li>HTML特性中处理函数带括号,而其余的处理方式不带括号,带括号相当于直接函数调用</li></ul><ul><li><p>为什么要使用 <code>addEventListener</code>?</p></li><li><blockquote><p>它允许给一个事件注册多个监听器</p><p>它提供了一种更精细的手段控制 <code>listener</code> 的触发阶段。（即可以选择捕获或者冒泡）</p><p>它对任何 DOM 元素都是有效的</p></blockquote></li></ul><h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><ul><li><p>当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。</p></li><li><p>event 对象的一些属性：</p></li><li><blockquote><p>type  事件类型     </p><p>currentTarget   处理事件的元素  </p><p>.event.clientX / event.clientY  指针事件中指针的窗口相对坐标</p><p>还有很多属性。其中很多都取决于事件类型：键盘事件具有一组属性，指针事件具有另一组属性</p></blockquote></li><li><p>event 对象在 HTML 特性中处理程序中也可用</p></li></ul><h5 id="对象处理程序"><a href="#对象处理程序" class="headerlink" title="对象处理程序"></a>对象处理程序</h5><ul><li><p>我们不仅可以分配函数，还可以使用 addEventListener 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 handleEvent 方法。 我们还可以为此使用类创建一个对象</p></li><li><p>此类中必须要有一个handleEvent(event) 方法</p><blockquote><p>handleEvent 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法</p></blockquote><blockquote><p>这样会使事件处理程序分离出来,处理多个事件时更加方便, 利于后期维护   : 事件委托章节中的实例诠释了这种写法</p></blockquote></li></ul><h4 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h4><ul><li><strong>冒泡</strong>（bubbling）原理很简单。当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</li></ul><ul><li><blockquote><p>event.target —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。  计划运行的元素</p><p>this —— 实际上处理事件的”当前”元素.  ( == event.currentTarget)  </p></blockquote></li><li><p>冒泡事件从目标元素开始向上冒泡 ,它们会调用路径上所有的处理程序。</p></li><li><p><strong>停止冒泡的方法</strong>是 event.stopPropagation()。 如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行, event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的其他处理程序运行</p></li><li><blockquote><p>通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。</p></blockquote></li><li><p><strong>捕获</strong> : </p></li><li><p>DOM 事件标准描述了事件传播的 3 个阶段：</p><blockquote><p>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。      </p><p>目标阶段（Target phase）—— 事件到达目标元素。</p><p>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</p></blockquote></li><li><blockquote><p>为了在捕获阶段捕获事件，我们需要将处理程序的 capture 选项设置为 true 如果为 false（默认值），则在冒泡阶段设置处理程序。</p></blockquote></li><li><p>要移除处理程序，<code>removeEventListener</code> 需要同一阶段</p></li></ul><ul><li>如果我们在同一阶段有多个事件处理程序，并通过 <code>addEventListener</code> 分配给了相同的元素，则它们的运行顺序与创建顺序相同</li></ul><blockquote><p>冒泡 和捕获 的两种方式, 实际上在影响事件的执行顺序, 冒泡是子元素首先执行事件,  捕获 是父元素首先执行事件</p></blockquote><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><ul><li><pre><code class="javascript">event.target.closest(&#39;td&#39;)  针对td中有嵌套元素时,用来获取td元素的方法 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- 委托示例：标记中的行为  看看实例的书写 https:<span class="hljs-comment">//zh.javascript.info/event-delegation 通过自定义特性进行标记, 写一个类, 通过获取自定义属性执行相应的函数, 把该类绑定到父元素上事件处理</span><br><br>- 行为模式 :将描述其行为的自定义特性添加到元素。 用文档范围级的处理程序追踪事件(通过事件委托),如果事件发生在具有特定特性的元素上,则执行行为   <br><br>- &gt; 这可能变得非常方便 —— 无需为每个这样的元素编写 JavaScript。只需要添加自定义特性。文档级处理程序使其适用于页面的任意元素。  可能为库 框架提供一个方便的调用<br><br><br><span class="hljs-meta">#### 浏览器默认行为</span><br><br>- &gt; 点击一个链接 —— 触发导航（navigation）到该 URL。<br>  &gt;<br>  &gt; 点击表单的提交按钮 —— 触发提交到服务器的行为。<br>  &gt;<br>  &gt; 在文本上按下鼠标按钮并移动 —— 选中文本。<br><br>- 某些事件会相互转化。如果我们阻止了第一个事件，那就没有第二个事件了。<br><br><br><br>- 有两种方式来告诉浏览器我们不希望它执行默认行为：<br>  <br>- &gt;  主流的方式是使用 <span class="hljs-keyword">event</span> 对象。有一个 <span class="hljs-keyword">event</span>.preventDefault() 方法。<br>  &gt;<br>  &gt;  如果处理程序是使用 <span class="hljs-keyword">on</span>&lt; <span class="hljs-keyword">event</span>&gt;（而不是 addEventListener）分配的，那返回 <span class="hljs-literal">false</span> 也同样有效。<br>  &gt;<br>  &gt;  从处理程序返回 <span class="hljs-literal">false</span> 是一个例外, 事件处理程序返回的值通常会被忽略。唯一的例外是从使用 <span class="hljs-keyword">on</span>&lt;<span class="hljs-keyword">event</span>&gt; 分配的处理程序中返回的 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>。<br>  <br>  <br>  <br>- addEventListener 的可选项 passive: <span class="hljs-literal">true</span> 向浏览器发出信号，表明处理程序将不会调用 preventDefault()。<br><br>  &gt; 为什么需要?  <br><br>- 如果默认行为被阻止，那么 `<span class="hljs-keyword">event</span>.defaultPrevented 属性`为 <span class="hljs-literal">true</span>，否则为 <span class="hljs-literal">false</span>。<br><br>- &gt; 有时我们可以使用 <span class="hljs-keyword">event</span>.defaultPrevented 来代替，来通知其他事件处理程序，该事件已经被处理。 不再使用<span class="hljs-keyword">event</span>.stopPropagation() , 来阻止冒泡  <br>  &gt;<br>- <span class="hljs-keyword">event</span>.stopPropagation() 和 <span class="hljs-keyword">event</span>.preventDefault()是两个不同的东西。它们之间毫无关联。<br><br>  <br><span class="hljs-meta">#### 创建自定义事件</span><br>- 内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 Event 类。<br><br>-  **创建自定义事件过程** :<br><br>  - <span class="hljs-keyword">new</span> Event(type[, options]); <br><br>  &gt; type —— 事件类型，可以是像这样 <span class="hljs-string">&quot;click&quot;</span> 的字符串，或者我们自己的像这样 <span class="hljs-string">&quot;my-event&quot;</span> 的参数。<br>  &gt;<br>  &gt; options —— 具有两个可选属性的对象：<br>  &gt;<br>  &gt; bubbles: <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span> —— 如果为 <span class="hljs-literal">true</span>，那么事件会冒泡<br>  &gt;<br>  &gt; cancelable: <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span> —— 如果为 <span class="hljs-literal">true</span>，那么“默认行为”就会被阻止。<br>  &gt;<br>  &gt; 默认情况下，以上两者都为 <span class="hljs-literal">false</span>：必须设置 bubbles:<span class="hljs-literal">true</span>，否则事件不会向上冒泡。<br><br>  - 事件对象被创建后，使用 elem.dispatchEvent(<span class="hljs-keyword">event</span>) 调用,在元素上<span class="hljs-string">&#x27;&#x27;</span>运行<span class="hljs-string">&#x27;&#x27;</span>。然后,就可以像常规事件一样捕获该事件 进行处理<br><br>  - &gt; 我们应该对我们的自定义事件使用 addEventListener，因为 <span class="hljs-keyword">on</span>&lt; <span class="hljs-keyword">event</span>&gt; 仅存在于内建事件中，document.onhello 则无法运行。<br><br>  <br><br>- 有一种方法可以区分“真实”用户事件和通过脚本生成的事件。<br><br>- &gt; 对于来自真实用户操作的事件，<span class="hljs-keyword">event</span>.isTrusted 属性为 <span class="hljs-literal">true</span>，<br>  &gt;<br>  &gt; 对于脚本生成的事件，<span class="hljs-keyword">event</span>.isTrusted 属性为 <span class="hljs-literal">false</span><br><br>  <br>  <br>- 对于UI事件, 像 MouseEvent 和 KeyboardEvent ,如果我们想要创建这样的事件，我们应该使用它们而不是 `<span class="hljs-keyword">new</span> Event`。例如，`<span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">&quot;click&quot;</span>)`。<br><br>- &gt; 正确的构造器允许为该类型的事件指定标准属性。就像鼠标事件的 `clientX/clientY` 一样：<br>  &gt;<br>  &gt; ```javascript<br>  &gt; <span class="hljs-keyword">let</span> <span class="hljs-keyword">event</span> = <span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">&quot;click&quot;</span>, <br>  &gt;         &#123;<br>  &gt;          bubbles: <span class="hljs-literal">true</span>, <br>  &gt;          cancelable: <span class="hljs-literal">true</span>,  <br>  &gt;          clientX: <span class="hljs-number">100</span>,  <br>  &gt;          clientY: <span class="hljs-number">100</span> <br>  &gt;         &#125;);<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>对于我们自己的全新事件类型，例如 “hello”，我们应该使用 new CustomEvent()。</p></li><li><blockquote><p>从技术上讲，CustomEvent 和 Event 一样。除了一点不同。 在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 detail。以避免与其他事件属性的冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;h1 id=<span class="hljs-string">&quot;elem&quot;</span>&gt;Hello <span class="hljs-keyword">for</span> John!&lt;/h1&gt;<br><br>&lt;script&gt;<br>  <span class="hljs-comment">// 事件附带给处理程序的其他详细信息</span><br>  elem.addEventListener(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>    alert(event.detail.name);<br>  &#125;);<br><br>  elem.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;hello&quot;</span>, &#123;<br>    detail: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;<br>  &#125;));<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>对于新的，自定义的事件，绝对没有默认的浏览器行为，但是绑定此类事件的代码可能有自己的计划，触发该事件之后应该做什么。</p></li><li><blockquote><p>通过调用 event.preventDefault()，事件处理程序可以发出一个信号，指出这些行为应该被取消。函数结束</p><p>在这种情况下，elem.dispatchEvent(event) 的调用会返回 false</p></blockquote></li></ul><ul><li><p>通常事件是在队列中处理的。根据顺序进行调用</p></li><li><blockquote><p>值得注意的例外情况就是，一个事件是在另一个事件中发起的,例如使用 <code>dispatchEvent</code>。这类事件将会被立即处理</p><p>如果不想改变顺序,可以把另一个触发事件的调用包装到零延迟的 setTimeout 中</p></blockquote></li></ul><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><ul><li><p>此类事件不仅可能来自于“鼠标设备”，还可能来自于对此类操作进行了模拟以实现兼容性的其他设备，例如手机和平板电脑。</p></li><li><p>在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 mousedown → mouseup → click 的顺序调用处理程序。</p><h5 id="键位获取属性"><a href="#键位获取属性" class="headerlink" title="键位获取属性"></a>键位获取属性</h5></li><li><p>event.button 属性 获取鼠标按钮键位 ,左中右键,分别返回0 1 2 …</p></li><li><blockquote><p>旧代码可能会使用event.which属性获取鼠标键盘键位，这是获取按钮的一种旧的非标准方式， 现在不推荐使用(考虑兼容性可以使用)</p></blockquote></li><li><p>所有的鼠标事件都包含有关按下的组合键的信息。事件属性：</p><pre><code>  shiftKey：Shift  altKey：Alt（或对于 Mac 是 Opt）  ctrlKey：Ctrl  metaKey：对于 Mac 是 Cmd</code></pre><h5 id="坐标获取属性"><a href="#坐标获取属性" class="headerlink" title="坐标获取属性"></a>坐标获取属性</h5></li><li><p>所有的鼠标事件都提供了两种形式的坐标：</p><pre><code>  相对于窗口(浏览器内)的坐标：clientX 和 clientY。  相对于文档的坐标：pageX 和 pageY。  相对于屏幕的坐标 :ScreenX ScreenY</code></pre></li><li><p>如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：oncopy。return false</p></li><li><p>如何防止 ,鼠标左键不松情况的文本选择,最合理的方式是防止浏览器对 <code>mousedown</code> 进行操作,mousedown事件返回false</p><h5 id="移动鼠标事件"><a href="#移动鼠标事件" class="headerlink" title="移动鼠标事件"></a>移动鼠标事件</h5></li><li><p>对于 mouseover：</p><pre><code>  event.target —— 是鼠标移过的那个元素。  event.relatedTarget —— 是鼠标来自的那个元素（relatedTarget → target）。</code></pre></li><li><p>mouseout 则与之相反：</p><pre><code>  event.target —— 是鼠标离开的元素。  event.relatedTarget —— 是鼠标移动到的，当前指针位置下的元素（target → relatedTarget）</code></pre></li><li><blockquote><p>relatedTarget 属性可以为 null。这是正常现象，仅仅是意味着鼠标不是来自另一个元素，而是来自窗口之外。或者它离开了窗口。</p></blockquote></li><li><h5 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a><strong>跳过元素</strong></h5></li><li><p>当鼠标移动时，就会触发 mousemove 事件。但这并不意味着每个像素都会导致一个事件。如果访问者非常快地移动鼠标，那么某些 DOM 元素就可能被跳过：</p></li><li><blockquote><p>这对性能很有好处，因为可能有很多中间元素。我们并不真的想要处理每一个移入和离开的过程</p><p>但是如果mouseover 被触发了，则必须有 mouseout事件</p></blockquote></li></ul><ul><li><p>鼠标转到另一个元素（甚至是一个后代），那么它将离开前一个元素,所以当鼠标指针从元素移动到其后代时触发 mouseout 事件</p><blockquote><p>如果离开父元素时有一些行为，当鼠标指针深入子元素时，我们并不希望发生这种行为。</p><p>我们可以在mouseout 处理程序中检查<code> relatedTarget</code>，如果鼠标指针仍在元素内，则忽略此类事件, 在处理程序中return结束处理 。</p></blockquote></li><li><p>事件 mouseenter 和 mouseleave</p><blockquote><p>元素内部与后代之间的转换不会产生影响。当鼠标移入更深入的子元素时，不会触发离开父元素的事件<br>事件 mouseenter/mouseleave 不会冒泡。（因为不会冒泡所以不能事件委托）</p></blockquote></li></ul><h5 id="鼠标拖放事件"><a href="#鼠标拖放事件" class="headerlink" title="鼠标拖放事件"></a>鼠标拖放事件</h5><ul><li><p>在现代 HTML 标准中有一个 关于拖放的部分，其中包含了例如 dragstart 和 dragend 等特殊事件</p></li><li><blockquote><p> 原生的拖放事件也有其局限性。例如，我们无法阻止从特定区域的拖动。并且，我们无法将拖动变成“水平”或“竖直”的。还有很多其他使用它们无法完成的拖放任务。并且，移动设备对此类事件的支持非常有限。</p></blockquote></li><li><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DragEvent">MDN</a>原生拖放事件</p></li></ul><ul><li><p>基础的拖放算法 ： mousedown  mousemove  mouseup</p></li><li><blockquote><p>我们在 document 上跟踪 mousemove，而不是在 ball 上 因为在快速移动鼠标后，鼠标指针可能会从球上跳转至文档中间的某个位置（甚至跳转至窗口外）。</p></blockquote></li><li><blockquote><p>因为浏览器有自己的对图片和一些其他元素的拖放处理。它会在我们进行拖放操作时自动运行，并与我们的拖放处理产生了冲突。 解决冲突 ： ball.ondragstart = function() { return false;};</p></blockquote></li></ul><ul><li>潜在的放置目标: 在实际中，我们通常是将一个元素放到另一个元素上,当我们拖动时，可拖动元素一直是位于其他元素上的。而鼠标事件只发生在顶部元素上，而不是发生在那些下面的元素。所以无法使用鼠标事件实现</li><li><blockquote><p>使用 document.elementFromPoint 检测鼠标指针下的 “droppable” 的元素</p></blockquote></li><li><blockquote><p>document.elementFromPoint(clientX, clientY) 的方法。它会返回在给定的窗口相对坐标处的嵌套的最深的元素</p></blockquote></li></ul><h5 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h5><ul><li><p>指针事件是一种现代方式，可以处理来自各种指针设备（例如鼠标，钢笔/手写笔，触摸屏等）的输入。</p></li><li><blockquote><p>待扩展…</p></blockquote></li></ul><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><ul><li><p>当一个按键被按下时，会触发 <strong>keydown</strong> 事件，而当按键被释放时，会触发 <strong>keyup</strong> 事件。</p></li><li><blockquote><p>如果按下一个键足够长的时间，它就会开始“自动重复”：keydown 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 keyup。因此，有很多 keydown 却只有一个 keyup 是很正常的。</p><p>对于由自动重复触发的事件，event 对象的 event.repeat 属性被设置为 true。 是一个只读属性</p></blockquote></li><li><p><strong>event.code 和 event.key</strong> </p></li><li><blockquote><p>事件对象的 key 属性允许获取按键的字符，</p><p>事件对象的 code 属性则允许获取“物理按键代码”。 </p></blockquote></li></ul><ul><li><p> 物理按键代码</p><blockquote><p>  字符键的代码为 “Key<letter>“：”KeyA”，”KeyB” 等。 大小写敏感：”KeyZ”，不是 “keyZ”<br>  数字键的代码为：”Digit<number>“：”Digit0”，”Digit1” 等。<br>   特殊按键的代码为按键的名字：”Enter”，”Backspace”，”Tab” 等。</p></blockquote></li><li><p>选择按键处理方式 :</p></li><li><blockquote><p>例如有些键盘布局不同,但我们只绑定按到”z”键才触发,不管键盘怎样布局 —- 使用event.key</p><p>就算键盘布局不同, 只要物理位置正确,无所谓是不是按到”z”,都可以执行  —- 使用event.code</p></blockquote></li></ul><ul><li><p>阻止对 keydown 的默认行为可以取消大多数的网页行为</p></li><li><blockquote><p>keydown的默认行为:</p><p>出现在屏幕上的一个字符（最明显的结果）。</p><p>一个字符被删除（Delete 键）。</p><p>滚动页面（PageDown 键）。</p><p>浏览器打开“保存页面”对话框（Ctrl+S）</p></blockquote><ul><li>过去曾经有一个 keypress 事件，还有事件对象的 keyCode、charCode 和 which 属性。大多数浏览器对它们都存在兼容性问题，现在不再使用</li></ul><blockquote><p>以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。</p></blockquote></li></ul><h5 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h5><ul><li><p>scroll 事件允许对页面或元素滚动作出反应</p></li><li><p>我们如何使某些东西变成不可滚动？</p><blockquote><p>我们不能通过在 onscroll 监听器中使用 event.preventDefault() 来阻止滚动，因为它会在滚动发生之后才触发。</p><p>但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 keydown 事件上，使用 event.preventDefault() 来阻止滚动。</p></blockquote></li><li><p>通过设置 overflow 可以控制页面滚动 不滚动</p></li></ul><h4 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h4><h5 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a>表单属性和方法</h5><ul><li><p>表单（form）以及例如 input 的控件（control）元素有许多特殊的属性和事件。</p></li><li><blockquote><p>获得文档中的表单:</p><p>document.forms.name      name: 表单的name属性</p><p>document.forms[0]             文档中第一个表单</p></blockquote></li><li><blockquote><p>获得表单中的元素</p><p>form.elements.name      name : 表单中空间的name属性 </p><p>form.elements[0]            表单中第一个</p><p>可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现,在这种情况下，form.elements[name] 将会是一个集合，</p></blockquote></li></ul><ul><li><p>&lt; fieldset&gt; 元素。它们也具有 elements 属性，通过<em>form.elements.name</em> 获得</p></li><li><p>我们可以将 form.elements.login 写成 form.login 或者 form[login]</p></li><li><blockquote><p>这样写会有一个小问题 , 如果我们访问一个元素，然后修改它的 name，之后它仍然可以被通过旧的 name 访问到（当然也能通过新的 name 访问） </p><p>但是通过 form.elements 来调用只能使用新名字</p></blockquote></li></ul><ul><li><p><strong>反向引用</strong> : </p></li><li><blockquote><p>表单引用了所有元素，元素也引用了表单</p><p>其对应的表单都可以通过 <code>element.form</code> 访问到    element :表单内元素</p></blockquote></li><li><p><strong>表单控件</strong>: </p></li><li><blockquote><p>我们可以通过 <code>input.value</code>（字符串）或 <code>input.checked</code>（布尔值）来访问复选框（checkbox）中的它们的 <code>value</code>。</p><p>使用 textarea.value 访问而不是textarea.innerHTML</p></blockquote></li><li><p>select 和 option: </p><pre><code>  select.options —— &lt;option&gt; 的子元素的集合，  select.value —— 当前所选择的 &lt;option&gt; 的 value，  select.selectedIndex —— 当前所选择的 &lt;option&gt; 的编号。  设置选中状态,改变value值 :  找到对应的 &lt;option&gt; 元素，并将 option.selected 设置为 true。  将 select.value 设置为对应的 value。  将 select.selectedIndex 设置为对应 &lt;option&gt; 的编号。</code></pre></li><li><blockquote><p>如果 <select> 具有 multiple 特性（attribute），则允许多选。这个功能很少使用。在这种情况下，我们需要使用第一种方式：从 <option> 的子元素中添加/移除 selected 属性</p></blockquote></li><li><p>有一个很好的简短语法可以创建 <option> 元素：option = new Option(text, value, defaultSelected, selected);</p></li><li><blockquote><p>text —— <option> 中的文本，</p><p>value —— <option> 的 value，  </p><p>defaultSelected —— 如果为 true，那么 selected HTML-特性（attribute）就会被创建，  </p><p>selected —— 如果为 true，那么这个 <option> 就会被选中</p></blockquote></li></ul><ul><li><option> 元素具有以下属性：<pre><code>  option.selected :  &lt;option&gt; 是否被选择。  option.index : &lt;option&gt; 在其所属的 &lt;select&gt; 中的编号。  option.text  : &lt;option&gt; 的文本内容（可以被访问者看到）。</code></pre></li></ul><h5 id="表单事件-聚焦"><a href="#表单事件-聚焦" class="headerlink" title="表单事件 聚焦"></a>表单事件 聚焦</h5><ul><li><p>当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus）。当网页加载时，HTML-特性（attribute）autofocus 也可以让一个焦点落在元素上</p></li><li><p><strong>focus/blur 事件  focus/blur 方法</strong> </p></li><li><blockquote><p>elem.focus() 和 elem.blur() 方法可以设置和移除元素上的焦点。</p><p>请注意，我们无法通过在 onblur 事件处理程序中调用 event.preventDefault() 来“阻止失去焦点”，因为 onblur 事件处理程序是在元素失去焦点 之后 运行的。</p></blockquote><p><strong>不适用情况:</strong></p></li><li><p>默认情况下，很多元素不支持聚焦。列表（list）在不同的浏览器表现不同，但有一件事总是正确的：focus/blur 保证支持那些用户可以交互的元素：<button>，<input>，<select>，<a> 等。</p></li><li><p>另一方面，为了格式化某些东西而存在的元素像 <div>，<span> 和 <table> —— 默认是不能被聚焦的。elem.focus() 方法不适用于它们，并且 focus/blur 事件也绝不会被触发。</p></li></ul><ul><li><p>使用 HTML特性 tabindex可以允许在任何元素上聚焦</p></li><li><blockquote><p>任何具有 <code>tabindex</code> 特性的元素，都会变成可聚焦的。该特性的 <code>value</code> 是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号。</p><p> 值为-1 元素被忽略   = 0 默认排在最后</p><p>.tabIndex 有对应的DOM属性</p></blockquote></li></ul><ul><li><p><strong>focus/blur 委托 : focus 和 blur 事件不会向上冒泡</strong></p></li><li><blockquote><p>解决方法 : </p><p>方案一，有一个遗留下来的有趣的特性（feature）：focus/blur 不会向上冒泡，但会在捕获阶段向下传播。</p><p>方案二，可以使用 focusin 和 focusout 事件 —— 与 focus/blur 事件完全一样，只是它们会冒泡。必须使用 elem.addEventListener 来分配它们，而不是 on<event>。</p></blockquote></li><li><p>可以通过 <code>document.activeElement </code>来获取当前所聚焦的元素。</p></li></ul><h5 id="事件：change，input，cut，copy，paste"><a href="#事件：change，input，cut，copy，paste" class="headerlink" title="事件：change，input，cut，copy，paste"></a>事件：change，input，cut，copy，paste</h5><ul><li><blockquote><p>当元素更改完成时，将触发 change 事件。</p><p>对于文本输入框，当其失去焦点时，就会触发 change 事件</p></blockquote></li><li><p>每当用户对输入值进行修改后，就会触发 input 事件。</p></li><li><blockquote><p>如果我们想要处理对 &lt; input&gt; 的每次更改，那么此事件是最佳选择。  </p><p><strong>无法阻止</strong> <code>oninput</code>事件 :当输入值更改后，就会触发 input 事件。我们无法使用 event.preventDefault() —— 已经太迟了，不会起任何作用了。</p></blockquote></li><li><p>剪切/拷贝/粘贴 : cut，copy，paste</p></li><li><blockquote><p>它们属于 ClipboardEvent 类，并提供了对拷贝/粘贴的数据的访问方法。我们也可以使用 event.preventDefault() 来中止行为，然后什么都不会被复制/粘贴</p></blockquote></li></ul><h5 id="表单：事件和方法提交"><a href="#表单：事件和方法提交" class="headerlink" title="表单：事件和方法提交"></a>表单：事件和方法提交</h5><ul><li><p>提交表单时，会触发 submit 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。</p></li><li><blockquote><p>如果要手动将表单提交到服务器，我们可以调用 form.submit()。这样就不会产生 submit 事件。我们可以动态地创建表单，使用该方法将其发送到服务器。</p></blockquote></li></ul><ul><li><p>提交表单主要有两种方式：</p></li><li><blockquote><ul><li><p>第一种 —— 点击 &lt; input type=”submit”&gt; 或 &lt; input type=”image”&gt;。</p></li><li><p>第二种 —— 在 input 字段中按下 Enter 键。</p></li></ul><ul><li>这两个行为都会触发表单的 submit 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用 event.preventDefault()，这样表单就不会被发送到服务器了。</li></ul></blockquote></li></ul><blockquote><p>在输入框中使用 Enter 发送表单时，会在 &lt; input type=”submit”&gt; 上触发一次 click 事件</p></blockquote><h4 id="加载文档-和资源"><a href="#加载文档-和资源" class="headerlink" title="加载文档 和资源"></a>加载文档 和资源</h4><h5 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h5><ul><li><p>HTML 页面的生命周期包含三个重要事件：</p><pre><code>  DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 &lt;img&gt; 和样式表之类的外部资源可能尚未加载完成。  load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。  beforeunload/unload —— 当用户正在离开页面时。</code></pre></li><li><p>每个事件都是有用的：</p></li><li><blockquote><p>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。<br> load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。<br> beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。<br> unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</p></blockquote></li><li><p>**DOMContentLoaded **</p></li><li><p>DOMContentLoaded 事件发生在 document 对象上。我们必须使用 addEventListener 来捕获它,不能使用on<event></p></li></ul><ul><li>当浏览器处理一个 HTML 文档，并在文档中遇到 <script> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，<strong>所以 DOMContentLoaded 必须等待脚本执行结束。</strong></li></ul><ul><li><p><code>DOMContentLoaded</code> 不会等待样式表, 但是如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成, </p></li><li><blockquote><p>原因: 脚本可能想要获取元素的坐标和其他与样式相关的属性, 脚本等待样式表,<code>DOMContentLoaded</code> 等待脚本</p></blockquote></li></ul><p>  例外 :</p><blockquote><p>具有 async 特性（attribute）的脚本不会阻塞 DOMContentLoaded，稍后 我们会讲到。</p><p>使用 document.createElement(‘script’) 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded。</p></blockquote><ul><li>Firefox，Chrome 和 Opera 都会在 <code>DOMContentLoaded</code> 中自动填充表单。</li></ul><ul><li><p><strong>load /unload/beforeunload事件</strong>:</p></li><li><p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件.</p></li><li><p>当访问者离开页面时，window 对象上的 unload 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。 发送分析数据。</p></li><li><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将要求进行更多确认。 如果我们要取消事件，浏览器会询问用户是否确定。</p></li><li><blockquote><p>window.onbeforeunload = function() {  return false; };</p></blockquote></li></ul><ul><li><p><strong>document.readyState 属性</strong>: 提供当前加载状态的信息。</p><pre><code>  loading —— 文档正在被加载。  interactive —— 文档被全部读取。  complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</code></pre></li><li><blockquote><p>还有一个 readystatechange 事件，会在状态发生改变时触发</p></blockquote></li></ul><h5 id="脚本：async，defer"><a href="#脚本：async，defer" class="headerlink" title="脚本：async，defer"></a>脚本：async，defer</h5><ul><li><p>当浏览器加载 HTML 时遇到 <script>...</script> 标签，浏览器就不能继续构建 DOM。对于外部脚本 <script src="..."></script> 也是一样的.</p></li><li><blockquote><p>这会导致两个重要的问题：</p><p>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</p><p>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容：</p></blockquote><p>解决方法: </p></li><li><blockquote><p>例如，我们可以把脚本放在页面底部, 但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。</p><p>对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p><p>使用 defer async解决</p></blockquote></li></ul><ul><li><p><strong>defer 和 async</strong></p></li><li><p>defer 特性告诉浏览器它应该继续处理页面，并“在后台”下载脚本，然后等页面加载完成后，再执行此脚本。</p></li><li><blockquote><p>具有 defer 特性的脚本不会阻塞页面, 等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。</p></blockquote></li><li><p>具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。 多个脚本下载时,并行下载,按顺序执行,如果我们有一个长脚本在前，一个短脚本在后，那么后者就会等待前者执行</p></li><li><p><strong>defer 特性仅适用于外部脚本</strong>, 如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>defer</code> 特性。</p></li></ul><ul><li><p><strong>async 特性意味着脚本是完全独立的</strong>：</p></li><li><blockquote><p>页面不会等待异步脚本，它会继续处理并显示页面内容。</p><p>DOMContentLoaded 和async异步脚本不会彼此等待：DOMContentLoaded可能会发生在异步脚本之前也可能在后面发生</p><p>其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本, 如果我们有几个 async 脚本，它们可能按任意次序执行。总之是先加载完成的就先执行</p></blockquote></li><li><p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p></li><li><p><strong>动态脚本</strong> : </p></li><li><blockquote><p>使用 JavaScript 动态地添加脚本：默认情况下，动态脚本的行为是“异步”的。</p><p>它们不会等待任何东西，也没有什么东西会等它们。  先加载完成的脚本先执行（“加载优先”顺序）。</p></blockquote></li><li><blockquote><p>我们可以通过将 async 特性显式地修改为 false，以将脚本的加载顺序更改为文档顺序（就像常规脚本一样）</p></blockquote></li></ul><h5 id="资源加载：onload，onerror"><a href="#资源加载：onload，onerror" class="headerlink" title="资源加载：onload，onerror"></a>资源加载：onload，onerror</h5><ul><li><p>浏览器通过load 和 error 事件,允许我们跟踪外部资源的加载  —— 脚本，iframe，图片等。基本上（basically）适用于具有外部 src 的任何资源。</p></li><li><blockquote><p>唯一的例外是 <iframe>：出于历史原因，不管加载成功还是失败，即使页面没有被找到，它都会触发 load 事件。</p></blockquote></li><li><p> onload —— 成功加载，     onerror —— 出现 error。</p></li><li><blockquote><p>我们需要加载第三方脚本时,使用 onload事件,在成功加载时执行,失败时执行 onerror</p></blockquote></li><li><blockquote><p>onload/onerror 事件仅跟踪加载本身。也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件。如果要跟踪脚本 error，可以使用 window.onerror 全局处理程序。</p></blockquote></li></ul><ul><li><p><strong>跨源策略</strong> : 这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。更确切地说，一个源（域/端口/协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。</p></li><li><p>如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。(如果想要获取到就必须允许跨源访问)</p></li><li><blockquote><p>对其他类型的资源也执行类似的跨源策略（CORS）。</p></blockquote></li></ul><ul><li><p>要允许跨源访问，<script> 标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">无 crossorigin 特性 —— 禁止访问。<br><br>crossorigin=<span class="hljs-string">&quot;anonymous&quot;</span> —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header Access-Control-Allow-Origin，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。<br><br>crossorigin=<span class="hljs-string">&quot;use-credentials&quot;</span> —— 如果服务器发送回带有我们的源的 header   <br>Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials: <span class="hljs-literal">true</span>，则允许访问浏览器会将授权信息和 cookie 发送到远程服务器。<br></code></pre></td></tr></table></figure></li></ul><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li><h5 id="DOM-变动观察器（Mutation-observer）"><a href="#DOM-变动观察器（Mutation-observer）" class="headerlink" title="DOM 变动观察器（Mutation observer）:"></a>DOM 变动观察器（Mutation observer）:</h5></li><li><blockquote><p> MutationObserver 是一个内建对象，它观察 DOM 元素，在其发生更改时触发回调。</p><p><code>MutationObserver</code> 可以对 DOM 的变化作出反应：特性（attribute），添加/删除的元素，文本内容。</p><p>我们可以用它来跟踪代码其他部分引入的更改，以及与第三方脚本集成</p></blockquote><p>语法: </p></li><li><blockquote><p>let observer = new MutationObserver(callback);  创建一个带有回调函数的观察器</p><p>observer.observe(node, config);   将其附加到一个 DOM 节点</p></blockquote></li><li><p>用于集成 : 你需要添加一个第三方脚本，该脚本不仅包含有用的功能，还会执行一些我们不想要的操作，例如显示广告 <div class="ads">Unwanted ads</div>。当然，第三方脚本没有提供删除它的机制。使用 MutationObserver，我们可以监测到我们不需要的元素何时出现在我们的 DOM 中，并将其删除</p></li><li><p>我们可以使用 <code>MutationObserver</code> 来自动检测何时在页面中插入了代码段，并高亮显示之它们</p></li></ul><h5 id="选择（Selection）和范围（Range）"><a href="#选择（Selection）和范围（Range）" class="headerlink" title="选择（Selection）和范围（Range）"></a>选择（Selection）和范围（Range）</h5><ul><li>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本,如果按下鼠标左键，并在不松开的情况下移动鼠标，这也常常会造成不必要的选择。有多种防止选择的方法.</li></ul><ul><li><p>Range 是用于管理选择范围的通用对象。我们可能会创建此类对象，并传递它们 —— 它们在视觉上不会自行选择任何内容。</p></li><li><blockquote><p>let range = new Range();</p></blockquote></li><li><p>range 对象具有以下属性：</p><pre><code>  startContainer，startOffset —— 起始节点和偏移量，  endContainer，endOffset —— 结束节点和偏移量，  collapsed —— 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 true，  commonAncestorContainer —— 在范围内的所有节点中最近的共同祖先节点，</code></pre></li></ul><ul><li><p>设置范围的起点：</p><pre><code>  setStart(node, offset) 将起点设置在：node 中的位置 offset  setStartBefore(node) 将起点设置在：node 前面  setStartAfter(node) 将起点设置在：node 后面  设置范围的终点（类似的方法）：  setEnd(node, offset) 将终点设置为：node 中的位置 offset  setEndBefore(node) 将终点设置为：node 前面  setEndAfter(node) 将终点设置为：node 后面  如前所述，node 既可以是文本节点，也可以是元素节点：对于文本节点，offset 偏移的是字符数，而对于元素节点则是子节点数。  其他：  selectNode(node) 设置范围以选择整个 node  selectNodeContents(node) 设置范围以选择整个 node 的内容          collapse(toStart) 如果 toStart=true 则设置 end=start，否则设置 start=end，从而折叠范围  cloneRange() 创建一个具有相同起点/终点的新范围  如要操纵范围内的内容：  deleteContents() —— 从文档中删除范围内容  extractContents() —— 从文档中删除范围内容，并将删除的内容作为 DocumentFragment 返回  cloneContents() —— 复制范围内容，并将复制的内容作为 DocumentFragment 返回  insertNode(node) —— 在范围的起始处将 node 插入文档  surroundContents(node) —— 使用 node 将所选范围内容包裹起来。要使此操作有效，则该范围必须包含其中所有元素的开始和结束标签：不能像 &lt;i&gt;abc 这样的部分范围。</code></pre></li></ul><ul><li><p>文档选择是由 Selection 对象表示的，可通过 window.getSelection() 或 document.getSelection() 来获取。</p></li><li><p>选择属性 :</p><pre><code>  anchorNode —— 选择的起始节点，  anchorOffset —— 选择开始的 anchorNode 中的偏移量，  focusNode —— 选择的结束节点，  focusOffset —— 选择开始处 focusNode 的偏移量，  isCollapsed —— 如果未选择任何内容（空范围）或不存在，则为 true 。  rangeCount —— 选择中的范围数，除 Firefox 外，其他浏览器最多为 1。</code></pre></li><li><p>在文档中，选择的终点可能在起点之前</p></li><li><p>选择获取 : </p><pre><code>  作为文本：只需调用 document.getSelection().toString()。  作为 DOM 节点：获取底层的（underlying）范围，并调用它们的 cloneContents() 方法（如果我们不支持  Firefox 多选的话，则仅取第一个范围）。</code></pre></li><li><p>选择事件 : 有一些事件可以跟踪选择：</p><pre><code>  elem.onselectstart —— 当选择从 elem 上开始时，例如，用户按下鼠标键并开始移动鼠标。  阻止默认行为会使选择无法开始。  document.onselectionchange —— 当选择变动时。  请注意：此处理程序只能在 document 上设置。</code></pre></li><li><p>选择方法 :</p><pre><code>  getRangeAt(i) —— 获取从 0 开始的第 i 个范围。在除 Firefox 之外的所有浏览器中，仅使用 0。  addRange(range) —— 将 range 添加到选择中。如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用。  removeRange(range) —— 从选择中删除 range。  removeAllRanges() —— 删除所有范围。  empty() —— removeAllRanges 的别名。  外，还有一些方便的方法可以直接操作选择范围，而无需使用 Range：  collapse(node, offset) —— 用一个新的范围替换选定的范围，该新范围从给定的 node 处开始，到偏移    offset 处结束。  setPosition(node, offset) —— collapse 的别名。  collapseToStart() —— 折叠（替换为空范围）到选择起点，  collapseToEnd() —— 折叠到选择终点，  extend(node, offset) —— 将选择的焦点（focus）移到给定的 node，位置偏移 oofset，  setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) —— 用给定的起点      anchorNode/anchorOffset 和终点 focusNode/focusOffset 来替换选择范围。选中它们之间的所有内容。  selectAllChildren(node) —— 选择 node 的所有子节点。  deleteFromDocument() —— 从文档中删除所选择的内容。  containsNode(node, allowPartialContainment = false) —— 检查选择中是否包含 node（特别是如果第二个参数是 true 的话）</code></pre></li></ul><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection">https://developer.mozilla.org/zh-CN/docs/Web/API/Selection</a></p></li><li><p>对于许多任务，我们可以调用 Selection 方法，而无需访问底层的（underlying）Range 对象。</p></li><li><p>如要选择，请先移除现有的选择<br>如果选择已存在，则首先使用 removeAllRanges() 将其清空。然后添加范围。否则，除 Firefox 外的所有浏览器都将忽略新范围。</p></li><li><p>表单控件中的选择 :</p></li><li><p>诸如 input 和 textarea 等表单元素提供了 专用的选择 API，没有 Selection 或 Range 对象。由于输入值是纯文本而不是 HTML，因此不需要此类对象，一切都变得更加简单。</p><pre><code>  input.selectionStart —— 选择的起始位置（可写），  input.selectionEnd —— 选择的结束位置（可写），  input.selectionDirection —— 选择方向，其中之一：“forward”，“backward” 或 “none”（例如使用鼠标双击进行的选择），  事件：  input.onselect —— 当某个东西被选择时触发。  方法：  input.select() —— 选择文本控件中的所有内容（可以是 textarea 而不是 input），  input.setSelectionRange(start, end, [direction]) —— 在给定方向上（可选），从 start 一直选择到 end。  input.setRangeText(replacement, [start], [end], [selectionMode]) —— 用新文本替换范围中的文本。  可选参数 start 和 end，如果提供的话，则设置范围的起点和终点，否则使用用户的选择。  最后一个参数 selectionMode 决定替换文本后如何设置选择。可能的值为：  &quot;select&quot; —— 将选择新插入的文本。  &quot;start&quot; —— 选择范围将在插入的文本之前折叠（光标将在其之前）。  &quot;end&quot; —— 选择范围将在插入的文本之后折叠（光标将紧随其后）。  &quot;preserve&quot; —— 尝试保留选择。这是默认值。</code></pre></li><li><blockquote><p>onselect 是在某项被选择时触发，而在选择被删除时不触发。根据 规范，发表单控件内的选择不应该触发 document.onselectionchange 事件，因为它与 document 选择和范围不相关。一些浏览器会生成它，但我们不应该依赖它。</p></blockquote></li></ul><ul><li><p>要使某些内容不可选，有三种方式：</p></li><li><blockquote><p>使用 CSS 属性 user-select: none。</p><p>防止 onselectstart 或 mousedown 事件中的默认行为。 这样可以防止在 elem 上开始选择，但是访问者可以在另一个元素上开始选择，然后扩展到 elem。</p><p>我们还可以使用 document.getSelection().empty() 来在选择发生后清除选择。很少使用这种方法，因为这会在选择项消失时导致不必要的闪烁。</p></blockquote></li></ul><ul><li>关于光标。在诸如 <textarea> 之类的可编辑元素中，光标的位置始终位于选择的起点或终点。我们可以通过设置 elem.selectionStart 和 elem.selectionEnd 来获取光标位置或移动光标。</li></ul><h5 id="事件循环-微任务-宏任务"><a href="#事件循环-微任务-宏任务" class="headerlink" title="事件循环  微任务 宏任务"></a>事件循环  微任务 宏任务</h5><ul><li><p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。</p></li><li><p>事件循环的概念:  </p></li><li><blockquote><p>它是一个在 JavaScript 引擎等待任务，<strong>执行任务</strong> 和 <strong>进入休眠状态</strong>  <strong>等待更多任务</strong>  这几个状态之间转换的无限循环。</p></blockquote></li><li><p>多个任务组成了一个队列，即所谓的“宏任务队列”</p></li><li><blockquote><p>队列中的任务基于“先进先出”的原则执行</p><p>引擎执行任务时永远不会进行渲染（render）,仅在任务完成后才会绘制对 DOM 的更改。</p><p>如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，无法处理用户事件，因此，在一定时间后浏览器会在整个页面抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</p></blockquote><p><strong>微任务:</strong></p></li><li><p>微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。</p></li><li><p>还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行。</p></li><li><blockquote><p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</p></blockquote></li></ul><ul><li><p>安排（schedule）一个新的 宏任务：用零延迟的 setTimeout(f)。</p></li><li><p>安排一个新的 微任务：使用 queueMicrotask(f)。 promise 处理程序也会通过微任务队列。</p></li><li><blockquote><p>在微任务之间没有 UI 或网络事件的处理：微任务之间它们一个立即接一个地执行。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jsDOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery API</title>
    <link href="/2021/02/21/Md%20jQuery/jquery%20%E6%8B%BE%E5%BF%86/"/>
    <url>/2021/02/21/Md%20jQuery/jquery%20%E6%8B%BE%E5%BF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Jquery-API-解释"><a href="#Jquery-API-解释" class="headerlink" title="Jquery API 解释"></a>Jquery API 解释</h3><h4 id="选择器过滤"><a href="#选择器过滤" class="headerlink" title="选择器过滤"></a>选择器过滤</h4><ul><li><p>.last()  获取匹配元素集合中最后一个元素 和:last 相同。  :last-child  判断匹配到的元素是否是其父元素的最后一个子元素  </p></li><li><p>:selected 选取select 中被选取的元素</p></li><li><p>:even 从0开始算</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4></li><li><p>add() 添加元素到匹配的元素集合。  addback([ selector]) 添加<strong>当前堆栈中</strong>元素<strong>集合</strong>到当前集合 ,(选择器可以筛选出之前堆栈内容 之后添加到当前集合)</p></li><li><blockquote><p>在end addback中的堆栈操作解释 : 每次遍历方法都会找到新的元素,这些新的元素构成一个jq对象压入堆栈</p></blockquote></li><li><p>end() addback()都是通过堆栈来实现的,end终止在当前链的过滤操作,返回匹配的元素的以前状态,本质使用了出栈操作,返回原来的一个状态</p></li><li><p>closest() 从元素本身开始，逐级向上找到符合条件的第一个元素，该元素可能是当前元素自身，也可能是最靠近当前元素的一个祖先元素。</p></li><li><p>has() 筛选相匹配的元素,如果符合条件就留下来,最后返回一个集合    not() 通过条件筛选,符合条件的去除 和has 相反</p></li><li><p> is()判断当前元素,返回布尔值</p></li><li><p>map(callback)  用于处理当前jQuery对象匹配的所有元素，并将处理结果封装为新的jq数组 </p></li><li><blockquote><p>特别适用于获取或设置元素集合中的值</p></blockquote></li><li><p>.slice(start [, end )  根据指定的下标范围，过滤匹配的元素集合 (从零开始计数,所以范围是到end-1) </p></li></ul><h4 id="偏移-尺寸"><a href="#偏移-尺寸" class="headerlink" title="偏移 尺寸"></a>偏移 尺寸</h4><ul><li><p>offsetparent() 获得被定位后的祖先元素的top left值,没有就返回undefined</p></li><li><p>position()  获得当前元素针对被定位祖先元素的偏移量 没有就返回针对document的偏移量</p></li><li><blockquote><p>被定位 指的是 position不为static的元素</p></blockquote></li><li><p>指的注意的是 偏移的top left值的计算是不包括margin值,到maigrin的边界的值才是偏移量</p></li><li><p>height() 获取高度值(只包括内容)  </p></li><li><p>innerheight() 获取高度值(包含padding不包含border) outerheight(包括 padding border 参数为true 则包含margin)</p></li></ul><h4 id="DOM操作-css属性-html属性-DOM增删改查"><a href="#DOM操作-css属性-html属性-DOM增删改查" class="headerlink" title="DOM操作 (css属性 html属性 DOM增删改查)"></a>DOM操作 (css属性 html属性 DOM增删改查)</h4><ul><li><p>删除操作</p></li><li><p>empty() 这个方法不仅移除子元素（和其他后代元素),同样移除元素里的文本</p></li><li><p>remove() 和.empty()相似 , 当我们想将元素自身移除时我们用 .remove()</p></li><li><p>detach() 要删除的元素不删除数据和事件的情况下，使用.detach()来代替。 当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。</p></li><li><p>prop()  val() 对表单进行操作 </p></li><li><p>val() 主要用于获取表单元素的值, val()获得value属性内容,对于多选下拉列表则返回一个数组包含每个选择项     通过.val([ “表单value值”])可以设置被选中的状态 (对于select 没有value值的直接写选项中的值也可以被选中)</p></li><li><p>.prop( propertyName, value ) 获取/设置元素的property值(一般我们用在表单属性上,具体参考API)</p></li></ul><ul><li> html() 获取设置匹配元素内部的html内容(设置时会把之前的内容替换掉) </li><li> text() 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代.     可以用来给指定元素设置文本内容(文本内容会替换指定元素里的所有内容)</li></ul><ul><li>DOM 操作分为几类 : 内部/外部添加到前面/后面   调用顺序不同</li></ul><h4 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h4><ul><li><p>.animate() 所有用于动画的属性(设置变化的键值对)必须是数字的，除非另有说明,不要使用css简写属性<br>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。动画属性可以使用 +=</p></li><li><p>精细控制动画  animate 函数 step progress函数使用  : step函数被每个动画元素的每个动画属性调用 ,它接受两个参数（now 和 fx） this是当前正在执行动画的DOM元素集合</p></li><li><blockquote><p>now: 每一步动画属性的数字值 fx: jQuery.fx 原型对象的一个引用 </p></blockquote></li><li><blockquote><p>比如elem 表示前正在执行动画的元素，start和end分别为动画属性的第一个和最后一个的值，prop为进行中的动画属性。</p></blockquote></li><li><p>queue 属性,决定要不要进队列中一个动画接下一个,flase 则是会和下一个动画方法同时发生(前提 : 这些都是连缀书写动画方法)</p></li><li><p>progress函数 每一步动画(step大约13毫秒调用一次,progress相似的方式)完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数</p></li></ul><ul><li><p>.delay()  设置一个延时来推迟执行队列中后续的项  它无法取消延时,不是JavaScript的原生 setTimeout函数的替代品</p></li><li><p>.queue( [queueName ] 默认为fx),显示在匹配元素上已经执行的函数队列 (这里的执行不一定是已经完成了,有时动画可能在队列中排队,完成函数调用就算是执行) ,</p></li><li><p>.queue( [queueName ], newQueue ) newQueue是array类型代表函数数组,用来替换当前队列中的内容,newQueue可以是空的数组 [],可以用来取消队列中不想进行的函数操作  类似 clearQueue()操作</p></li><li><p>.queue( [queueName ], callback( next ) ) 它让我们把新函数置入到队列的末端。为jQuery集合中的每个元素执行一次回调函数。类似在动画方法提供回调函数</p><blockquote><p>当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。 从jQuery 1.4开始，向队列中追加函数时，可以向该函数中传入另一个函数next()</p></blockquote></li></ul><blockquote><p>队列允许一个元素来异步的访问一连串的动作，而不终止程序执行,在执行上一个同时还能继续下个操作,队列存储信息  :$(‘#foo’).slideUp().fadeIn(); ,这个元素开始立即做滑动动画，但渐入动画放置在 fx列队,  所以jq可以执行完slideup还能继续执行渐变, </p></blockquote><ul><li><p>.dequeue()  移除队列中的首个函数, 然后执行这个函数, 这个执行的函数中也应当直接或间接的包含.dequeue()语句，这样才能继续执行队列中的其它函数</p></li><li><p>.clearQueue( [queueName ] )方法被访问的时候，所有在这个列队中未执行的函数将被移除 。当不使用参数的时候，.clearQueue()会从标准的动画队列fx中移除剩下的函数</p></li><li><blockquote><p>这个方法类似.stop(true)。然而.stop()方法只适用在动画中。.clearQueue()还可以用来移除用.queue()方法添加到普通jQuery列表的任何函数。 </p></blockquote></li></ul><ul><li><p>stop()  , 只会停止当前动画,对于队列中的其他动画可以选择停止,stop停止的动画函数,无法执行动画里的回调函数</p></li><li><p>.stop( [clearQueue ] [, jumpToEnd ] ) 默认都为false</p></li><li><p>.stop( [queue ] [, clearQueue ] [, jumpToEnd ] ),还可以选择队列名称</p></li><li><p>finish() 在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值 和.stop(true, true)很相似,但是stop只会把当前的动画跳转到目标值</p></li></ul><blockquote><p>关于动画队列,每个元素维护自己的一个动画队列,不会不同的动画元素放在一起</p></blockquote><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li><p>data() 在匹配元素上存储任意相关数据. .removeData()移除存储数据 通过data()函数存取的数据都是临时数据，一旦页面刷新，之前存放的数据都将不复存在</p></li><li><p>toArry() 返回包含jquery对象的DOM元素数组  get()返回一个对应的DOM元素</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery 基础</title>
    <link href="/2021/02/21/Md%20jQuery/JQuery%20%20%E6%8C%87%E5%AF%BC/"/>
    <url>/2021/02/21/Md%20jQuery/JQuery%20%20%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery-实践"><a href="#jQuery-实践" class="headerlink" title="jQuery 实践"></a>jQuery 实践</h1><ul><li><p>抽象jQuery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax </p></li><li><p>jQuery 总是面向对象,对节点集合可能会进行隐式迭代操作</p></li><li><p>编写程序时要尊重渐进增强,和平稳退化</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li><p>使用jQuery选择器就算获取不到元素也不会报错,传统Dom在获取之前要加上if判断是否存在,需要注意</p><blockquote><p>$()获取的永远是一个对象,就算不存在该元素,所以jQuery通过对象的长度大小.length 属性进行判断是否存在</p></blockquote></li></ul><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ul><li>id 标签名 类名 层次选择器(+ ~ &gt; 后代…)</li><li>表单选择器  :表单标签名字</li></ul><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul><li><p> element[attr] 选中拥有attr属性的元素,可以多选属性 </p></li><li><blockquote><p>可以利用正则表达式进行判断属性 <code>a[href^=&quot;mailto:&quot;]</code> 判断href属性开头含有mailto的元素</p></blockquote></li></ul><h4 id="过滤选择器-自定义选择器"><a href="#过滤选择器-自定义选择器" class="headerlink" title="过滤选择器(自定义选择器)"></a>过滤选择器(自定义选择器)</h4><ul><li><p>过滤选择器又被成为<strong>自定义选择器</strong>, 隶属于jQuery独有的选择器</p></li><li><p>基本过滤器:</p><blockquote><p>  <code>:first </code>选取第一个元素（单个元素）,<code>:last</code><br>  <code>:not(selector)</code> 去除所有与给定选择器匹配的元素,<br>  <code>:even :odd </code>索引从零开始<br> <code> :eq（index）</code> 选取索引等于index的元素,</p><p><code>:gt(index)</code>  大于index <code>:lt(index)：</code>小于<br>  <code>:header</code>  选取所有的标题元素<br>  <code>:animated：</code>选取当前正在执行动画的所有元素<br>  <code>:focus：</code>选取当前获得焦点的元素</p><p>  <code>nth-child() </code>参数可以为数字<br><code> even/odd</code> 表达式  索引从1开始<br>  <code>first-child last-child only-child</code></p></blockquote></li><li><p>内容过滤器 </p><blockquote><p><code>:contains(text)</code> 选取(直接)含有text文本内容的元素,(子元素含有并不算)<br><code> :empty</code>选取内容为空的元素(没有元素节点 没有文本节点)<br><code>:has(selector) </code>选取<strong>含有</strong>指定选择器选定的元素的元素  </p><p> <code> :parent</code> 选取有子元素的元素<br> <code> :visible</code>  选取所有可见的元素<br><code> :hidden</code></p></blockquote></li><li><p>表单选择符</p><blockquote><p><code>:checked :selected :enabled :disabled</code></p></blockquote></li></ul><ul><li>只要可能，jQuery就会使用浏览器原生的DOM选择符引擎去查找元素。但在<br> 使用自定义选择符的时候，就无法使用速度最快的原生方法了。</li></ul><h4 id="Dom遍历方法"><a href="#Dom遍历方法" class="headerlink" title="Dom遍历方法"></a>Dom遍历方法</h4><ul><li>遍历方法提供了筛选 元素的另一种角度, 结合选择器操作可以更好的互补</li></ul><ul><li><blockquote><p><code>find(selector )</code>  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。</p><p><code>.filter()</code> 它除了以上参数,可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中</p></blockquote></li><li><blockquote><p><code>next([selector ]) nextAll()</code> 获得匹配元素集合后面同级的所有元素 ,…all() 返回结果都不包含自己,       </p><p> 对应方法: <code>.prev()和.prevAll()</code></p><p><em>如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。</em></p><p><code>.siblings()</code>  能够选择处于相同DOM层次的所有其他元素</p></blockquote></li><li><blockquote><p><code>.parent( [selector ] )  </code> 取得匹配元素集合中，每个元素的父元素</p><p><code>.children([selector ]) </code>   获得匹配元素集合中每个元素的子元素, 返回结果只包含子元素不包括后代元素</p><p> <code>.contents()</code>  获得元素的子元素包括文字注释节点</p></blockquote></li><li><blockquote><p><code>each()方法</code> 就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次</p><p><code>end() </code>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.</p></blockquote></li><li><blockquote><p>jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]</p></blockquote></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="ready-事件处理程序"><a href="#ready-事件处理程序" class="headerlink" title=".ready()事件处理程序"></a>.ready()事件处理程序</h3><ul><li><p>通过使用$(document).ready()方法，jQuery支持我们预定在DOM加载完毕后调用某个函<br>数，而不必等待页面中的图像加载</p><blockquote><p>简写模式 : $(function(){})</p><p>不使用该方法也可以,但是ready()方法为我们提供了很好的跨浏览器解决方法</p></blockquote></li><li><p>jQuery提供了一个<code>jQuery.noConflict()</code>方法，把对$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,</p><blockquote><p>jQuery(document).ready(function($) {正常使用符号} )  </p><p>简写 : jQuery(function($){})  </p></blockquote></li></ul><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li><p>在事件处理中常用内容:</p><blockquote><p><code>addClass()</code>  为每个匹配的元素添加指定的样式类名</p><p><code>hasClass()</code>   确定任何一个匹配元素是否有被分配给定的类,返回Boolean值</p><p><code>removeClass()</code>  移除集合中每个匹配元素上 一个，多个或全部样式</p><p><code>toggleClass(&quot;类名&quot;)</code> 能够根据相应的类是否存在而添加或删除类</p></blockquote></li></ul><pre><code><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">当触发任何事件处理程序时，关键字<span class="hljs-keyword">this</span>引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象<br><br><span class="hljs-keyword">is</span>() 判断是否为一个选择器 DOM元素...  例如:  .<span class="hljs-keyword">is</span>(<span class="hljs-string">&#x27;:hidden&#x27;</span>) 判断元素是否是可见的<br><br></code></pre></td></tr></table></figure></code></pre><h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><ul><li><p><code>.on(&quot;click&quot;,fn)</code>   参数可以是函数引用或者匿名函数, 还可以用事件名函数绑定  例如.click()  .change()</p><blockquote><p>on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jQuery隐式迭代机制</p></blockquote></li><li><p><code>.one()   </code>处理函数在每个元素上每种事件类型最多执行一次,然后删除自己</p></li><li><blockquote><p><code>trigger()</code>  一次模拟事件的触发  </p><p><code>triggerHandler()</code> 与 .trigger() 相似,不会触发默认行为,不会事件冒泡, 只会对匹配到的第一个元素生效 </p></blockquote></li><li><p>早期版本使用 <code>bind()</code> 进行事件绑定</p><h5 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h5></li><li><p><code>.off(&quot;事件名&quot;)</code>方法移除</p></li><li><p>对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.</p><blockquote><p>例如:  .on(‘click.collapse’,fn);  .off(‘click.collapse’); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的</p></blockquote></li></ul><h5 id="事件传播-冒泡"><a href="#事件传播-冒泡" class="headerlink" title="事件传播(冒泡)"></a>事件传播(冒泡)</h5><ul><li><p>DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,</p></li><li><p>jQuery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。</p></li><li><p>避免事件传播的事件处理</p><blockquote><p><code>hover(fn,fn)</code>函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播<br><code>mouseenter()和mouseleave()</code>，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。</p></blockquote></li><li><p>事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡</p></li></ul><h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><ul><li><p>jQuery对事件对象进行了必要的扩展，从而在任何浏览器中都能够使用这个属性,jQuery提升了兼容性</p></li><li><p>如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false</p><blockquote><p>对于Dom 中 返回 false 只是阻止默认行为</p></blockquote></li></ul><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><ul><li>某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素</li></ul><h2 id="样式与动画"><a href="#样式与动画" class="headerlink" title="样式与动画"></a>样式与动画</h2><h3 id="CSS属性操作"><a href="#CSS属性操作" class="headerlink" title="CSS属性操作"></a>CSS属性操作</h3><ul><li><p>.CSS()方法,用来获取计算后的样式,设置内联样式.</p><blockquote><p><code>获取</code>使用:<br>单个样式属性   传递一个<strong>字符串形式</strong>的属性名，获取字符串形式的属性值,<br>多个样式属性   可以传入属性名的<strong>数组</strong>，得到的则是属性和值构成的对象,对于属性名的格式,可以是驼峰命名或者连字符  </p></blockquote><blockquote><p><code>设置</code>使用:<br>CSS()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值</p><p>另一种是为它传递一个由属性—值对构成的对象</p></blockquote></li><li><p>浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性</p></li></ul><h3 id="效果和时长"><a href="#效果和时长" class="headerlink" title="效果和时长"></a>效果和时长</h3><ul><li><p>隐藏/显示元素:  <code>.hide() .show()</code>   相当于设置display的值   默认是不带动画效果的.</p><blockquote><p>.hide()方法会将匹配的元素集合的内联style属性设置为 display:none。</p><p>但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局</p></blockquote></li><li><p>带动画效果: .hide(‘duration’)   duration:毫秒级   </p><blockquote><p>动画效果-&gt;会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,<br>动画效果有两种预设的速度参数：’slow’和’fast’。也可以自定义指定显示速度. 以下动画效果都可以适用</p></blockquote></li><li><p>淡入和淡出, <code>fadeIn(),fadeOut()</code>  :</p><blockquote><p>改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。</p></blockquote></li><li><p>滑入和滑下, <code>slideDown()和.slideUp() :</code>  改变高度和display的值  </p><blockquote><p>元素本来就处在文档流中,适合使用滑入滑出</p></blockquote></li><li><p>复合效果方法,  <code>slideToggle()</code> ,动画和<code>slideDown(),slideUp()</code>一样   </p><blockquote><p>toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见</p></blockquote><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3></li><li><p>.animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式</p><blockquote><p>第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:</p><p><code>.animate(&#123;property1: &#39;value1&#39;, property2: &#39;value2&#39;&#125;, duration, easing, function() &#123;&#125;)</code></p><p>第二种形式接受两个参数，一个属性对象和一个选项对象:</p><p><code>.animate(&#123; property1: &#39;value1&#39;, property2: &#39;value2&#39; &#125;, </code></p><p><code>&#123; duration: &#39;value&#39;, easing: &#39;value&#39;,</code></p><p><code>specialEasing: &#123; property1: &#39;easing1&#39;, property2: &#39;easing2&#39; &#125;, </code></p><p><code>complete: function() &#123;&#125;, queue: true, step: callback &#125;);</code></p></blockquote></li></ul><ul><li><p>animate()方法最少要有两个参数,属性对象和duration</p><blockquote><p>.animate()方法针对CSS属性提供了方便简写值：<code>&#39;show&#39;、&#39;hide&#39;和&#39;toggle&#39;</code></p><p>例如 : .animate({height: ‘toggle’}, ‘slow’);</p></blockquote></li><li><p>animate()方法中,属性对象中的值如果是 {“height” :”+=value” }表示在原来的基础上再加上value,而不是变化到value</p><h5 id="并发与排队"><a href="#并发与排队" class="headerlink" title="并发与排队"></a>并发与排队</h5></li><li><p>同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.</p><blockquote><p>需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式</p></blockquote></li><li><p>想要同时触发效果,要在一个方法内写多个属性</p></li></ul><ul><li><p>多个元素,应用效果时,这些效果会同时发生,</p><blockquote><p>为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数</p><p>$clickedItem.next().slideDown(‘slow’, function() { $clickedItem.slideUp(‘slow’); }); 先执行外层,在执行回调函数</p></blockquote></li></ul><h5 id="越过队列"><a href="#越过队列" class="headerlink" title="越过队列"></a>越过队列</h5><ul><li>第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始</li><li>对于非效果方法,如.CSS()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序<blockquote><p>解决方法</p><p>1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({background Color:’#f00’});next();}) </p><p>传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码</p></blockquote></li></ul><blockquote><p>2:利用效果方法中的回调函数,在回调函数中书写.CSS(), 在外层函数完成时执行CSS,不需要调用next()</p></blockquote><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><h5 id="HTML-特性操作"><a href="#HTML-特性操作" class="headerlink" title="HTML 特性操作"></a>HTML 特性操作</h5><ul><li><p><code>.attr()</code> 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值</p></li><li><p><code>.removeAttr()方法</code>  删除<em>一个</em>属性</p><blockquote><p>可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:</p><ul><li><pre><code>$(&#39;div.chapter a&#39;).attr(&#123;  title: &#39;Learn more at Wikipedia&#39;,id: function(index, oldValue)&#123; return &#39;wikilink-&#39; + index; &#125;&#125;);这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用</code></pre></li></ul></blockquote><h5 id="DOM-属性"><a href="#DOM-属性" class="headerlink" title="DOM 属性"></a>DOM 属性</h5></li><li><p>在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同</p></li><li><blockquote><p>从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。</p></blockquote></li><li><p>DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性</p><blockquote><p>差别最大的地方是表单控件的属性,不要使用attr(),要使用Val() 获取/设置属性 </p><p> 或者是prop操作DOM属性(这个是要分情况的)</p></blockquote></li><li><p>与.attr()和.prop()一样，.val()方法也可以接受一个函数作为其setter参数</p></li></ul><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul><li><p>创建节点 :  使用$(“”)函数创建节点</p></li><li><p>插入(添加) / 移动节点: </p><blockquote><p><code>内容.insertBefore(&quot;目标&quot;)</code> 在现有元素外部、之前添加内容；</p><p><code>.insertAfter() </code>在现有元素外部、之后添加内容。</p><p><code>.prependTo() </code>  在现有元素内部、之前添加内容；<br><code>.appendTo() </code>     在现有元素内部、之后添加内容；<br>使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了<br>在隐式迭代添加多个节点时,插入顺序<strong>预定义</strong>的,不管是after before,从上到下顺序都是迭代顺序</p></blockquote></li><li><p>反向插入方法 :内容目标的位置颠倒,名字更换了一下</p><blockquote><p><code>append()  prepend()   before()   after()</code></p></blockquote></li></ul><ul><li><p>包裹节点</p><blockquote><p>被包裹的节点 <code>.wrap(&quot;节点&quot;) .wrapAll(&quot;节点&quot;)</code><br>区别:后者在多个节点时,只包裹一次(最外面的节点), 而wrap每个节点都会包装一次</p><p><code>wrapInner()</code>包裹匹配元素的子元素</p></blockquote></li></ul><ul><li><p>复制节点</p><blockquote><p><code>.clone()</code>  在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件</p><p>通过 clone(true) 复制事件处理函数</p></blockquote></li></ul><ul><li><p>删除节点 </p><blockquote><p>从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件</p><p><code>remove(),detach()</code>  两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null </p><p>两者区别: 使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除</p></blockquote></li><li><p><code> empty()</code> 清空节点里的内容(文本 元素节点),</p><blockquote><p><em>注意是节点里的,不是节点本身</em> , 返回一个已经清空的元素</p></blockquote></li></ul><ul><li><p>替换节点(文本/元素)</p><blockquote><p>.html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容</p><p>.text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本<br>.replaceAll(“目标”) 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动<br>.replaceWith(“内容”)   替换集合中所有匹配的元素,返回被删除元素的集合</p></blockquote></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h5 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h5><ul><li><p>jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。</p><pre><code>  &gt; `.ajaxStart()和.ajaxStop()`方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个  &gt; 当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数   &gt; 当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.</code></pre></li><li><p>错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 </p><h5 id="ajax中的常见问题"><a href="#ajax中的常见问题" class="headerlink" title="ajax中的常见问题"></a>ajax中的常见问题</h5></li><li><p>通过Ajax生成页面内容时的一个常见问题:事件绑定丢失</p><blockquote><p>事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。</p><p>解决方法: 每次页面内容更新重新绑定事件      使用事件委托</p></blockquote></li><li><p><code>$.ajaxSetup()</code> 函数可以修改调用Ajax方法时每个选项的默认值。之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，</p></li><li><p>取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式</p></li></ul><h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><ul><li><p>添加新的全局函数, 即jQuery对象的方法</p><blockquote><p><code>$.funcname = func()   </code></p><p><code>$.extend(&#123;funcame:func()&#123;&#125;&#125;)</code></p><p>添加全局函数</p><p>为了避免冲突，最好的办法是把属于一个插件的全局函数都封装到一个对象中</p></blockquote></li><li><p>扩展jQuery对象的方法</p><blockquote><p><code> jQuery.fn.myMethod = function()&#123;&#125;</code> </p><p> jQuery.fn对象是jQuery.prototype的别名</p></blockquote></li><li><p>开发插件注意的问题</p><blockquote><ul><li><p>考虑方法的隐式迭代问题 :  jQuery的选择符表达式可能会匹配零、一或多个元素,</p><blockquote><p>调用.each()方法；这样就会执行隐式迭代 (在调用的.each()方法内部，this依次引用每个DOM元素)</p></blockquote></li><li><p>考虑方法的连缀问题:  函数的返回值要是一个jQuery对象</p></li><li><p>默认参数值, 灵活的参数(传递对象参数) , </p></li></ul></blockquote></li><li><p>利用QUnit等测试框架为自己的插件维护一组自动的单元测试</p></li></ul><h2 id="jQuery进阶内容"><a href="#jQuery进阶内容" class="headerlink" title="jQuery进阶内容"></a>jQuery进阶内容</h2><h5 id="高级遍历"><a href="#高级遍历" class="headerlink" title="高级遍历"></a>高级遍历</h5><ul><li><p>Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。</p><blockquote><p>使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异</p></blockquote></li><li><p>选择符优化问题 自定义选择符</p><blockquote><p>如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器</p></blockquote></li><li><p>DOM遍历背后的原理</p><blockquote><p>向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关</p><p>addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑</p></blockquote></li></ul><ul><li>DOM 遍历的性能问题 : 多使用连缀,和缓存jQuery对象,来最低限度的重复使用选择符和遍历方法</li></ul><h5 id="高级事件处理"><a href="#高级事件处理" class="headerlink" title="高级事件处理"></a>高级事件处理</h5><ul><li><p>早委托 : 选择document作为委托作用域,不必等待Dom完全加载后才进行绑定事件, 通过早委托实现早绑定</p></li><li><p>自定义事件: 通过 on()注册自定义事件, 使用trigger方法进行手动调用, 它只能手动调用</p><blockquote><p>在触发自定义事件时，我们也可以给任何注册的事件处理程序传入额外的信息。这种技术就叫做自定义事件参数, 在trigger调用处理程序时传入参数</p></blockquote></li><li><p>节流事件: 浏览器中有几个原生事件都会频繁触发。最常见的事件有scroll、resize和mousemove。为了解决这个问题，就需要节流事件</p><blockquote><p> 这个技术会限制一些无谓的计算，即不是每次事件发生都计算</p><ol><li>通过定时器,函数的调用只会在计时器结束时调用, 那么多次触发事件只有一次调用</li><li>通过定时器进行轮询检查,调用函数</li></ol></blockquote></li><li><p>在频繁重复的事件发生期间限制处理次数的第三种技术叫消除抖动</p></li><li><p>扩展事件: 利用这些事件扩展API，可以创建出与原生DOM事件非常类似的新事件。具备默认行为….</p></li></ul><h5 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h5><ul><li><p>如果在两次事件发生后调用动画, 如果时间很多的情况下,那么图像会在最后一次事件出发后反复的运行动画</p><blockquote><p>原因: 元素的动画逐一的添加进队列,它会依次运行直到队列为空</p></blockquote></li><li><p>使用jQuery自定义的<code>:animated</code>, is(‘:animated’)判断是否在动画中,但是还不够,还需要<strong>终止运行中的动画</strong></p><blockquote><p><code>.stop()</code>，它能在动画运行过程中让动画立即停止。这里的关键是在处理新动画之前先停止当前动画, .stop()方法可以接收两个布尔值,第二个参数 <code>gotoend</code></p><p><code>.finish() </code>  清除队列中的动画,并使当前动画跳转到最终值,和.stop(true,true)相似</p></blockquote></li></ul><blockquote><p>在1.7之前版本中,   在动画之前，这些简写的动画方法(<strong>slidedown fadein..</strong>.)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。</p></blockquote><ul><li><p>全局效果属性 :<code>$.fx</code>对象  </p><blockquote><p>禁用所有动画效果  <code>$.fx.off=true;</code><br>定义效果时长 <code>$.fx.speeds= ...  </code>可以改变预设值的效果速度,可以自定义一个速度选项</p></blockquote></li></ul><ul><li><p>多属性缓动  </p><blockquote><p>通过动画方法中,<code>specialEasing</code>选项可以为每个要应用动画的属性设置不同的加速度曲线。 默认的是 swing函数</p></blockquote></li><li><p>延迟对象(promise)</p><blockquote><p>每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。</p></blockquote><blockquote><p>通过在jQuery对象上调用.promise()方法,获得延迟对象</p><p><code>.done()</code>方法添加的处理程序会在延迟对象被成功解决之后调用。<br><code> .fail()</code>方法添加的处理程序会在延迟对象被拒绝之后调用。<br><code> .always()</code>方法添加的处理程序会在延迟对象完成其任务（无论解决或拒绝）时<br> 调用。</p></blockquote></li><li><blockquote><p>通过延迟对象可以使动画在某个操作结束后调用函数, 取代了回调函数</p></blockquote></li><li><p>.animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  </p><blockquote><p>jQuery动画系统最底层的方法是$.Animation()和$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面</p></blockquote></li></ul><hr><p>本文档参考                   &lt;  jQuery 基础教程第四版  2020 6.30 &gt;</p>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML表单</title>
    <link href="/2021/02/21/Md%20HTML5/HTML%E8%A1%A8%E5%8D%95/"/>
    <url>/2021/02/21/Md%20HTML5/HTML%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML原生表单"><a href="#HTML原生表单" class="headerlink" title="HTML原生表单"></a>HTML原生表单</h2><h4 id="原生表单部件"><a href="#原生表单部件" class="headerlink" title="原生表单部件"></a>原生表单部件</h4><ul><li><p>表单标签 :</p></li><li><blockquote><p>&lt; form  name method action &gt;  </p><p>&lt; input  type  id name&gt;  </p><p>&lt; label for&gt;      <label>标签与 <input> 通过他们各自的<code>for</code> 属性和 <code>id</code> 属性正确相关联,  这样可访问性会好</p><p>&lt; textarea cols rows wrap&gt;  wrap 预设值 ，表示提交的文字不会换行，但浏览器呈现的文字会换行</p><p>&lt; select  multiple&gt; &lt; optgroup&gt;&lt; option&gt;</p><p>&lt; datalist id&gt; 建议列表 ,使用list属性将数据列表绑定到一个文本框</p><p>&lt; button type  &gt; </p></blockquote></li></ul><ul><li><p>严格禁止在一个表单内嵌套另一个表单。嵌套会使表单的行为不可预知</p></li><li><p>form name 属性不推荐使用, 现在使用id</p></li><li><fieldset> 和 <legend> 元素  可以用来给表单分出结构(语义化标签) , legend 元素会有边框的 css样式</li></ul><h4 id="表单组件通用属性"><a href="#表单组件通用属性" class="headerlink" title="表单组件通用属性"></a>表单组件通用属性</h4><ul><li><p><strong>通用属性:</strong> </p><blockquote><p><code>name</code>        元素的名称;这是跟表单数据一起提交的。<br><code>value    </code>    元素的初始值。<br><code>autofocus</code>    (false)    这个布尔属性允许您指定当页面加载时元素应该自动具有输入焦点,文档中只有一个与表单相关的元素可以指定这个属性。<br><code>disabled</code>    这个布尔属性表示用户不能与元素交互</p></blockquote></li><li><p><strong>所有输入用的文本框(input textarea)都有一些通用规范:</strong></p><blockquote><p>readonly: 用户不能修改输入值<br>disabled：输入值永远不会与表单数据的其余部分一起发送  </p><p>size (框的物理尺寸) 和 maxlength (可以输入的最大字符数)。</p><p>placeholder:提供输入提示信息</p></blockquote></li></ul><h6 id="输入框-按钮注意点"><a href="#输入框-按钮注意点" class="headerlink" title="输入框.按钮注意点"></a>输入框.按钮注意点</h6><ul><li><strong>&lt; input&gt;的默认值</strong>，必须使用value 属性,<strong>&lt; textarea&gt;的默认值</strong>，在 textarea 元素的开始和结束标记之间放置默认值</li></ul><ul><li>&lt; textarea&gt;元素可以包含文本内容的子元素。将任何HTML内容放入&lt; textarea&gt;中都呈现为纯文本内容。</li></ul><ul><li><p> 对于<button> 元素, 省略 type 属性 (或是一个无效的 type 值) 的结果就是一个提交(type=submit)按钮.</p></li><li><blockquote><p>type 属性 : submit  reset   button</p><p>使用<button>元素或<input>元素定义的按钮几乎没有区别。</p><p>唯一的区别是在<button>元素中，标签可以是HTML，因此可以相应地进行样式化。在<input>元素中，标签只能是字符数据，</p></blockquote></li></ul><ul><li>HTML表单文本字段是简单的纯文本输入控件(input)。 这意味着您不能使用它们执行富文本编辑(粗体、斜体等)。</li></ul><h6 id="选择小部件注意点"><a href="#选择小部件注意点" class="headerlink" title="选择小部件注意点"></a>选择小部件注意点</h6><ul><li>如果一个&lt; option&gt;元素设置了value属性，那么当提交表单时该属性的值就会被发送。如果忽略了value属性，则使用&lt; option&gt;元素的内容作为选择框的值。</li></ul><ul><li><p>可选中项是可以通过单击它们来更改状态的小部件。有两种可选中项：复选框和单选按钮</p><blockquote><p>对于可选中项(radio  checkbox)，只有在勾选时才发送它们的值。如果他们没有被勾选，就不会发送任何东西，甚至连他们的名字也没有</p><p>对于大多数表单部件，一旦表单提交，所有具有<code>name</code>属性的小部件都会被发送，即使没有任何值被填。</p></blockquote></li><li><p>几个单选按钮(radio)可以连接在一起。如果它们的name属性共享相同的值，那么它们将被认为属于同一组的按钮。同一组中只有一个按钮可以被选；</p></li></ul><ul><li><p>对于可选项,value属性是被后台获取的值,</p><blockquote><p>不指定value默认”on” ,反之是”off”, 复选框,单选框都需要拥有value属性</p></blockquote></li></ul><h4 id="高级表单部件"><a href="#高级表单部件" class="headerlink" title="高级表单部件"></a>高级表单部件</h4><ol><li><p>数字 type=’number’</p><blockquote><p>通过设置min和max属性来约束该值。<br>通过设置step属性来指定增加和减少按钮更改小部件的步进值大小。</p></blockquote></li><li><p>滑块 type=’range’  设置min、max和step属性。</p></li><li><p>拾色器  &lt; input type=”color” name=”color” id=”color”&gt;</p></li><li><p>日期时间选择器 : type =’datetime-local’  ‘month ‘  ‘ time’  ‘week’</p></li><li><p>文件选择器 :  input  type=file  ,  accept属性来约束接受的文件类型 , multiple属性让用户选择多个文件</p><blockquote><p>有些数据是用表单发送的，但不显示给用户。使用&lt; input&gt;将它的type属性设置为hidden值。然后设置它的name和value属性</p></blockquote><ul><li><p> <strong>上传文件:</strong></p></li><li><p>获得上传文件的地址:</p><blockquote><p>&lt; input type=”file” id=”input”&gt; 上传组件, 你不能使用 input.value 来获取该文件路径,由于浏览器安全问题,路径会被修改, 会出现 fakepath.</p><p>后端node   可以通过.upload.path 获得 绝对路径</p><p>前端的话,只能获得表示该文件的字符串 </p></blockquote></li><li><p>获得上传文件:</p><blockquote><p>使用<code>HTMLInputElement.files</code>返回一个包含一列 File 对象的 FileList 对象(类数组)。 length 属性来获得已选择文件的数量。</p><p>File 对象常用属性 : name size type lastModified….       通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications">File API</a>  操作</p></blockquote></li></ul></li></ol><ul><li><p>上传文件是图片时获得缩略图:</p></li><li><blockquote><p>  <code>window.URL.createObjectURL() </code>和<code>window.URL.revokeObjectURL() </code>方法的支持。这使得你可以创建用于引用任何数据的简单URL字符串，也可以引用一个包括用户电脑上的本地文件的DOM File对象。 </p><p> 利用此可以获得选中文件的字符串,可以直接付给src</p><p>FileReader() 可以获得base64图片 赋值给src</p></blockquote></li></ul><ol start="6"><li><p>图像按钮:  type=image </p><blockquote><p>这个元素支持与&lt; img&gt;元素相同的属性，和其他表单按钮支持的所有属性。</p><p>如果使用图像按钮来提交表单，它提交的是在图像上单击处的X和Y坐标(坐标是相对于图像的，图像的左上角表示原点，坐标被发送为两个键/值：</p></blockquote></li><li><p>进度条 使用&lt; progress&gt;元素创建的。</p><blockquote><p>&lt; progress max=”100” value=”75”&gt;75/100&lt;/ progress&gt;</p></blockquote></li><li><p>仪表</p><blockquote><p>&lt; meter min=”0” max=”100” value=”75” low=”33” high=”66” optimum=”50”&gt;</p></blockquote></li></ol><h4 id="发送表单数据"><a href="#发送表单数据" class="headerlink" title="发送表单数据"></a>发送表单数据</h4><ul><li><p><strong>表单发送数据:</strong></p></li><li><blockquote><p>form  action属性: 定义了发送数据要去的位置。它的值必须是一个有效的URL,如果没有提供此属性，则数据将被发送到包含这个表单的页面的URL。</p><p>method 属性 : 该属性定义了如何发送数据 Get  post</p></blockquote></li><li><p>发送敏感信息/ 发送大量数据 post方法是首选,因为一些浏览器限制了URL的大小。</p></li></ul><ul><li><p><strong>表单发送文件:</strong></p></li><li><blockquote><p>表单发送文件,需要更改Content-Type, 通过在form的enctype=”multipart/form-data”</p><p>文件是二进制数据,被分成多个部分传送,所以需要单独设置类型</p><p>默认情况下，它的值是application/x-www-form-urlencoded。它的意思是：“这是已编码为URL参数的表单数据。”</p></blockquote></li></ul><hr><ul><li><p><strong>表单发送数据 和 ajax 的区别</strong></p></li><li><blockquote><p>标准的 HTML 表单提交会加载数据要发送到的URL，这意味着浏览器窗口以整页加载进行导航。 可以通过隐藏闪烁和网络滞后来避免整页加载以提供更平滑的体验</p><p>AJAX 技术主要依靠 XMLHttpRequest 它可以构造 HTTP 请求、发送它们，并获取请求结果。</p></blockquote></li></ul><ul><li><p><strong>AJAX 发送表单数据的主要方法:</strong></p></li><li><blockquote><p>get/post 简单的使用编码为URL参数的表单数据。  类型 :application/x-www-form-urlencoded</p><p>使用FormData 对象构建数据,post来发送数据  类型: multipart/form-data</p></blockquote></li></ul><ul><li><p>请注意，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">FormData</a> 对象是“只写”的，这意味着您可以更改它们，但不能检索其内容,你也可以把一个 <code>FormData</code> 对象绑定到一个表单上, new FormData(form);</p></li><li><blockquote><p>如果表单含有type=file组件, FormData对象会自动处理</p><p>后端拿到formdata数据,也需要单独处理</p></blockquote></li></ul><hr><ul><li><p><strong>Get 和 Post 请求的区别:</strong> …</p></li><li><blockquote><p>使用post方法, 数据追加到HTTP请求的主体中</p><p>….</p><p>HTTP请求由两个部分组成：一个包含关于浏览器功能的全局元数据集的头部，和一个包含服务器处理特定请求所需信息的主体。(简单说头 和 主体)</p></blockquote></li></ul><h4 id="表单数据效验"><a href="#表单数据效验" class="headerlink" title="表单数据效验"></a>表单数据效验</h4><ul><li><p><strong>客户端效验:</strong> 发生在浏览器端，表单数据被提交到服务器之前</p><blockquote><p>JavaScript  校验，这是可以完全自定义的实现方式, 会触发invalid事件,可以自定义样式</p><p>HTML5 <strong>内置校验</strong>，这不需要 JavaScript ，而且性能更好，但是不能像JavaScript那样可自定义。</p></blockquote><ul><li><p>内置效验:</p></li><li><blockquote><p> <code>required</code>(必填)  <code>pattern</code>正则表达式, </p><p>所有文本框 (<input> 或 <textarea>) 都可以使用minlength 和 maxlength 属性,数字类型 type =number <code>min</code> 和 <code>max</code> 属性同样提供校验约束</p></blockquote></li><li><p><strong>JS自定义验证:</strong> <code>novalidate</code> 属性关闭浏览器的自动校验；这允许我们使用脚本控制表单校验</p></li><li><blockquote><p>使用 JavaScript css伪类 自定义错误提示信息的外观  文本</p></blockquote></li></ul></li></ul><ul><li><p>要自定义错误提示消息的外观和文本, 你必须使用 JavaScript自定义; 不能使用 HTML 和 CSS 来改变.     <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/Data_form_validation">validation API</a> 只可以用来改变文本或者监测验证情况</p><blockquote><p>通过效验时, 通过 CSS 伪类 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a> 进行特殊的样式化,</p><p>没有通过效验时, 通过 CSS 伪类 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a> 进行特殊的样式化；</p></blockquote><hr></li></ul><ul><li><p><strong>服务器端校验</strong>:  发生在数据被服务器端程序接收之后, 将数据写入数据库之前</p><blockquote><p>服务器端校验不像客户端校验那样有好的用户体验，因为它直到整个表单都提交后才能返回错误信息</p></blockquote></li></ul><ul><li>远程效验:  一个应用实例就是注册表单，在这里你需要一个用户名。 为了避免重复，执行一个 AJAX 请求来检查用户名的可用性，</li></ul><h4 id="Css样式化表单"><a href="#Css样式化表单" class="headerlink" title="Css样式化表单"></a>Css样式化表单</h4><ul><li>有些元素根本不能用应用CSS样式。 这些包括：所有高级表单小部件，如范围，颜色或日期控件….  , 所有下拉小部件，包括&lt; select&gt;, &lt; option&gt;, &lt; optgroup&gt;和&lt; datalist&gt; 元素。</li></ul><ul><li>因为每个小部件都有自己的边框，padding和边距的规则。如果你想给不同的小部件相同的大小，你必须使用box-sizing 属性</li></ul><ul><li>默认情况下，所有浏览器都认为&lt; textarea&gt; 元素是inline block，与文本底线对齐, 如果你想以inline方式使用它，通常改变垂直对齐方式：vertical-align</li></ul><ul><li>注意添加outline 属性非常重要，这样可以移除由某些浏览器添加的默认高亮效果</li></ul><ul><li><p>CSS 3 也增加了几个伪类用于描述小部件的状态：</p></li><li><blockquote><p>   :default :valid :invalid  :in-range :out-of-range </p><p>  :required    :optional    :read-only   :read-write</p></blockquote></li><li><p>要实现对表单小部件的完全控制，你别无选择，只能选择依靠JavaScript。使用JS库</p></li></ul><h4 id="表单提交时安全问题"><a href="#表单提交时安全问题" class="headerlink" title="表单提交时安全问题"></a>表单提交时安全问题</h4><ul><li>跨站脚本(XSS)和跨站点请求伪造(CSRF)是常见的攻击类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML表单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML基础</title>
    <link href="/2021/02/21/Md%20HTML5/HTML%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/21/Md%20HTML5/HTML%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML基础："><a href="#HTML基础：" class="headerlink" title="HTML基础："></a>HTML基础：</h2><h4 id="基本标签使用"><a href="#基本标签使用" class="headerlink" title="基本标签使用:"></a>基本标签使用:</h4><ol><li><p>段落标题：   h  p</p></li><li><p>列表:  ul li  ol li  (列表的嵌套也是可以的)   描述列表: dl dt dd</p><blockquote><p>描述列表,浏览器的默认样式会在描述列表的描述部分&lt; dd&gt;和描述术语&lt; dt&gt;缩进</p></blockquote></li><li><p>强调语义：strong  em (更强的可访问性 语义性)   b i u(仅仅影响表象而且没有语义，被称为表象元素)</p></li><li><p>超链接:  a    属性title :补充信息    通过id还可以设置锚点</p></li></ol><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://download.mozilla.org...&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;firefox-installer.exe&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>   <br>// 当链接是下载资源时 使用download属性给一个资源名字<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:nowhere@mozilla.org&quot;</span>&gt;</span>向 nowhere 发邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>//可以通过mailto: 来给一个邮件地址<br></code></pre></td></tr></table></figure></blockquote><ol start="5"><li><p>&lt; abbr title=”” &gt; 包裹一个缩略语或缩写,title属性里面是详细介绍,<br>&lt; address&gt;  标记联系方式   &lt; sup&gt; 和&lt; sub&gt;上标和下标。&lt; code&gt;标记计算机代码<br>&lt; pre&gt;用来保存空白字符, 默认浏览器是忽略缩进和空格</p></li><li><p>&lt; time datetime=””&gt;  将时间和日期标记为可供机器识别的格式</p></li><li><p>块级内容引用:  blockquote 包裹起来表示，并且在cite属性里用URL来指向引用的资源 行内引用: q 包裹起来, 写cite属性</p><blockquote><p>块级引用:浏览器在渲染块引用时默认会增加缩进</p><p>行内引用:默认将其作为普通文本放入引号内表示引用</p><p>cite属性默认不会显示,更好的做法是使用cite元素 附上a链接,元素默认的字体样式为斜体</p></blockquote></li></ol><ol start="8"><li><p>文档结构标签 &lt; header&gt; &lt; footer &gt; &lt; aside&gt;  &lt; nav&gt;  &lt; main&gt;</p><blockquote><p>main 主题部分中  可用article   section  div等元素表示。</p><p>标签本质上没有特别,主要有语义的作用,   他会让可访问性更强</p></blockquote></li><li><p>换行和切割线 : hr  br</p></li><li><p>ins  del 元素, 删除文本和标记文本分别出现  文字划线 和 下划线 可以通过css改变样式,变成漂亮的标注 </p></li></ol><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ol><li><p>&lt; table&gt;  &lt; tr&gt;&lt; td&gt;  &lt; th&gt;: 样式加粗 一般设置小标题, &lt; caption&gt;</p></li><li><p>colspan 横跨 rowspan 竖跨  </p></li><li><p>表格内结构标签：&lt; thead&gt;  &lt; tbody&gt; &lt; tfoot&gt;：没有特效，只是格式标签 . </p><p>scope 属性,添加在&lt; th&gt; 元素中 用来说明是列标题还是行标题  scope=”col” scope=”row”  (id headers也可以标记但是太麻烦了)</p></li><li><p>&lt; colgroup&gt;  &lt; col&gt;为一列添加样式 ,每个col 代表一列 ,这里是第二列应用样式,<br>使用 span 可以指定列数  ,这里可以改成 一个&lt; col span=2&gt;  (为每一行设置样式是比较简单的,但是为每一列设置的话使用这种方法比较简单 或者 nth-child)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">col</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: yellow&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="HTML多媒体"><a href="#HTML多媒体" class="headerlink" title="HTML多媒体"></a>HTML多媒体</h4><ul><li><p><strong>img 图片标签:</strong>    </p></li><li><blockquote><p>title 鼠标悬停的信息</p><p>alt 在图片无法显示时, 显示的描述信息</p><p>width height  </p><p>srcset 用于浏览器根据宽、高和像素密度来加载相应的图片资源</p></blockquote></li><li><p>html5 中的&lt; figure&gt; 和 &lt; figcaption &gt;元素 （放置图片的说明信息）：为图片提供一个语义容器，在标题和图片之间建立清晰的关联。</p></li><li><blockquote><p>注意 figure 里不一定要是一张图片，只要是一个这样的独立内容单元：图片、一段代码、音视频、方程、表格..  </p><p>它本身没有一个实质的作用,是一个语义化的容器</p></blockquote></li><li><p><strong>如何选择img 还是 background背景:</strong></p></li><li><blockquote><p>如果图像对您的内容里有意义，则应使用HTML图像。</p><p>如果图像纯粹是装饰，则应使用CSS背景图片。这样插入的图片完全没有语义上的意义, 也不能被屏幕阅读器识别。</p></blockquote></li><li><p>像 img 和 video  ifram这样的元素有时被称之为<strong>替换元素</strong>，这样的元素的内容和尺寸由外部资源所定义，而不是元素自身。</p></li><li><blockquote><p>替换元素: 当资源加载出来后,元素将被替换掉,所以尺寸是外部资源所定义的,但是我们可以进行设置元素的大小</p></blockquote><hr></li></ul><h5 id="自适应图片"><a href="#自适应图片" class="headerlink" title="自适应图片"></a>自适应图片</h5><ul><li><blockquote><p>解决方法:    </p><ol><li><p>准备两套图片  img元素通过 srcset  sizes属性根据尺寸切换</p></li><li><p>利用&lt; picture&gt; 中的source标签  通过他的media srcset属性实现</p><p>为什么不可以通过css  js 来实现响应式?</p><p>因为浏览器预加载 任意的图片 , 你不能先加载好 img 元素后, 再用 JavaScript 检测可视窗口的宽度，动态地加载小的图片替换已经加载好的图片，这就加载了两次</p></li></ol></blockquote><hr></li></ul><ul><li><p><strong>音视频标签: audio  video</strong></p></li><li><blockquote><p>属性值: </p><p>width 和 height 控制尺寸,如果没有保持纵横比,那么没有内容填充的部分默认为背景色</p><p>controls : 为网页中的音频显示标准的HTML5控制器。<br>autoplay : 使音频自动播放。<br>loop : 使音频自动重复播放。<br>muted  这个属性会导致媒体播放时，默认关闭声音。<br>poster:这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。<br>preload 这个属性被用来缓冲较大的文件</p><p>&lt; audio&gt; 上使用方式几乎一样，但不支持宽高设置 同时也不支持poster属性</p></blockquote></li><li><p>video 标签内为备选内容, 用 &lt; source  type=’’&gt; 标签来指定多个文件，以为不同浏览器提供可支持的编码格式</p></li><li><p>关于这种媒体元素,会有响应的事件和函数可以调用,详情查阅MDN ,常用的有 play() pause()….</p></li><li><p>&lt; track&gt;标签, 提供一个音频内容的文本(字幕)</p></li></ul><hr><ul><li><p><strong>html 中的向量图</strong>—svg图片,通过img标签添加,或者通过svg标签添加(这成为内联svg)</p></li><li><blockquote><p>矢量图形相较于同样的位图，通常拥有更小的体积，因为它们仅需储存少量的算法，而不是逐个储存每个像素的信息。在放大时不会产生失真</p><p>缺点 : </p><p>无法使用JavaScript操作图像。<br>如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 </p></blockquote></li><li><p>可以使用SVG作为CSS背景图像</p></li><li><p>内联svg优缺点:</p></li><li><blockquote><p>将 SVG 内联减少 HTTP 请求，可以减少加载时间。</p><p>浏览器不能像缓存普通图片一样缓存内联SVG。</p></blockquote></li></ul><ul><li>&lt; iframe&gt;元素旨在允许您将其他Web文档嵌入到当前文档中。&lt; embed&gt;和&lt; object&gt;元素的功能不同于&lt; iframe&gt;—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具,不太使用</li></ul><h4 id="URL和Path"><a href="#URL和Path" class="headerlink" title="URL和Path"></a>URL和Path</h4><ul><li><p>URL: 统一资源定位符（英文：<strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator）是一个定义了在网络上的位置的一个文本字符串, URL使用路径Path查找文件。路径指定文件系统中您感兴趣的文件所在的位置。URL分为:<strong>绝对URL</strong>和<strong>相对URL</strong></p><ul><li><strong>绝对URL</strong>: 指向由其在Web上的绝对位置定义的位置，包括 protocol（协议） 和 domain name（域名）</li><li><strong>相对URL</strong>:指向与您链接的文件相关的位置, 相对的基准默认是index.html主入口</li></ul></li><li><blockquote><p>当链接到同一网站的其他位置时，你应该使用相对链接,当链接到另一个网站时，你需要使用绝对链接  </p><p>相对URL，浏览器只在同一服务器上查找被请求的文件。如果使用绝对URL会不断地让你的浏览器做额外的工作</p></blockquote></li></ul><h4 id="关于meta元数据"><a href="#关于meta元数据" class="headerlink" title="关于meta元数据"></a>关于meta元数据</h4><ul><li><p>视口元标签:</p><blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;<br><span class="hljs-regexp">//</span>除了这项选项,还有别的可用的选项<br></code></pre></td></tr></table></figure><p>这行代码会强制地让手机浏览器采用它们真实可视窗口的宽度来加载网页</p><p>**原因 :**这个元标签的存在，是由于原来iPhone发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为960像素, 渲染出缩小版本的网页, 但是你的媒体查询可能在960像素下不会生效</p><p>所以不加这行代码,可能只会渲染出缩小版本的网页</p></blockquote></li></ul><ul><li><p><code>meta</code>元素包含了 name 和 content特性：</p></li><li><blockquote><p>name  指定了 meta 元素的类型</p><p>content  指定了实际的元数据内容</p></blockquote></li><li><p>常见的  name =’description’     meta charset=”utf-8”</p></li></ul><blockquote><p>关于有些meta元数据。可以是自定义的，它旨在向某些网站 (如社交网站) 提供可使用的特定信息。例如，Facebook 编写的元数据协议 <a href="http://ogp.me/">Open Graph Data</a> 为网站提供了更丰富的元数据,  Twitter 还拥有自己的类型的专有元数据协议</p></blockquote><h4 id="页面添加图标的方式"><a href="#页面添加图标的方式" class="headerlink" title="页面添加图标的方式"></a>页面添加图标的方式</h4><ul><li>将图片保存在与网站的索引页面相同的目录中，以.ico格式保存（大多数浏览器将支持更通用的格式，如.gif或.png，但使用ICO格式将确保它能在如Internet Explorer 6一样久远的浏览器显示）, 在head中引用</li></ul><blockquote><link rel="shortcut icon" href="favicon.ico" type="image/x-icon"></blockquote><h4 id="为文档设定主语言"><a href="#为文档设定主语言" class="headerlink" title="为文档设定主语言"></a>为文档设定主语言</h4><blockquote><html lang="zh-CN"></blockquote><blockquote><p>你还可以将文档的分段设置为不同的语言。例如，我们可以把日语部分设置为日语，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>日语实例: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;jp&quot;</span>&gt;</span>ご飯が熱い。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="内联元素和块级元素"><a href="#内联元素和块级元素" class="headerlink" title="内联元素和块级元素"></a>内联元素和块级元素</h4><ul><li><p>以块的形式出现,对于在前面的内容它会出现新的一行,后面的内容也会被挤到下一行</p></li><li><blockquote><p>address  article aside audio<br>blockquote  canvas dd div dl </p><p>fieldset form figcaption figure  footer<br>h1~6  header hgroup hr noscript<br>ol output p pre section<br>table ul  tfoot video</p></blockquote></li><li><p>内联元素通常出现在块级元素中并环绕文档内容的一小部分,内联元素不会导致文本换行</p></li><li><blockquote><p>b, big, i, small, tt<br>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var<br>a, bdo, br, img, map, object, q, script, span, sub, sup<br>button, input, label, select, textarea</p></blockquote></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>如何将一张图片的不同区域链接到不同页面。: <a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Howto/Add_a_hit_map_on_top_of_an_image">图像映射</a></p></li><li><p>数据属性 data-   还可以被css访问  </p><blockquote><p>article::before {<br>content: attr(data-parent);<br>}<br>article[data-columns=’3’] {<br>width: 400px;<br>}</p></blockquote></li><li><p>在 &lt; img&gt; 元素中定义的图片可以从外部来源加载并在 &lt; canvas&gt; 元素中使用，就像是从本地源加载一样。在HTML5中，一些 HTML 元素提供了对 <a href="https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS">CORS</a> 的支持， 例如 &lt; audio&gt;、&lt; img&gt;、&lt; link&gt;、&lt; script&gt; 和 &lt; video&gt;均有一个跨域属性 (crossOrigin  property)，它允许你配置元素获取数据的 CORS 请求。 : <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image">需要配置跨域</a></p></li><li><p> &lt; link&gt; 元素的 rel 属性的属性值preload 可以实现在页面加载初期进行预加载</p></li></ul><h4 id="怪异模式和标准模式"><a href="#怪异模式和标准模式" class="headerlink" title="怪异模式和标准模式  : "></a>怪异模式和标准模式  : <!doctype html></h4><ul><li><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“**怪异模式(兼容模式)**”的渲染模式。“<!DOCTYPE html>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></li><li><p>兼容模式下 会出现很多问题, 比如 css应用问题, 加上标签和不加标签可能会出现差异,不如各个浏览器排版会出现问题</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sass基础</title>
    <link href="/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/Sass%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/Sass%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><ul><li><p><code>引入</code> 允许你创建多个文件，然后在一个文件中引入。</p></li><li><p><code>变量</code>  不在进行重复写一个值 ,而是直接使用变量</p></li><li><p><code>嵌套</code>  在嵌套中写css规则 , 更方便..</p></li><li><p><code>继承</code>  通过继承, 我们可以写一些基本样式, 然后继承他</p></li><li><p>sCSS是 sass 的升级版本  scss使用花括号表示关系, sass则是使用空白符和缩进</p></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>使用<code>$</code>符号来标识变量,任何可以用作css属性值的赋值都 可以用作sass的变量值，甚至是以空格分割的多个属性值</p></li><li><p>当变量定义在css规则块内，那么该变量只能在此规则块内使用。 变量之间也可以相互引用</p></li></ul><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ul><li><p>使用嵌套处理重复的书写选择器</p><blockquote><p>CSS在处理嵌套过程中,会用空格使用后代选择器, 但是有些时候比如 :first :hover 等情况, 我们不希望有空格, 这时候使用 &amp;:的符号</p></blockquote></li><li><blockquote><p>&amp; 本质上代表外层的父元素, 所以可以在嵌套中还可以使用后代选择</p><p>例如: p &amp;{}  但是尽量只定义 后代选择器, 这样导入时比较安全</p></blockquote></li><li><p>对于 &gt; + ~的处理来说, 可以放在外层选择器后边，或里层选择器前边</p></li><li><p>嵌套处理重复的属性  例如 : border-radius  -style …</p></li></ul><h4 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h4><ul><li><p>CSS@import规则，允许在一个CSS文件中导入其他CSS文件。然而，只有执行到@import时，浏览器才会去下载其他CSS文件，这导致页面加载起来特别慢。</p></li><li><p>SCSS@import规则不同, 在生成CSS文件时就进行导入,把所有样式整合到一起,而无需发送多个下载请求</p><blockquote><p>所有被导入文件中定义的变量和混合器均可在导入文件中使用。</p><p>使用sass的@import规则可以省略.sass或.scss文件后缀 </p><p>允许同时导入多个文件</p></blockquote></li><li><p>局部文件:</p><blockquote><p>把Sass 样式 分成多个文件进行管理,然而只想生成几个CSS文件, 那么就要使用局部文件 : 名字以<code>下划线开头</code>的sass文件 </p></blockquote></li><li><p>在引入文件时,防止被覆盖已经声明的变量, </p><blockquote><p>变量声明的后面使用!default  关键字, 如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p></blockquote></li><li><p>sass允许@import命令写在css规则内。这种导入方式会直接导入css规则内,成为嵌套语法</p></li></ul><ul><li>原生的CSS导入</li><li><blockquote><p>被导入文件的  名字以.CSS结尾；或者URL值,文件名以 http:// 开头, 或者通过URL()</p><p>这里推荐 @import url() 的方式 , 用css结尾导入可能会补上多余的前缀(vscode中) </p><p>换句话说,你不能用sass的@import直接导入一个原始的CSS文件，因为sass会认为你想用CSS原生的@import。</p></blockquote></li></ul><ul><li>静默注释,在生成的CSS文件中不会产生注释 格式: //</li></ul><h4 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h4><ul><li><p>处理重复的大段样式代码</p></li><li><blockquote><p>通过@mixin name 定义  @include引入 </p></blockquote></li><li><p>避免滥用混合器 ,在何时使用混合器</p><blockquote><p>判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。</p></blockquote></li><li><p>CSS类名应该是表述标签的含义,  混合器名字应该是展示性描述,应该具备应用样式的表述含义</p></li><li><p>混合器传参</p><blockquote><p>@mixin name($name), include时传递参数</p><p>参数默认值  使用$name: default-value</p></blockquote></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li><p>选择器继承  @extend语法实现,选择器可以继承另一个选择器定义的所有样式</p><blockquote><p>继承被编译后是 使用<code>,</code>的并集选择器</p></blockquote></li><li><p>选择器不仅会继承所有样式，任何该选择器有关的组合选择器样式 也会以组合选择器的形式继承</p><blockquote><p>//.seriousError从.error继承样式<br>.error a{  //应用到.seriousError a<br>  color: red;<br>  font-weight: 100;<br>}</p></blockquote></li><li><p>像#main .error这种后代选择器序列是不能被继承的。但可以反过来继承,我们也应该避免这种情况</p></li><li><p>继承 交集选择器:</p><blockquote><p>@extend.important.error ， 那么.important.error 和h1.important.error 的样式都会被.seriousError继承</p></blockquote></li></ul><ul><li><p>继承只会在生成CSS时复制选择器，而不会复制大段的CSS属性。比起混合器更加节省空间,但是如果继承的选择器较复杂,可能会复制很多选择器</p><blockquote><p>避免这种情况出现的最好方法就是不要在CSS规则中使用后代选择器（比如.foo .bar）去继承CSS规则。 为了匹配可能的情况,它会复制大量的选择器</p></blockquote></li></ul><h4 id="sassScript"><a href="#sassScript" class="headerlink" title="sassScript"></a>sassScript</h4><ul><li><p>CSS规则块内可以进行运算</p></li><li><blockquote><p>如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS文件中，只需要用 #{} 插值语句将变量包裹。</p></blockquote></li><li><blockquote><p>font: #{$font-size}/#{$line-height};</p><p>通过 #{} 插值语句可以在选择器或属性名中使用变量</p></blockquote></li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li>Sass 中 @media 指令与 CSS中用法一样，只是增加了一点额外的功能：允许其在 CSS规则中嵌套。如果 @media 嵌套在 CSS规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。</li></ul><ul><li><p>@extend-Only 选择器  Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS文件中。</p></li><li><p>!optional 声明 要求 @extend 不生成新选择器</p></li><li><p>在指令中使用 @extend 时（比如在 @media 中）有一些限制,这能继承在media规则内的选择器</p></li><li><p>@at-root  指令使嵌套在父元素的规则,编译时作为独立的样式,而不是后代选择器</p></li><li><p>@debug 把表达式打印出来 @ warn 指令将 SassScript 表达式的值打印到标准错误输出流。</p></li><li><p>@ error 将 SassScript 表达式的值作为一个致命错误抛出,对于验证 mixin 和函数的参数非常有用</p></li></ul><ul><li><p>@if指令  @while指令</p></li><li><p>@for指令 </p></li><li><blockquote><p>@for $i from 1 through 3  @for $i from 1 to 3  ,区别在于 to不包括end</p></blockquote></li><li><p>@each 指令</p></li><li><blockquote><p>@each $animal in puma, sea-slug, egret, salamander </p></blockquote></li></ul><ul><li>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：</li><li><blockquote><p>@function grid-width($n) {<br>@return $n * $grid-width + ($n - 1) * $gutter-width;} </p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3 指南</title>
    <link href="/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS3%20%E6%89%A9%E5%B1%95/"/>
    <url>/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS3%20%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul><li><p>边框</p><ul><li><p>border-radius    圆角</p><blockquote><p>默认一个值应用在四个方向,如果想单独设置,可以各四个值分别代表 从左上顺时针到左下的角</p></blockquote></li><li><p>box-shadow   边框阴影 </p><blockquote><p>四个值分别   x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 </p></blockquote></li><li><p>border-image    用图片创建边框</p><blockquote><p>三个值 /* border-image: image-source image-height image-width image-repeat */</p></blockquote></li></ul></li><li><p>文本</p><ul><li><p>text-shadow 文本应用阴影 (和box-shadow 格式一样)</p><blockquote><p>四个值分别 :水平阴影(px)、垂直阴影 (px)、模糊距离(px)，以及阴影的颜色</p></blockquote></li><li><p>@font-face 规则   应用时设置font-family: name 使用自己设置的名字</p></li></ul></li><li><p>渐变</p><ul><li> linear-gradient()函数创建  </li><li><blockquote><p> background: linear-gradient(to bottom right, blue, pink);  第一个参数可选 也可以替换成角度  颜色参数也可以是多种颜色  可以控制结束为止,渐变中心… 在使用角度的时候, 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右</p></blockquote></li></ul></li><li><p>filter 属性 完成图像模糊 (滤镜效果) 颜色转变的想过 </p><h3 id="CSS-变形-transforms"><a href="#CSS-变形-transforms" class="headerlink" title="CSS 变形 (transforms)"></a>CSS 变形 (transforms)</h3></li><li><p>行级元素不产生变形效果，将其转为 <code>inline-block</code> 或 <code>block</code> 以及弹性元素时都可以产生变化效果</p></li></ul><ul><li><p><strong>transform属性,变形函数</strong>:</p></li><li><p>偏移</p><ul><li><p><code>translate()</code>  控制X、Y轴偏移   <code>translate3d() </code> 空间内偏移  , 给 x y z轴的坐标</p></li><li><blockquote><p>从其当前位置移动，根据给定的坐标值</p><p>还有,  <code>translateX() </code> <code>translateY()</code>   <code>translateZ()</code>  </p><p><strong>坐标值的类型:</strong></p><p>百分比 :  100%代表元素本身的尺寸(z轴不能给百分比值,因为z轴可以无限纵深,没有参考值)</p><p>负值: 反方向偏移</p><p>标准值</p></blockquote></li></ul></li></ul><ul><li><p>缩放: </p><ul><li><p><code>scale()</code> 设置 X/Y 轴的缩放     <code> scale3d()</code>  沿X/Y/Z三个轴绽放元素。</p><blockquote><p><code>scaleX()  scaleY()  scaleZ()</code>   </p></blockquote><blockquote><p>z轴的缩放放大,视觉上是距离远近</p><p>放大和缩放  , 1 代表本身的大小, 负值进行反方向变换</p></blockquote></li></ul></li></ul><ul><li>旋转:</li></ul><pre><code>- `rotate()`  在平面内旋转,效果与使用 `rotateZ` 相同。  `rotate3d(tx,ty,tz,angle)` 同时设置X/Y/Z轴的旋转向量值来控制元素的旋转  &gt; 允许负值，元素将逆时针旋转  &gt;`rotateX()   rotateY()    rotateZ()`  元素按照不同坐标轴进行旋转  &gt;  &gt;可以同时设置多个旋转规则，顺序不同结果也会不同。</code></pre><ul><li><p>倾斜:</p><ul><li><p>skew()同时设置X/Y轴倾斜操作，不指定第二个参数时Y轴倾斜为零</p><blockquote><p><code>skewX( )  skewY()</code>   </p><p>通过倾斜还可以做出立体的图像</p></blockquote></li></ul></li></ul><ul><li><p>变形基点:</p></li><li><p>使用 <code>transform-origin</code> 设置元素的X/YZ操作的基点，用于控制旋转、倾斜等操作</p><blockquote><ul><li><p><strong>旋转默认以元素中心</strong>进行旋转，改变基点后可控制旋转点位置</p></li><li><p><strong>元素移动不受变形基点所影响</strong></p></li><li><p>基点是元素原始空间位，而不是translate移动后的空间位,基点存在于元素本身,而不是移动的空间位上</p></li></ul></blockquote></li><li><p>透视:</p><blockquote><p>使用 <code>perspective</code> 来控制元素的透视景深   (简单理解 数值越小观察位置越近)</p><p>给单个元素设置 tansform:perspective() ,使视角向后靠,让3d感更强,(近距离看不到3d的)</p></blockquote></li></ul><blockquote><p><code>perspective</code> <strong>规则</strong>用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的。对父元素没有影响, 一般容器内是一个立方体时使用,用同一个位置观察不同的元素</p><p><code>perspective()</code> 函数用于为元素设置单独透视，每个元素的透视效果是一样的。相当于把每个元素拿到同一个位置去看</p></blockquote><ul><li><p>使用 <code>transform-style</code> 用于控制3d透视。参数:flat   preserve-3d</p><blockquote><p>应用于舞台即变形元素的父级元素<br>设置 overflow:visible 时 preserve-3d 才无效</p></blockquote></li></ul><ul><li><p>透视视角:</p><blockquote><p>通过 <code>perspective-origin</code> 属性来设置。默认透视视角为 观察者视角不变 物体变换位置</p><p>可以理解眼镜看物体的位置,看物体的左边或者右边</p><p>需要设置 <code>perspective</code> 透视后才可以看到效果。</p></blockquote></li></ul><ul><li><p>使用 <code>backface-visibility</code> 用于控制是否可以看到元素的背面。</p></li><li><blockquote><p>一般设置在元素上而不是舞台元素上</p><p>需要舞台元素（父级元素）设置 <code>transform-style: preserve-3d</code></p></blockquote></li><li><p><code>transform-style: preserve-3d</code> 当z轴参与 需要3d感时需要给父元素加上</p></li></ul><h3 id="CSS过渡-transitions"><a href="#CSS过渡-transitions" class="headerlink" title="CSS过渡 (transitions)"></a>CSS过渡 (transitions)</h3><ul><li><p>transition 提供了一种在更改CSS属性时控制动画速度的方法</p><blockquote><p>transition-property` 规定哪些属性进行改变</p><p><code>transition-duration</code> 变换时间</p><p><code>transition-delay</code>  指定延迟 </p><p>简写属性  <code>transition</code></p><p>transition: width 2s 1s(delay) linear, height 2s, transform 2s </p></blockquote></li></ul><ul><li><p><code>transition-timing-function </code>指定一个函数，定义属性值变化快慢函数</p><blockquote><p>关键字 或者自定义 cubic-bezier()</p></blockquote></li></ul><ul><li><blockquote><p>当过渡完成时触发一个事件，<code>transitionend</code></p><p>想让一个元素的属性 transition起来 , 必须要先有预设值,  </p><p>部分属性是没有过渡属性的</p></blockquote></li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><p>使用keyframes定义动画序列</p><blockquote><p>@keyframes name {</p><p>from{….} </p><p>to{….},</p><p>或者 关键帧</p><p>25%{}  75%{}…</p><p>} </p><p>帧动画也可以和form to混合使用</p><p>多个帧动画有共同的属性可以组合书写</p><p>25%,75%{</p><p>}</p></blockquote></li><li><p>animation 属性:</p><blockquote><p><code>animation-duration</code>  设置动画中的属性的运行时长</p><p> <code>animation-timing-function</code>  动画变化速率 贝塞尔曲线 和transition一样<br> <code>animation-direction</code>  设置动画方向  (方向指 动画的0% 100%)</p><p> <code>animation-delay</code> 延迟<br> <code>animation-iteration-count</code> 设置动画重复次数， 可以指定infinite无限次重复动画<br>   <code> animation-name</code>   指定应用的动画</p><p><code>animation-play-state</code>  指定动画暂停开始 </p><p>``animation-fill-mode` :用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态</p></blockquote></li><li><p>简写属性 : animation</p><blockquote><p>animation: 3s ease-in 1s 2 reverse both paused 动画名字</p><p>动画名字由@keyframes 定义</p></blockquote></li><li><p>没有中间值的属性,没办法进行动画变化, 例如:solid  dashed 边框样式是没有中间值的,他会一瞬间变化没有动画</p></li></ul><h3 id="媒体查询和响应式"><a href="#媒体查询和响应式" class="headerlink" title="媒体查询和响应式"></a>媒体查询和响应式</h3><ul><li><p>style link 标签的 media属性,针对各设备的样式化 ,默认为 all</p></li><li><p>您可以在<code>media</code>属性中提供媒体类型或查询; 然后，只有在媒体条件为true时，才会加载此资源。</p></li><li><p>@import url() media名字  查询条件   给各设备导入样式化文件</p><blockquote><p>利用import 把每个不同设备的css文件 进行导入同一个css文件</p></blockquote></li><li><p>only 关键字 : 支持媒体查询的浏览器应用样式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 布局</title>
    <link href="/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS3%20%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88%20/"/>
    <url>/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS3%20%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88%20/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><h3 id="布局总览"><a href="#布局总览" class="headerlink" title="布局总览:"></a>布局总览:</h3><ul><li><p>正常布局流</p></li><li><p>display属性</p></li><li><p>Grid (CSS网格)</p></li><li><p>Flexbox(弹性盒子)</p></li><li><p>position (定位)</p></li><li><p>float(浮动)</p></li><li><p>多列布局</p></li><li><p>表格布局</p></li></ul><h3 id="Flexbox-弹性盒子"><a href="#Flexbox-弹性盒子" class="headerlink" title="Flexbox(弹性盒子)"></a>Flexbox(弹性盒子)</h3><ul><li><p>专门设计出来用于创建横向或是纵向的<strong>一维页面布局</strong> </p></li><li><p>弹性盒子的布局围绕两个轴来布局: 主轴 和 交叉轴  , 在弹性盒子中的元素称为flex 项</p><blockquote><p>主轴和交叉轴 不是一成不变的, 它根据<code>flex-direction</code>布局方向变化,属性指定主轴方向,另一个轴就是交叉轴 </p><p><code>align-items </code>:  控制交叉轴的对齐方式 ,因为它将所有直接子节点上的<code>align-self</code>值设置为一个组</p><p><code> align-content</code> : 浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。</p><p><code>align-self</code> 控制单个flex项的对齐方式</p><p><code>justify-content</code>: 控制 flex 项在主轴上的位置</p><blockquote><p>space-around ——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。 space-between 则不会再两端留有空间    align-content中的属性同样的方式</p></blockquote></blockquote></li></ul><ul><li><p>以下为弹性盒子的主要属性:</p><blockquote><p><code>flex-direction </code>指定主轴方向 ,默认为row</p><p><code>flex-wrap</code>   空间不够时是否让 flex项进行换行</p><ul><li>弹性元素属性：</li></ul><p><code>flex-flow</code> : flex-direction flex-wrap  的缩写</p><p><code>flex-grow </code>: 指定了flex容器中剩余空间应该分配给项目的比例。</p><p><code>flex-basis:</code> 元素大小的基准值,空间允许情况下会尽量满足该值 , 比width的优先级大</p><p><code>flex-shrink</code>: 空间不足时,缩放比例的多少</p><p><code>flex</code>:  flex-grow flex-shrink flex-basis   缩写   </p></blockquote></li></ul><ul><li><p>利用<code>order</code> 属性进行flex 项排序 ,默认值为0, 可以为负值,  order小的显示顺序在前</p></li><li><p><em>弹性盒子中的<code>文本节点</code>也可以进行弹性布局</em></p></li></ul><h3 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h3><ul><li><p>被设计用于同时在两个维度上把元素按行和列排列整齐。</p></li><li><p>定义栅格系统:</p><blockquote><p><code>grid-template-rows </code>:规定每行的高度,有几行就声明几个值</p><p><code>grid-template-columns </code>:和rows 一样使用,区别在于,多出的元素只会溢出行,不会溢出列</p><blockquote><p><strong>值的几种特殊类型:</strong></p><p>还可以给某一列使用 auto 值,自动获得剩余所有的宽/高度</p><p>使用repeat(3/auto-fill,1fr /px/minmax(50px,100px)/%…) 声明栅格系统 </p><p>auto-fill :  根据值大小,自动分出列 (值不能是fr)    </p><p>fr : 可用空间按比例分配        minmax()函数规定了尺寸的范围</p></blockquote><p><code>grid-tempalte</code>:  grid-template-rows、grid-template-columns、grid-template-areas 属性值的缩写</p></blockquote></li><li><p><strong>间距(gutter)定义:</strong></p><blockquote><p><code>column-gap </code>  :别名: grid-column-gap</p><p><code>row-gap</code>    别名: grid-row-gap</p><p><code>gap</code> 规则可以一次定义行、列间距</p></blockquote></li></ul><ul><li><p><strong>栅格线命名:</strong></p><blockquote><p>独立命名: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">  &gt;grid-template-rows:<br>[r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end];<br></code></pre></td></tr></table></figure><p>单元格的每个方向给两条边   例如 :r1-star r1-end    (r1-end r2-start是一条线)</p><p>自动命名:  命名从1开始  r-start 1 … </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">grid-template-rows: repeat(3, [r-start] 100px [r-end]);<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>区域命名:</strong></p><blockquote><p>使用<code> grid-template-areas</code>可以定义栅格区域，并且栅格区域必须是矩形的。</p></blockquote><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">grid-template-areas: <br>&quot;header header header&quot;<br>&quot;nav main main&quot;<br>&quot;footer footer footer&quot;;<br>定义三行三列,每个栅格都有名字, 系统会为区域自动命名, 例如 header-start    header-end  来表示header栅格区域  <br></code></pre></td></tr></table></figure></blockquote><blockquote><p><code>grid-template</code>简写模式:</p></blockquote><blockquote><p> grid-template:</p><pre><code>  &#39;栅格名称 栅格名称 栅格名称 栅格名称&#39; 行高  &#39;栅格名称 栅格名称 栅格名称 栅格名称&#39; 行高  &#39;栅格名称 栅格名称 栅格名称 栅格名称&#39; 行高/列宽 列宽 列宽 列宽;</code></pre><p><code>区域占位</code> :使用一个或多个 连续的. 定义区域占位。</p></blockquote></li><li><p><strong>填充栅格:</strong>    </p></li><li><p>使用栅格线:    （这些属性是用在子元素上的）</p><blockquote><p><code>grid-row-start/end</code>     行开始/结束的栅格线</p><p> <code>grid-column-start/end </code>   列开始/结束的栅格线</p><p>样式属性可以使用以下值:  <code>栅格线名字</code>、<code>span</code>  、<code>auto</code></p><p>span例子 :  grid-row-end/star: span 2 向下/上包含两行  (bootstarp 基于此开发栅格系统)</p></blockquote></li><li><blockquote><p><strong>方法简写::</strong>  <code>grid-row</code> 设置行开始栅格线，使用 <code>grid-column</code> 设置列结束栅格线。</p><p>例如 :  grid-row: 2/4;  grid-column: 2/4;</p></blockquote></li></ul><ul><li><p>使用区域:</p><blockquote><p>grid-area<code>更加简洁是同时对 </code>grid-row<code>与</code>grid-column` 属性的组合声明。</p><p>语法结构1: grid-row-start/grid-column-start/grid-row-end/grid-column-end。</p><p>语法结构2: 区域名字  例如 :   </p><p>grid-area: nav;   grid-area: header-start/nav-start/main-end/main-end</p></blockquote></li><li><p>填充栅格时,不要设置宽高 两个发生冲突,宽高属性优先级更高</p><hr></li></ul><ul><li><p><strong>栅格流动</strong> : </p></li><li><p>设置<code>grid-auto-flow</code> 属性可以改变单元格排列方式。</p><blockquote><p>参数说明: </p><p>column 按列排列    row    按行排列</p><p>dense    元素使用前面空余栅格</p></blockquote></li><li><p><strong>对齐管理:</strong></p></li><li><table><thead><tr><th>justify-content</th><th>所有栅格在容器中的水平对齐方式，容器有额外空间时</th><th>栅格容器</th></tr></thead><tbody><tr><td>align-content</td><td>所有栅格在容器中的垂直对齐方式，容器有额外空间时</td><td>栅格容器</td></tr><tr><td>align-items</td><td>栅格内所有元素的垂直排列方式</td><td>栅格容器</td></tr><tr><td>justify-items</td><td>栅格内所有元素的横向排列方式</td><td>栅格容器</td></tr><tr><td>align-self</td><td>元素在栅格中垂直对齐方式</td><td>栅格元素</td></tr><tr><td>justify-self</td><td>元素在栅格中水平对齐方式</td><td>栅格元素</td></tr></tbody></table></li><li><p><strong>自动排列:</strong></p><blockquote><p>当栅格无法放置内容时，系统会自动添加栅格用于放置溢出的元素，我们需要使用以下属性控制自动添加栅格的尺寸。</p><p><code>grid-auto-rows</code>控制自动增加的栅格行的尺寸，</p><p>grid-auto-flow:row时(默认值)    针对对象:容器</p><p><code>grid-auto-columns</code>控制自动增加的栅格列的尺寸，</p><p>grid-auto-flow: column时;    针对对象:容器</p></blockquote></li></ul><ul><li><p>终极简写: <code>grid</code>是简写属性</p></li><li><p>在不使用gird的情况下怎么创建网格布局: 可以利用div块 子元素的浮动属性,构建一个网格系统布局,但是这是固定的宽度,创建流体网格可以使用百分比设置宽度   flex也可以用来创建网格系统,但是flex仍然是一维设计的,用来处理网格还是需要计算width</p></li></ul><h3 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h3><ul><li><p><strong>相对定位:</strong></p></li><li><p>相对定位(relative positioning)让你能够把一个正常布局流中的元素从它的默认位置按坐标进行相对移动。</p></li><li><p><strong>绝对定位:</strong></p></li><li><p>元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移(如果没有就是html标签)，来确定元素位置。</p></li><li><p><strong>固定定位:</strong></p><blockquote><p>与绝对定位的工作方式完全相同,但是只有一个区别:</p><p>固定定位固定元素是相对于浏览器视口本身</p></blockquote></li><li><p><strong>粘性定位(sticky position)</strong> </p><blockquote><p>它基本上是相对位置和固定位置的混合体，它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点, 根据视口定位</p><p>例如，从视口顶部起10像素为止，此后它就变得固定了</p></blockquote></li></ul><ul><li><p>绝对定位的元素可以通过指定top和bottom ，来填充可用的垂直空间。</p></li><li><p>绝对定位元素的 top…值如果是百分比,则是非static定位的祖先元素的宽度 </p></li><li><p><strong>定位层级z-index：</strong></p></li><li><p>对于<strong>定位元素</strong>来说通过定义层级来决定谁的层级高, 默认后者高于前者 </p><blockquote><p><strong>同级的元素才有可比性</strong>,父子元素之间的z-index是失效的(除非子元素设置负值父元素设置auto)</p><p>对于同级元素说,z-index根据数值大小进行排列</p></blockquote></li><li><p>z-index 也支持过渡效果,它没有在每一步改变它的值(没有渐变效果)，所以你认为它没有过渡效果，但实际上是有的</p></li></ul><ul><li>对于float元素 z-index还有更复杂的状况.详细查询资料</li></ul><h3 id="多列布局-multicol"><a href="#多列布局-multicol" class="headerlink" title="多列布局 (multicol)"></a>多列布局 (multicol)</h3><ul><li><p><code>column-count</code>    <code>column-width</code> 属性把块变为多列容器</p><blockquote><p>column-width  浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p></blockquote></li><li><p>Multicol 创建的列无法单独的设定样式。 不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。</p><ul><li> <code>column-gap </code>改变列间间隙。</li><li> <code>column-rule </code>在列间加入一条分割线。</li></ul></li><li><p>多列布局的内容因为空间问题(分配内容是按一列一列的填充)被拆成多个内容(称为内容折断)  </p><blockquote><p>通过属性break-inside: avoid 在内容(子元素)中添加防止</p></blockquote></li></ul><h3 id="float-浮动"><a href="#float-浮动" class="headerlink" title="float 浮动"></a>float 浮动</h3><ul><li><p>浮动会改变该元素本身和在正常布局流中跟随它的其他元素的行为</p><blockquote><p>行级元素浮动后,可以设置宽高有了块级元素的特征 </p><p>浮动元素会提升层级压住标准元素, 元素向指定方向移动，直到遇见边框。 </p><p>浮动会脱离正常文档流,所以容器高度由最后一个非浮动元素的位置决定,</p></blockquote></li><li><p>浮动元素的外边距可以推开周围元素,但是周围元素无法设置外边距推开浮动元素,</p></li><li><blockquote><p>这里的周围元素仅限于 块级元素    原因: 块级元素不能推开在于,本质上块级元素还是独占一行,应用了外边距,但是是针对容器边框的,而行内元素的margin 是针对周边元素的</p><p>行内元素可以通过左右的外边距推开  inline-block 可以通过所有外边距推开</p></blockquote></li><li><p>浮动对块级元素并没有影响,只是对块级元素中的文本产生影响,而作用到块级元素,换句话说如果没有文本,块级元素会忽略浮动元素,出现在最初的位置</p></li></ul><ul><li><p><strong>清除浮动:</strong></p></li><li><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性。它将非浮动块的边框边界移动到<code>所有相关浮动元素</code>外边界的下方</p></li><li><p>容器自适应浮动元素</p><blockquote><ol><li>给父容器使用<strong>clearfix</strong> 方法,</li></ol><p>#container::after {<br>  content: ‘ ‘;<br>  display: block;<br>  clear: both;<br>}</p><ol start="2"><li>在容器的最后使用空的div块, 应用celar:both  自适应</li><li> 设置父元素 <code>overflow: auto</code> 或者设置其他的非默认的 <code>overflow: visible</code> 的值。 创建BFC</li></ol></blockquote></li></ul><h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><ul><li><p>(通常用于老的不支持 弹性盒子的浏览器)</p></li><li><p>display: table  display: table-row ..</p></li></ul><hr><h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><ul><li><p>响应式设计是三种技术的混合使用。</p><blockquote><p><code>流动布局</code>    <code>响应式多媒体</code>     <code>媒体查询</code></p></blockquote></li><li><p><strong>流动布局:</strong></p><blockquote><p>关键在于<code>流动性</code>,在任何宽度下都可以很好地适应, 而不是内容被隐藏</p><p>float  flex  grid 默认情况下都是流动的</p><p>在设计布局时,为了流动性,我们尽量不适用 固定的像素数值 ,而是百分比  em rem  vh vw..</p></blockquote></li><li><p>响应式排版的问题(主要是字体大小),不要使用像素值写死,这样在不同设备上的体验不好,使用 em 视口单位会更好</p></li></ul><ul><li><p><strong>媒体查询:</strong></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">媒体查询</a>可以应用于各种元素：</p><blockquote><p> 在&lt; link style source&gt;元素的media属性中定义了待应用的资源</p><p>在JavaScript中，您可以使用[`Window.matchMedia()](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia</a>) 方法根据媒体查询测试窗口,<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Testing_media_queries">查询方法</a></p></blockquote></li><li><p>语法格式 :</p></li><li><pre><code>@media media-type and (media-feature-rule) &#123;  /* CSS rules go here */&#125;常用的  media-type  all  print  screen<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>- 媒体查询的三种逻辑 与 或 非<br><br>- 媒体查询中的断点:  引入媒体查询的点就叫做**断点**。<br><br>- 媒体查询可以通过js css实现布局的变化,例如:导航栏在移动端收起为一个图标<br><br><br><br>- 你真的需要媒体查询吗？<br><br><span class="hljs-meta">  &gt;</span><span class="bash"> 流动布局在设计中是优先级最高的,媒体查询当成辅助来使用</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。</span><br><br>- 响应式设计方法: <br><br><span class="hljs-meta">  &gt;</span><span class="bash"> **第一种方法:** 你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；桌面端向下的方式</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; **第二种方法:**  你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。被叫做移动优先的响应式设计， 移动端向上</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; - 尽量使用移动端向上的方式进行，让那些不支持媒体查询的设配也可以获得一个较好的布局</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; ​</span>    <br><br>  <br><br>- **响应式的多媒体:**<br><br>- 响应式图像:<br><br><span class="hljs-meta">  &gt;</span><span class="bash"> 图像的二个问题:一个图像裁剪转换的问题(小设备看不到主要信息,需要裁剪出重要信息)</span> <br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt;  图像分辨率的问题(小设备上不需要加载高分辨率的图像,浪费带宽)</span><br><br>- &gt; 解决方法:    <br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 1. 准备两套图片  img元素通过 srcset  sizes属性根据尺寸切换</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 2. 利用&lt; picture&gt; 中的<span class="hljs-built_in">source</span>标签  通过他的media srcset属性实现</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt;    为什么不可以通过css  js 来实现响应式?</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt;    因为浏览器预加载 任意的图片 , 你不能先加载好 img 元素后, 再用 JavaScript 检测可视窗口的宽度，动态地加载小的图片替换已经加载好的图片，这就加载了两次</span><br><br>- 有选择性的为用户提供图片:<br><br><span class="hljs-meta">  &gt;</span><span class="bash"> 使用 display: none 图片也会在浏览器请求时加载,会发生隐藏但是浪费带宽</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 可以通过js  data-属性来控制 ,一开始不给与图片src地址, 在页面加载完之后再进行选择性的加载图片</span><br><br>- css像素  和 设备像素的区别<br><br>- 媒体查询的断点问题<br><br><span class="hljs-meta">  &gt;</span><span class="bash">  传统的断点是 320px 768px 1024px... 但是正确的方法应该是根据内容设置断点，通过对浏览器缩小放大，找到不合适的布局进行设置断点</span> <br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 传统的布局方法</span></span><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 旧浏览器支持</span></span><br>- **特性查询  :** 允许测试一个浏览器是否支持特定的一个css特性<br><br>- &gt; ```<br><span class="hljs-meta">  &gt;</span><span class="bash"> @supports (display: grid) &#123;</span><br><span class="hljs-meta">  &gt;</span><span class="bash">   .item &#123;</span><br><span class="hljs-meta">  &gt;</span><span class="bash">       width: auto;</span><br><span class="hljs-meta">  &gt;</span><span class="bash">   &#125;</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 指南</title>
    <link href="/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS%20%E6%8C%87%E5%AF%BC/"/>
    <url>/2021/02/21/Md%20CSS%E5%A4%95%E6%8B%BE/CSS%20%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS-指南"><a href="#CSS-指南" class="headerlink" title="CSS 指南"></a>CSS 指南</h3><ul><li>响应式 和 自适应的区别 </li></ul><p>响应式 :  改变布局  适配多种屏幕   <strong>流动</strong>的网格、<strong>灵活</strong>的图片和媒体查询是响应式网页设计的3个技术要素，</p><p>自适应 ,根据固定屏幕大小,使用多种不同的布局设计</p><p>另一种分别是平滑设计和快速设计的区别。响应式设计是平滑的，因为不管在什么设备上看，布局都可以流畅地调整。</p><p>适应性思维方式既不是流动的也不是灵活的，而是寻找适应的特定点,在特定点来适配</p><p><a href="https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/">响应式和自适应</a></p><p><a href="https://www.interaction-design.org/literature/article/adaptive-vs-responsive-design">响应式和自适应</a></p><p>自适应设计(理论上)将确保根据用户使用的接口设备提供最佳的用户体验。不像响应式设计，屏幕从桌面设计“流动”到更小的设备，自适应设计提供了量身定做的解决方案。</p><p>2011年，网页设计师Aaron Gustafson在他的书《自适应网页设计》里率先提出了自适应网页设计的概念。</p><p>Adaptive design (自适应设计)：为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。目前AWD网页主要针对这几种分辨率（320，480，760，960，1200，1600）</p><p>和响应式网页不同，自适应设计是基于断点使用静态布局，一旦页面被加载就无法再进行自动适应，自适应会自动检测屏幕的大小来加载适当的工作布局。</p><p>自适应设计的优势在于，它允许设计人员量身定制解决方案，从而使GUI在不同的屏幕尺寸上呈现最佳状态。 缺点是自适应设计的成本很高，</p><h4 id="CSS使用"><a href="#CSS使用" class="headerlink" title="CSS使用"></a>CSS使用</h4><ul><li>行内式  内嵌式   外部链接式 (rel href 必填项)</li></ul><h4 id="CSS工作原理-浏览器工作"><a href="#CSS工作原理-浏览器工作" class="headerlink" title="CSS工作原理(浏览器工作)"></a>CSS工作原理(浏览器工作)</h4><ul><li>简单的步骤 :  载入HTML,然后转化为DOM,拉取大部分资源(图片,视频,CSS),JS稍后进行处理. 拉取到CSS 后进行解析,并应用到DOM树上,这个步骤称为  <code>渲染树</code>,  根据渲染树进行布局,显示在网页上(着色)</li></ul><h4 id="层叠与继承-优先级"><a href="#层叠与继承-优先级" class="headerlink" title="层叠与继承 优先级"></a>层叠与继承 优先级</h4><ul><li><p><strong>优先级:</strong>   id&gt;class&gt;…  那个选择器更具体 那个优先级就高</p><blockquote><p>分为千位 百位  十位  个位,依次为:</p><p>style 声明属性    ID选择器    类选择器/属性选择器/伪类       元素/伪元素选择器</p><p>依次加1000  100  10 1, 按最后的结果获得权重值</p></blockquote><blockquote><p>通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, <code>&#39; &#39;</code>)，和否定伪类 (<code>:not</code>) 不会影响优先级。 <code>只根据有多少个选择器 多少元素 进行计算权重</code></p></blockquote></li><li><p><strong>层叠:</strong>  当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</p><blockquote><p>没有优先级权重时, 使用的是层叠规则</p></blockquote></li><li><p><strong>继承:</strong>  设置在父元素上的CSS属性是可以被子元素继承的，有些不行不如width border…</p><blockquote><p> 控制继承: </p><p>inherit 开启继承,使子元素属性和父元素相同, (<strong>默认值 inherit</strong>) </p><p>initial 设置属性和浏览器默认样式一样,没有默认样式改为 inherit</p><p>unset  : 如果属性是继承的就是inherit,不是就是initial,使用默认样式</p><p>属性值 : 控制属性值  =&gt; background-color: unset;    来控制属性的是否继承</p><p>也可以通过 all: 控制属性值, 对父元素所有的属性进行控制  , <strong>或者用来撤销对样式所做更改</strong>,    all: unset; 可以使得某个元素重置所有的样式为默认样式</p></blockquote></li><li><p><code>!important打破优先级使用该属性 覆盖!important 唯一的办法就是另一个 !important  </code></p></li><li><blockquote><p> !important 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难,建议不使用</p></blockquote></li></ul><ul><li><strong>有继承性的属性:</strong> 实践中寻找,最常见的有 字体属性   文本属性</li></ul><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul><li><p><strong>基本选择器:</strong></p><blockquote><p>元素、类、id选择器<br>标签属性选择器 : a[title]{}<br>伪类、伪元素选择器  :类   ::元素</p><p>全局选择器  *</p></blockquote></li><li><p><strong>选择器运算符:</strong></p><blockquote><p>交集选择器  <code>&#39;&#39;</code>   并集选择器 <code>,</code>   </p><p>后代选择器   <code>&#39; &#39;</code>   子元素选择器：<code>&gt;</code>   </p><p>相邻兄弟(后面紧跟的一个)选择器 <code>+</code>     通用兄弟(选择所有兄弟)选择器:  <code>~</code></p></blockquote><hr></li></ul><ul><li><p><strong>标签选择器详解:</strong></p><blockquote><p>[attr~=value]  含有一个value (不能是子字符串,但之间可以是空格隔开)  </p><p>[<em>attr</em>|=<em>value</em>] 含有value (不能是子字符串,但后面可以跟-字符)</p><p>[attr~=value] [attr^=value] [attr*=value]   </p><p>依次为 :  开头、结尾、字符串中匹配value的 属性</p><p>attr 可以换成 class     例如: li[class=”a”]</p></blockquote></li></ul><ul><li><p><strong>伪类 伪元素选择器详解 :</strong> </p></li><li><blockquote><p>伪类是选择器的一种，它用于选择处于特定状态的元素</p><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。</p></blockquote></li></ul><ul><li><p><strong>伪元素使用:</strong></p></li><li><p>例子 : <code>::first-line</code>伪元素选择器,会始终选择元素内的第一行,进行样式化,如果使用其他选择器无法实现, 因为不知道一行有多少个字段,如果使用span标签进行包裹,如果字段较多,他就会延展到第二行, 无法只给第一段应用样式.</p><blockquote><p> 有一组特别的伪元素<code>::before</code>和<code>::after</code>，它们和<code>content</code>属性一同使用，使用CSS将内容插入到你的文档中中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.box::<span class="hljs-keyword">after</span>&#123;<br> content: &quot;This should show before the other content.&quot;<br>&#125;   <br>&lt;p <span class="hljs-keyword">class</span>=&quot;box&quot;&gt;Content <span class="hljs-keyword">in</span> the <span class="hljs-type">box</span> <span class="hljs-keyword">in</span> my HTML page.&lt;/p&gt;<br>//<span class="hljs-keyword">after</span>加载内容后面  <span class="hljs-keyword">before</span>相反<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>这些伪元素的更推荐的用法是插入一个图标</strong>, 这些伪元素经常用于插入空字符串,然后对空字符串进行样式化,可以给他一个宽高 和背景就会形成一个图形</p></li><li><blockquote><p>其余的伪元素 : <code>::first-letter</code>第一个字母 <strong><code>::selection</code></strong> 应用被高亮的部分(鼠标选择)</p></blockquote></li></ul><ul><li>伪类选择器和伪元素可以组合使用 , 但不能嵌套使用(比如:not()的参数)</li></ul><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ul><li><p>盒子分为：块级盒子（Block box)和  内联盒子（Inline box） </p></li><li><p><strong>块级盒子:</strong></p><blockquote><p>在内联的方向上扩展并占据父容器的所有可用空间:  简单说,占据父容器所有的宽度</p><p>发生换行   宽高   padding  border margin 发挥作用</p></blockquote></li><li><p><strong>内联盒子:</strong></p><blockquote><p>不会产生换行   width 和 height 属性将不起作用 </p><p>垂直方向的padding 、margin以及border会被应用但是推不开其他的盒子</p><p>水平方向的可以推开</p></blockquote></li><li><p><strong>inline-block盒子:</strong></p><blockquote><p>外部表现为 inline 不会换行 , 但是可以设置宽高  设置四个方向的padding 、margin以及border 可以推开盒子</p><p>相当于内联 和 块级的 中和的产物</p></blockquote></li><li><p>CSS的盒子模型有<strong>内部</strong>和<strong>外部</strong>显示类型 ，外部显示类型，来决定盒子是块级还是内联。内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局 (块级和内联布局), </p><blockquote><p>特殊的 display: flex, 外部显示类型是 block，但是内部显示类型修改为 flex。</p><p>标准的  inline-block   inline-flex</p></blockquote></li></ul><ul><li><p><strong>盒子模型分为 标准盒模型   替代盒模型</strong> </p><blockquote><p>区别在于标准盒模型计算盒子大小是 内容加上 padding border</p><p>替代盒模型: 设置box-sizing: content-box(默认值)/ border-box </p><p>content-box : 设置的宽/高度只有内容</p><p> border-box :宽/高度包含边框</p></blockquote></li></ul><h5 id="padding、margin、border"><a href="#padding、margin、border" class="headerlink" title="padding、margin、border"></a>padding、margin、border</h5><ul><li><p><strong>margin(外边距):</strong></p></li><li><p><code>margin-left:atuto</code>   :  会占据这个方向的剩余空间的宽度,用来让某一项顶到边框</p></li><li><p><strong>外边距外边距margin 折叠问题:</strong></p></li><li><blockquote><p>注意有设定<code>float</code>和<code>position=absolute</code>的元素不会产生外边距重叠行为。脱离文档流不存在此问题</p></blockquote><blockquote><ol><li>同一层相邻元素之间的外边距重叠:</li></ol><p>外边距合并：相邻元素margin-top 和margin-bottom 长度会合并成两者间较大的数值，如果有负值就是两者的和,两者都为负值就取绝对值最大的<br><strong>解决:</strong> 后一个元素 设置 inline-block</p><ol start="2"><li>没有内容将父元素和后代元素分开:</li></ol><p>如果没有设置边框border-top，内边距padding-top，行内内容(文字)，也没有创建块级格式上下文或清除浮动,那么margin-top就会折叠 .对于margin-bottom 也适用上面的判断,区别在于 高度也是margin-bottom的判断标准</p><p>较大的值最终会溢出到父级块元素外面。表现为父元素移动了溢出的值</p><ol start="3"><li>空白块</li></ol><p>当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素<strong>完全没有设定</strong>边框border、内边距paddng、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。(不太理解)</p><ul><li>上述情况的组合会产生更复杂的外边距折叠。</li></ul></blockquote></li></ul><ul><li><p><strong>padding(内边距):</strong></p></li><li><p>应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p><blockquote><p>padding可以撑大元素的尺寸，背景会随着撑大元素的尺寸而扩大</p></blockquote></li></ul><h5 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h5><ul><li><p>块格式化上下文（Block Formatting Context，BFC)，<strong>是块盒子的布局过程发生的区域</strong>，也是浮动元素与其他元素交互的区域。</p><blockquote><p><strong>浮动定位</strong> 和 <strong>清除浮动</strong> 时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</p><p>外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间</p></blockquote></li></ul><ul><li><p>创建BFC方法: </p><blockquote><p>在父级块中使用 display: flow-root 可以无副作用的创建新的 BFC。还能够使正常块级元素可以推开浮动元素,(默认情况是重叠的)</p><p>overflow 值不为 visible 的块元素 绝对定位元素  行内块元素 浮动元素…</p><p>更多创建BFC方法参考 MDN  </p></blockquote></li><li><p>BFC可以解决了 <code>高度塌陷</code>  <code>外边距折叠问题</code></p><blockquote><p>在文档流中，父元素的高度默认是被子元素撑开的，当为子元素设置浮动以后，子元素会完全脱离文档流，此时就会导致子元素无法撑起父元素的高度，此引发父元素的高度塌陷</p></blockquote></li></ul><h4 id="隐藏标签"><a href="#隐藏标签" class="headerlink" title="隐藏标签"></a>隐藏标签</h4><ul><li><p><code>display:none</code>   不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。</p></li><li><p><code>visible:hidden</code> 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。这是个继承元素</p><blockquote><p>元素使用<code>visibility:hidde</code>时 如果在设置:hover状态,这是不会触发,因为这时已经隐藏不可能触发</p></blockquote></li><li><p><code>opacity : 0</code> , 不可见,但保留位置</p></li></ul><h4 id="样式化文本"><a href="#样式化文本" class="headerlink" title="样式化文本"></a>样式化文本</h4><ul><li><strong>字体</strong></li></ul><ul><li><p>浏览器的 <code>font-size</code> 标准设置的值为 16px, 建议把根元素的font-size 调成10px,这样可以更方便的使用 em rem计算font-size值</p></li><li><blockquote><p>font-style 打开关闭斜体<br>font-weight 设置字体粗细<br>text-decoration  设置文本划线 上下中划线…<br>text-transform: 转换文本的大小写,全半角 </p><p>text-shadow 文本阴影 : </p></blockquote></li><li><h4 id="网络字体-在CSS的开始处有一个-font-face块，它指定要下载的字体文件"><a href="#网络字体-在CSS的开始处有一个-font-face块，它指定要下载的字体文件" class="headerlink" title="网络字体:  在CSS的开始处有一个@font-face块，它指定要下载的字体文件"></a>网络字体:  在CSS的开始处有一个@font-face块，它指定要下载的字体文件</h4></li></ul><ul><li><p><strong>文本布局</strong></p><ul><li><p><code>text-align</code> 用来控制行内内容(文本/节点..)如何和它所在的内容盒子(有宽度的块级元素)对齐</p><blockquote><p>在内容盒子中对齐,会改变行内元素的内联,比如左对齐,每个行内元素都独占一行</p></blockquote></li><li><p><strong><code>vertical-align</code></strong> 用来指定<strong>行内元素</strong>（inline）或<strong>表格单元格</strong>（table-cell）元素的垂直对齐方式。</p><blockquote><p>   垂直方式根据  行内元素基线相对于元素所在行的基线, 进行调整    </p><p>  该属性对块级元素是不能使用的</p></blockquote></li><li><p><code>letter-spacing </code> 字母之间间距  <code>word-spacing</code>单词与单词之间的间距</p></li><li><p><code>text-overflow:</code> 定义如何向用户表示存在被隐藏的溢出内容。</p><blockquote><p>这个属性只对那些在块级元素溢出的内容有效，<strong>但是必须要与块级元素内联(inline)方向一致</strong>（举个反例：内容在盒子的下方溢出。此时就不会生效）。</p><p>对于多行文本的向下溢出无法处理</p></blockquote></li><li><p><code>white-space:</code> 处理元素内部文本的空白和换行。</p></li><li><p><code>word-break:</code> 是否能在单词内部断行。</p><blockquote><p>对于中文来说可以在任意处断行,所以在处理一串英文时需要加上该属性值,否则他不会换行的</p></blockquote></li><li><p><code>text-orientation</code>: 定义行内文本的方向。</p></li><li><p><code>word-wrap(overflow-wrap):</code> 指定是否可以在单词内换行以避免超出范围。</p><blockquote><p>和word-break的区别时在于, word-wrap会尽量保证单词的完整性的情况下断行,word-break会在只要可以断行的时候断行writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向</p></blockquote></li></ul></li></ul><ul><li><p>height = line-height时 文字垂直居中显示</p></li><li><p>内联元素的高度有其中的文本内容 的font-size line-height共同决定, 如果字体大小比行高小一定的值,那高度就是行高</p></li><li><p>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。</p></li><li><p>text-indent 属性能定义一个块元素首行文本内容之前的缩进量。设置负值用来移出文档显示,块内元素中如果有内联元素例如 img span等,会移出文档,  该属性为继承属性 ,对内联元素中的内容无效</p></li><li><p>vertical-align 用于以下两种情况  1.使行内元素盒模型与其行内元素容器垂直对齐</p></li><li><p>2.垂直对齐表格单元内容:</p></li><li><p>vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。</p></li><li><p>margin取负值margin-left 和 margin-top：影响自身元素，自身元素将向指定方向偏移margin-bottom将影响后元素，使后元素向上偏移对应像素</p></li><li><p>多个内联文本有一个设置上外边距值 会一起移动, 内联元素布局默认是一指的</p><h4 id="样式化列表"><a href="#样式化列表" class="headerlink" title="样式化列表"></a>样式化列表</h4></li><li><blockquote><p><code>list-style-type</code> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。<br><code>list-style-position </code>：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。<br><code>list-style-image</code> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。<br>速记属性 list-style 完成以上三个的设置</p></blockquote></li></ul><ul><li><p><code>ul ol</code>属性  </p><blockquote><p>start 属性允许你从1 以外的数字开始计数  </p><p>reversed 属性将启动列表倒计数</p><p>li中 的value 属性允许设置列表项指定数值</p></blockquote></li></ul><h4 id="样式化链接"><a href="#样式化链接" class="headerlink" title="样式化链接"></a>样式化链接</h4><ul><li>链接状态 通过伪类进行设置<ul><li>Link (没有访问过的): 这是链接的默认状态 </li><li>Visited: 这个链接已经被访问过了</li><li>Hover: 当用户的鼠标光标刚好停留在这个链接</li><li>Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab  移动到这个链接的时候)</li><li>Active: 一个链接当它被激活的时候 (比如被点击的时候)</li></ul></li></ul><h4 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h4><ul><li><p>使用<code>table-layout: fixed</code>创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。</p><blockquote><p><strong>默认情况下表格及单元格的宽度取决于其包含的内容。</strong></p></blockquote></li><li><p>使用<code>border-collapse: collapse</code>使单元格边框塌陷,使得多个边框合并成一条</p></li><li><p><code>caption-side属性</code> : 会将表格的标题&lt; caption&gt; 放到规定的位置</p></li></ul><h4 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h4><ul><li><p>background 属性</p></li><li><blockquote><p><code>-clip </code> 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。   border-box  padding-box content-box</p><p><code>-origin</code> 指定背景图片的原点位置,   从边框开始;从内边距开始  从内容开始 content-box;  (默认在左上角)  border-box  padding-box content-box</p><p><code>-position </code>选择背景图像显示在其应用到的盒子中的位置, 默认是框的左上角(0,0),</p><blockquote><p>这个位置是相对于由 background-origin 定义的位置图层的。</p><p>百分比值0%代表图片和容器左/上边界重合  100%左上边界和容器的右/下重合</p><p>指定关键字 top, left, bottom, right 中的一个,另一个维度被设置成 50%，</p></blockquote><p><code>-repeat</code>  背景图像可以沿着水平轴/垂直轴重复，或者根本不重复,或者都重复</p><p><code>-size</code>   1个值指定图片的宽  2个值指定宽和高;</p><blockquote><p>cover 拉伸到新的尺寸覆盖容器全部空间<br>contain 按原有比例缩放到可用空间的尺寸,不一定能够覆盖完容器  </p></blockquote><p><code>-attachment</code>    指定内容滚动,背景如何滚动</p><blockquote><p>fixed 表示背景相对于视口固定,背景不会随着内容滚动<br>local 背景相对于<strong>元素内容</strong>固定,它会随着内容滚动    </p><p>scroll 背景相对于<strong>元素本身</strong>固定,而不是随着它的内容滚动</p></blockquote></blockquote></li></ul><ul><li><p>opacity属性指定了一个元素的透明度, 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待, 即使这个值没有被子元素继承</p></li><li><blockquote><p>因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值</p></blockquote></li><li><p>使用opacity属性，当属性值不为1时，会把元素放置在一个新的层叠上下文中。</p></li></ul><h4 id="处理不同方向的文本"><a href="#处理不同方向的文本" class="headerlink" title="处理不同方向的文本"></a>处理不同方向的文本</h4><ul><li>CSS中的书写模式是指文本的排列方向是横向还是纵向的。</li><li>writing-mode 属性使我们从一种模式切换到另一种模式,</li><li>horizontal-tb模式,水平方式写入，写入方向从top到bottom</li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul><li><p>我们通过给width和height（或者 inline-size 和 block-size）来约束盒子的尺寸。但是内容过多时,内容(例如文本会超出宽度显示)就会溢出</p></li><li><blockquote><p>溢出的内容不会当做盒子的尺寸,也就是说如果有行内元素的话,可能会忽略溢出内容,覆盖内容</p></blockquote></li></ul><ul><li><p>只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。通过<code>overflow</code> ``overflow-x/y`属性控制元素溢出的方式，</p><blockquote><p>hidden : 隐藏     scroll: 滚动来显示内容     visible(默认值):显示数据  </p></blockquote></li><li><p>溢出建立了块级排版上下文 BFC，在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。</p></li></ul><h4 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h4><ul><li><p>在CSS中使用了各种数值数据类型 :数字 长度 百分比</p></li><li><p>长度分为绝对长度 相对长度</p><blockquote><p>常用的绝对长度: px</p><p><strong>相对长度:</strong> </p><p>使用相对单位的好处是,可以使文本或其他元素的大小与页面上的其他内容相对应。</p><p><code>em</code> :  在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小,例如height</p><p><code>rem</code>: 根元素的字体大小</p><p><code>lh</code>:元素的line-height     <code>vw</code>: 视窗的高度的1%  <code>vh</code>:视窗高度的1%</p></blockquote></li><li><p>如果使用百分比作为大小，那么它将是父元素大小的百分比。</p><blockquote><p>body,html 百分比,是针对浏览器可视窗口的宽度高度</p></blockquote></li></ul><h4 id="调节项目大小"><a href="#调节项目大小" class="headerlink" title="调节项目大小"></a>调节项目大小</h4><ul><li><p>在受CSS设置影响之前，HTML元素有其<code>原始的尺寸</code>,</p><blockquote><p>比如  Img的固有尺寸是图片的尺寸, div块高由内容决定</p><p>元素的<strong>固有尺寸</strong> — 由其所包含的内容决定。对于块级元素来说内容只影响它的高度,宽度默认独占一行</p></blockquote></li><li><p>当你用百分数设定内外边距的时候，值是以<strong>内联尺寸</strong>进行计算的，也即对于左右书写的语言来说的宽度(浏览器视口的宽度)。而不是元素的尺寸大小</p></li></ul><ul><li><p>min-和max-尺寸:</p><blockquote><p>你有一个<code>变化容量</code>的盒子,但你想让它<strong>至少</strong>有个确定的高度,你应该给它设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><p>设定一个img的属性为width: 100%,那么它会充满整个容器,</p><p>max-width: 100%,那它最大只能是图片的原始尺寸</p></blockquote></li><li><p>min-和max-尺寸 这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p></li></ul><h4 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h4><ul><li><p>object-fit属性  指定 可替换元素 的内容应该如何适应到其使用的高度和宽度确定的框</p><blockquote><p><strong>contain</strong>: 保持宽高比 进行缩放   <strong>cover</strong>:保持宽高比,填充  <strong>fill</strong>: 填充不保持宽高比</p></blockquote></li><li><p>在替换元素使用各式CSS布局技巧时，你可能深切地体会到他们的展现略微与其他元素不同，</p></li><li><blockquote><p>记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为</p></blockquote></li><li><blockquote><p>例如，在一个flex或者grid布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。</p></blockquote></li></ul><h4 id="CSS预处理和后处理"><a href="#CSS预处理和后处理" class="headerlink" title="CSS预处理和后处理"></a>CSS预处理和后处理</h4><ul><li>Sass   预处理  </li><li>cssnano 后处理  你对加入例如许多额外的注释和空格，增大你的样式表大小有所关心的话，那么后处理会通过在生产版本中略去任何不必要的东西的方式</li></ul><h5 id="块级元素-行内元素互相嵌套问题"><a href="#块级元素-行内元素互相嵌套问题" class="headerlink" title="块级元素 行内元素互相嵌套问题"></a>块级元素 行内元素互相嵌套问题</h5><ul><li><p>以上问题都是 没有设置外部容器的宽高的情况</p></li><li><p><strong>内联元素嵌套块级元素</strong></p></li><li><p>块级元素无法撑开内联元素,但是例如 cursor: pointer /a便签 发生区域还是被撑大了, 而且不能覆盖块元素的性质, 它还是会独占一行, 因为没有尺寸背景色无法应用</p></li><li><blockquote><p>img 元素 也可以撑开内联元素,但是情况和上面一样,尺寸不正确,是默认的尺寸</p><p>个人理解,内联元素只能被文本撑开</p></blockquote></li><li><p>解决方法: </p><blockquote><p>把外层的内联元素换成 inline-black元素</p></blockquote></li></ul><ul><li><p><strong>块级元素嵌套内联元素</strong></p></li><li><p>有内容的内联元素可以撑开块级元素,</p></li><li><p>没有内容的内联元素,比如img 不能正好的撑开块级元素,会有缝隙,</p></li><li><p>解决方法:</p><blockquote><p>设置内部为块级元素就可以撑开 </p><p>外部设置宽度 img 100%</p></blockquote></li></ul><ul><li>只有块级元素之间能正好的撑开元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT 教程</title>
    <link href="/2021/02/21/Git/GIT%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/21/Git/GIT%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>重要概念:</p><ul><li>三方合并原则</li><li>git 提交的本质</li><li>git 操作和指针之间的关系…</li><li>冲突合并</li><li>什么时候冲突</li></ul><h3 id="git-分区"><a href="#git-分区" class="headerlink" title="git 分区"></a>git 分区</h3><ul><li><p>工作区 (working directory)  暂存区(stage)   版本库</p><blockquote><p>关系:  工作区  add  暂存区  commit  版本库</p></blockquote></li><li><p><code>git status </code>:可以追踪工作区的文件 ,红色文件代表工作区 绿色文件代表暂存区</p></li></ul><ul><li><p><code>git add ...</code>   使文件加入暂存区，被纳入版本控制，修改时可以被追踪</p></li><li><p>显示 new file,对其更改，删除，更改会显示modified状态，可以再次add把已修改的文件加入暂存区，然后进行提交，通过 checkout可以恢复，也可以通过reset不暂存，不暂存的话就变成了未追踪状态，可以重复以前的操作。 删除和更改操作一样，当删除过后，如果利用reset就会撤销暂存，并且文件无法恢复</p></li><li><p><code>git commit  -m&#39;注释&#39; </code>    加入版本库   更改删除发生状况，首先把文件全部提交完后当本地仓库和工作区同步时，则status什么都不显示,当更改后必须重新通过add加入暂存然后再次commit ，或者通过checkout（从暂存区？）恢复文件，删除情况与更改一样</p><blockquote><p><code>git commit -am &#39;注释&#39;</code>    即相当于是**<code>git add .</code>** 与 <strong><code>git commit</code></strong> 两步操作的合成</p></blockquote><blockquote><p><strong>该方式只适用于已被<code>git</code>追踪的文件（即文件至少提交过一次）</strong></p><p><strong>当文件第一次提交到暂存区时（此时该文件并未被<code>git</code>追踪）不可以使用该命令，而是要分开写，否则会报错</strong></p></blockquote></li></ul><h4 id="Git-日志"><a href="#Git-日志" class="headerlink" title="Git 日志"></a>Git 日志</h4><ul><li><p>主要分为三大类：分支的<strong>提交日志</strong>、文件的<strong>修改日志</strong>、<code>git</code>的<strong>操作日志</strong></p></li><li><p><code>git log</code>  查看版本库提交日志 ,提交历史是倒叙的，最新的提交排在最前面</p><blockquote><p><code>git log -3</code>最近几条  <code>git log --graph</code>  图形化显示提交历史</p><p><code>git log --pretty=oneline</code>   以一行的形式显示提交历史</p><p><code>git log --all --decorate --oneline --graph</code>  </p></blockquote></li><li><p><code>git blame file_name</code>   查看修改日志</p></li><li><p><code>git reflog</code>  查看操作日志</p><blockquote><p>区别: <strong><code>git log</code>**：只能显示</strong>当前分支**的提交历史，如果进行版本回退，会丢失较后版本的提交信息 这时通过操作日志进行查看..</p><p>总体上来说，操作日志包含了修改日志和提交日志，是最全的<code>git</code>日志</p></blockquote></li></ul><h3 id="git-删除、修改、撤销"><a href="#git-删除、修改、撤销" class="headerlink" title="git 删除、修改、撤销"></a>git 删除、修改、撤销</h3><ul><li><p><code>git rm &lt;file&gt;</code>   <strong>该命令用于删除版本库中的文件</strong>；如果用来删除工作区和暂存区中的文件都会报错</p><blockquote><p>本质上是两步操作 :  删除版本库中的文件, 把删除更改状态加入暂存区</p><p><code>git rm --cached &lt;file&gt;</code>    只删除暂存区的file文件 ,不在追踪该文件</p></blockquote></li><li><p><code>rm &lt;file&gt;</code>  命令只能用于删除工作区和版本库中的文件, 不能删除暂存区文件</p><blockquote><p>与<code>git rm</code><strong>不同的是</strong>，该指令不会将删除操作纳入<strong>暂存区</strong>。</p></blockquote></li></ul><h4 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h4><ul><li><code>git mv &lt;file1&gt; &lt;file2&gt;</code>  该命令会把重命名操作状态纳入暂存区</li><li><code>mv &lt;file1&gt; &lt;file2&gt;</code> 系统命令  和git命令区别在于不会将操作提交到暂存区</li></ul><h4 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h4><ul><li><p>系统命令 <code>diff  file1 file2</code> 比较本地文件</p></li><li><p>比较<strong>暂存区</strong>和<strong>工作区</strong>中的同一文件</p><blockquote><p><code>git diff</code>  该命令自动比较 工作区的修改后的文件 和暂存区的目标文件 </p></blockquote></li><li><p>比较<strong>版本库</strong>和<strong>工作区</strong>中的同一文件</p><blockquote><p><code>git diff commit_id</code>  用于比较指定commit id提交上的<code>A</code>文件和工作区中的<code>A</code>文件</p><p><code>git diff HEAD</code>  用于比较最新提交上的<code>A</code>文件和工作区中的<code>A</code>文件</p></blockquote></li><li><p>比较<strong>版本库</strong>和<strong>暂存区</strong>中的同一文件</p><blockquote><p><code>git diff --cached commit_id</code>  </p><p><code>git diff --cached</code>     作用和上一部分一样</p></blockquote></li></ul><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><ul><li><p><strong>将暂存区恢复到工作区</strong>:</p><blockquote><p>将已经纳入<strong>暂存区</strong>的修改撤销，恢复到<strong>工作区</strong>修改但没有提交的状态，再恢复到修改前</p></blockquote></li><li><blockquote><p><code>git restore --stage &lt;file&gt;</code>  将文件从<strong>缓存区</strong>中移动到<strong>工作区</strong>参数<code>--stage</code>写成<code>--staged</code>效果是一样的</p><p><code>git reset HEAD &lt;file&gt;</code>  </p></blockquote></li><li><p><strong>撤销工作区的操作</strong></p><blockquote><p>撤销工作区中对文件的操作，包括新增、修改、删除等</p><p>原理: 使用暂存区的文件进行比对, 对工作区进行回滚, 所有提交到暂存区后就无法改变修改</p></blockquote></li><li><blockquote><p><code>git checkout -- &lt;file&gt;</code>  可以撤销工作区中对<code>flie</code>文件的改动操作, <code>--</code>后面加上空格, 修改如果通过git add 提交到暂存区,该指令无效</p><p><code>git restore &lt;file&gt;</code>  可以撤销<strong>工作区</strong>中对<code>file</code>文件的操作,效果和上式相同</p></blockquote></li></ul><h4 id="修改提交注释和作者"><a href="#修改提交注释和作者" class="headerlink" title="修改提交注释和作者"></a>修改提交注释和作者</h4><ul><li><p><code>git commit --amend -m</code> ‘修正信息’</p><blockquote><p>当需要为最近一次提交添加大量注释时: <code>git commit --amend</code></p></blockquote></li><li><p><code>git commit --amend --author &#39;Name&lt;email&gt;&#39;</code></p></li><li><blockquote><p>修改提交注释的同时，会创建了一个新提交替换了原来需要修正的提交, 也就是说日志中只有一次提交而不是两次</p></blockquote></li><li><p>修改特定提交信息</p><blockquote><p><code>git rebase -i commit_id</code> </p><p><code>git rebase -i HEAD~n</code>   其中<code>n</code>表示需要显示的最近<code>n</code>次提交记录</p></blockquote></li></ul><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><ul><li><code>git config help </code> 跳转网页 获取config命令的说明</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><p>在开发当中，往往需要分工合作,<code>git</code>为我们提供的分支功能就能实现这一需求</p></li><li><blockquote><p><code>git branch</code>  查看当前版本库中的所有分支</p><p><code>git branch -a</code>  查看所有本地分支，包括本地分支和本地远程分支</p><p><code>git branch -v</code>   查看所有本地分支上最近一次的提交记录</p><p><code>git branch -av</code>    查看所有分支的最近一次提交记录</p><p><code>git branch -r</code>   参数用于单独查看本地远程分支</p><p><code>git branch -vv</code>   表示查看所有本地分支与远程分支的关联情况</p></blockquote></li><li><p><strong>本地分支</strong></p></li><li><blockquote><p><code>git branch &lt;branch_name&gt;</code>    创建分支</p><p><code>git checkout -b &lt;branch_name&gt;</code>  创建并切换到新的分支</p><p><code>git checkout &lt;branch_name&gt;</code>  切换分支</p><p><code>git checkout -</code>  切换回上次操作的分支：</p></blockquote></li><li><p><strong>重命名分支</strong>: <code>git branch -m &lt;oldName&gt; &lt;newName&gt;</code></p></li><li><p><strong>删除本地分支:</strong>  <code>git branch -d new_branch</code>  </p><blockquote><p>不能删除本地分支 ,</p><p>当需要删除的分支上有<code>master</code>分支没有的内容，并且删除前没有进行合并（<code>merge</code>）时，会报错  提示参数改为 D</p></blockquote></li><li><p>分支合并</p><blockquote><p><code>git merge &lt;branch_name&gt;</code> 这里所讲的分支指的是有公共提交节点的分支</p><p>当两分支没有公共提交节点 采用<code>rebase</code>进行合并</p></blockquote></li><li><p><code>git merge</code>原理</p><blockquote><p> 这种合并方式叫做：<code>Fast-forward</code>，<strong>没有冲突</strong>，改变的只是<code>master</code>指针指向</p><p><code>git merge --no-ff dev</code>  禁用Fast-forward模式, 会触发一次提交,而不是改变指针</p><p>注意两者的区别</p></blockquote></li></ul><ul><li><p>分支合并原则</p></li><li><p>分支的本质</p><blockquote><p><strong>分支：指向一条<code>commit</code>对象链或一条工作记录线的指针</strong>   </p><p><code>HEAD</code>始终指向当前分支</p><p>对于<code>HEAD</code>修改的任何操作，都会被<code>git reflog</code> 记录下来</p></blockquote></li><li><blockquote><p>我们可以通过<code>git</code>的底层命令<code>symbolic-ref</code>来实现对<code>HEAD</code>文件内容的修改</p></blockquote></li></ul><ul><li><p>合并冲突</p><blockquote><p>分别对两分支上的<code>test.txt</code>文件进行修改，并分别将修改<strong>提交</strong>到各自的分支,会发生合并冲突, 因为 <code>git</code>合并时并不知道以哪个分支的修改为标准,不能采用<code>Fast-forward</code>方式自动合并</p></blockquote></li><li><p>解决冲突</p><blockquote><p><strong>选择需要保留的内容，手动解决合并冲突</strong> ,只需要在文件中保留想要的内容即可,</p><p>然后使用add把修改提交到暂存区, 通过commit提交完成合并(merge)</p><p>一般情况下 我们使用工具解决冲突</p></blockquote></li><li><p>合并分支的实质就是不同提交的合并，以及<code>HEAD</code>和分支指针的移动；</p></li></ul><h3 id="远程仓库github、git图形"><a href="#远程仓库github、git图形" class="headerlink" title="远程仓库github、git图形"></a>远程仓库github、git图形</h3><ul><li><p><code>git</code>裸库 : 没有工作区的<code>git</code>仓库 , 只起到代码托管的作用而不需要也不应该修改服务器上的代码。</p><blockquote><p><code>git init --bare</code>   创建裸库</p></blockquote></li><li><p>本地仓库与远程版本库</p><blockquote><p>远程仓库的实质就是本地仓库中的<strong>版本库</strong>对应的<strong>远程版本库</strong>，通常直接叫做<strong>远程仓库</strong>。</p></blockquote></li><li><blockquote><p><code>git push</code>：将<strong>本地仓库某分支</strong>上的代码推送到<strong>远程仓库的某分支</strong>上, 推送操作是分支对分支的,而不是将本地仓库的所有分支都推送到远程仓库</p><p><code>git pull</code>:  将远程仓库文件拉取到本地版本库</p></blockquote></li><li><p><code>push、pull</code>完整的写法</p><blockquote><p>git push origin srcBranch:destBranch   <code>srcBranch</code>表示的是<strong>本地分支</strong>，<code>destBranch</code>表示的是<strong>远程分支</strong></p><p>git pull origin srcBranch:destBranch   <code>srcBranch</code>表示的是<strong>远程分支</strong>，<code>destBrach</code>表示的是<strong>本地分支</strong>；</p><p>可以这样理解：<code>srcBranch</code>表示<strong>从哪里来</strong>，<code>destBranch</code>表示<strong>到哪里去</strong>； </p></blockquote></li><li><p><code>git push</code></p><blockquote><p>特殊的情况 : 只有一个用户操作远程仓库, 手动的改变远程仓库文件, 而不通过本地推送来改变远程仓库文件,再次推送时会出现错误, 必须先进行pull操作,这时本地才会追踪修改的操作</p><p>多人共用同一远程仓库, 用户需要在pull操作之后 再次进行push, 如果直接推送发生错误,原因在于：不能覆盖别的用户做出的文件修改, 需要pull 之后进行merge操作 </p></blockquote></li><li><p><code>git pull</code> </p><blockquote><p>在进行拉取操作的过程中,会执行合并操作（<code>merge</code>）合并操作可能成功也可能失败</p><p><code>pull</code>操作其实是<code>fetch</code>操作和<code>merge</code>操作的合成</p></blockquote></li><li><h4 id="推送代码"><a href="#推送代码" class="headerlink" title="推送代码"></a>推送代码</h4><blockquote><p><code>git push -u origin master</code>    加上<code>-u</code>表示将本地的<code>master</code>分支与远程的<code>master</code>分支<strong>建立关联</strong>；再次推送时就可以直接通过<code>git push</code>进行推送了。</p></blockquote></li><li><p><strong>查看远程仓库地址</strong></p><blockquote><p><code>git remote</code> //只显示远程仓库地址名</p><p><code>git remote -v</code> //显示远程仓库地址名和对应URL </p><p><code>git remote show origin</code> //显示详细信息</p></blockquote></li><li><p>修改远程仓库</p><blockquote><p>方法一:</p><p><code>git remote rm origin </code></p><p><code>git remote add origin https://gitee.com/ahuntsun/gitTest.git</code></p><p>方法二 :</p><p><code>git remote set-url origin https://163.com</code></p><p>方法三: 修改.git中的config仓库</p></blockquote></li><li><p>SSH协议建立本地和远程仓库的联系</p></li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li><p>在<code>git</code>中永远有后悔药可吃，总是可以回到<strong>版本库</strong>的某一个时刻，这就叫做<strong>版本回退</strong></p></li><li><p><code>git reset</code>   常用的有<code>--mixed</code>、<code>--soft</code>和<code>--hard</code>三种参数</p><blockquote><p><code>--mixed</code> 将文件回退到<strong>工作区</strong>，此时会保留<strong>工作区</strong>中的文件，但会丢弃<strong>暂存区</strong>中的文件  为默认值，等同于<code>git reset</code></p><p><code>--soft</code>：作用为：将文件回退到<strong>暂存区</strong>，此时会保留<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</p><p><code>--hard</code>：作用为：将文件回退到<strong>修改前</strong>，此时会丢弃<strong>工作区</strong>和<strong>暂存区</strong>中的文件；</p></blockquote></li><li><blockquote><p>使用 <code>git reset --soft head^ </code>    <strong>回退一次</strong></p><p><code>git reset --hard HEAD^^ </code>  回退二次</p><p><code>git reset --hard HEAD~n</code>  回退n次</p><p> <code>HEAD</code>可以更换为分支名</p><p><code>git reset --hard commit_id</code>     **该指令的作用为回退到指定的<code>commit id</code>  (一般前6位)的提交版本 **</p><p>通过<code>commit id</code>的回退方式<strong>既可以向前回退，也可以向后回退。</strong></p></blockquote></li><li><p><code>git revert</code>    不同于<code>reset</code>直接通过改变分支指向来进行版本回退，并且不产生新的提交；<code>revert</code>是通过额外创建一次提交，来取消分支上指定的某次提交的方式，来实现版本回退的</p><blockquote><p><code>-e</code>参数是<code>--edit</code>的缩写，为<code>revert</code>指令的默认参数，即<code>git revert -e</code>等同于<code>git revert </code>    在重做过程中，新建一次提交的同时编辑提交信息\</p><p><code>--no-edit</code>   参数 不编辑新增提交的注释信息</p><p><code>-n</code>参数是<code>--no-commit</code>的简写形式  不进行提交 仅仅把改变放入暂存区,通过手动提交完成回滚操作</p></blockquote></li><li><p><code>revert</code>指令也有多种写法，下面介绍主要的几种。</p><blockquote><p><code>git revert commit_id</code>    通过<code>commit_id</code>精准地选择想要重做的提交。</p><p>重做非最新一次提交，会发生冲突。</p></blockquote><blockquote><p><code>git revert HEAD</code>   … 和 reset 语法相同</p></blockquote></li><li><p>撤销<code>revert</code>操作  , 再次通过<code>revert</code>操作取消上一次的<code>revert</code>操作, 即所谓”负负得正”）</p></li></ul><ul><li><p><code>git checkout</code>  </p><blockquote><p><code>git checkout commit_id</code>    使用<code>checkout</code>可以进行版本回退</p><p>通过checkout 回退 使组成的<code>commit</code>对象链条处于游离状态；</p><ul><li>通过<code>checkout</code>进行版本回退会造成游离的提交对象链，需要额外创建一个分支进行保存</li><li>因此，使用<code>checkout</code>进行版本回退的思路为，先切换到想要回退的提交版本，再删除进行版本回退的分支<code>dev</code>。最后，创建一个新的<code>dev</code>分支指向游离的提交对象链，完成分支<code>dev</code>的版本回退，简称”偷天换日”；</li></ul></blockquote></li></ul><ul><li><p>由于<code>checkout</code>会造成游离的提交对象链，所以，一般不使用<code>checkout</code>而是使用<code>reset</code>和<code>revert</code>进行版本回退</p></li><li><blockquote><p>在个人开发上，建议使用<code>reset</code>；但是在团队开发中建议使用<code>revert</code>，特别是公共的分支（比如<code>master</code>)，这样能够完整保留提交历史，方便回溯。</p></blockquote></li></ul><ul><li><p><code>git stash</code>的作用</p></li><li><blockquote><p>对没有提交到版本库的，位于工作区或暂存区中游离的修改进行保存，在需要时可进行恢复        这些游离的修改在切换分支时都将会丢弃</p></blockquote></li><li><p>位于工作区和暂存区中的修改都会被<code>checkout</code>操作覆盖  </p></li><li><blockquote><p>这种情况在日常开发中很常见，当在<code>develop</code>分支上开发新功能的时候，<code>master</code>分支出现紧急情况需要切换回去进行修复。但是，当前分支的新功能还没开发完全，贸然切换分支，原来开发的内容就会因被覆盖而丢失，怎么办呢？</p><p>使用git stash 暂存修改</p></blockquote></li><li><p>可见<code>git stash</code>可以将当前分支上，位于在工作区或暂存区中的修改，在未提交的情况下进行了保存；并且将分支回退到修改前的状态</p><blockquote><p>在切换回该分支时, 需要从stash区域中恢复保存的修改</p></blockquote><blockquote><p><code>git stash save &#39;注释&#39;</code>   保存修改时给与注释</p><p><code>git stash list</code>   查看保存的修改</p></blockquote></li><li><p>主要有三种方法恢复 stash存储的修改</p><blockquote><p><code>git stash pop</code>   恢复最新的修改 把修改从stash中删除</p><p><code>git stash apply</code>    恢复但不删除<code>stash</code>中存储的最新修改；</p><blockquote><p>使用该指令时发生了合并冲突。这是因为，<code>stash</code>中保存的每一次修改代表的都是一个版本。</p></blockquote><p><code>git stash apply stash@&#123;n&#125; </code>   ，作用为从<code>stash</code>中恢复特定的修改，并且不删除<code>stash</code>中的该修改。</p></blockquote></li></ul><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><ul><li><p><code>git config--</code>   三个作用域: system global local  优先级一次递增</p><blockquote><p>system: 一台计算机（操作系统）上的所有用户</p><p>global : 计算机中的某用户创建的所有项目</p><p>local : 某一特定的版本库</p></blockquote></li><li><p>通过**<code>git config --list</code>：**可以批量查看配置信息(所有的配置信息 包括local global配置)</p><blockquote><p>通过 <code>cat  .git/config</code> 查看Local配置   <code>cat ~/.gitconfig </code>查看全局配置</p></blockquote></li><li><p><code>git config --作用域  --unset &lt;参数名&gt;</code>    删除配置 </p><blockquote><p>可以用来修改用户名..  </p></blockquote></li><li><p><code>.gitignore</code> 文件中配置不被git追踪的文件</p><blockquote><p>注意在<code>.gitignore</code>文件中<strong>一行写一个</strong>文件名；<code>.gitignore</code>文件也支持<strong>正则表达式</strong></p></blockquote></li><li><p>如果某些文件已经被纳入了版本管理中，那么修改<code>.gitignore</code>是无效的,仍然会发生追踪</p><blockquote><p>清除<code>git</code>本地缓存，将文件转变为<code>untrack</code>状态，然后再提交:</p><p>git rm -r –cached .</p></blockquote></li></ul><h3 id="Git-协作流程和Git-pull-常见问题"><a href="#Git-协作流程和Git-pull-常见问题" class="headerlink" title="Git 协作流程和Git pull 常见问题"></a>Git 协作流程和Git pull 常见问题</h3><ul><li><p><code>Gitflow</code> 基于git分支的开发模型</p><blockquote><p>一般有<code>develop</code>分支   <code>test</code>分支  <code>master</code>分支   <code>bugfix(hotfix)</code>分支</p></blockquote></li><li><p><code>SVN</code>方式（典型模型）</p><blockquote><p>多个用户对同一个仓库进行推送,主要原因在于每个用户都需要 pull之后再次push,</p></blockquote></li><li><p>git pull 冲突问题</p></li><li><p><code>git pull</code>同源合并冲突</p><blockquote><p>所谓同源，指的是本地仓库与远程仓库中的分支从根提交节点开始，有共同的提交历史</p></blockquote></li><li><h4 id="git-pull不同源合并冲突"><a href="#git-pull不同源合并冲突" class="headerlink" title="git pull不同源合并冲突"></a><code>git pull</code>不同源合并冲突</h4><blockquote><p>所谓不同源，指的是两个仓库中的分支，根提交节点不同，</p></blockquote></li></ul><h3 id="Git-refspec"><a href="#Git-refspec" class="headerlink" title="Git refspec"></a>Git refspec</h3><ul><li><p>本地仓库与远程仓库的分支映射关系：<code>git refspec</code>, 没有映射的情况下,无法进行git push</p><blockquote><p>通过<code>git branch -vv</code>查看本地与远程分支的关联情况</p></blockquote></li><li><p><code>git</code>中其实有三种分支：本地分支、本地远程分支、远程分支</p><blockquote><p>本地远程分支是远程分支的一个镜像，并且在本地仓库与远程仓库之间起到一个桥梁的作用, 当本地仓库中的每一个分支都有与之关联的远程分支之后，本地仓库都会创建对应的<strong>本地远程分支</strong></p><p>比如本地远程分支<code>origin/develop</code>就对应着远程分支<code>develop</code>。</p></blockquote></li><li><p>本地远程分支是为了追踪远程分支而存在的，只有在执行<code>pull</code>或<code>push</code>操作时它的指向才会更新。</p></li><li><p><strong>设置同名远程分支:</strong></p><blockquote><p><code>upstream branch</code>表示上游分支，即远程仓库的分支</p></blockquote></li><li><p>建立本地与远程分支追踪关系的。类型一</p><blockquote><p>方法一: <code>git push --set-upstream origin &lt;branch&gt; </code>  : 在远程仓库创键一个与本地分支develop<strong>关联</strong>的同名分支，并将本地分支develop的文件推送到该远程分支上。</p><p>方法二 :  <code>git push -u origin &lt;branch&gt;</code>  :为本地仓库创建对应的远程分支</p><p>使用上述方法，只需设置一次，之后就可以使用简写形式<code>git push</code>进行推送</p><p>方法三: <code>git push origin HEAD</code>  / <code>git push origin &lt;branch&gt;</code>设置对应的远程分支, 因为没有跟踪分支信息, 所以之后无法直接使用git push</p></blockquote><blockquote><p><strong>设置不同名远程分支:</strong></p><p> <code>git push --set-upstream origin &lt;branch1&gt;:&lt;branch2&gt;</code>   其他方法也可以使用类似完整的命令</p><p>注意: 不同名的远程分支进行推送都不可以使用 git push, 因为名字不一样, 必须使用完整的命令的进行推送</p></blockquote></li></ul><ul><li><p>不建立本地与远程分支追踪关系的。类型二</p><blockquote><p><code>git push origin HEAD</code></p><p><code> git push origin &lt;branch_name&gt;</code>  </p><p>使用该方法,每次都需要使用完整写法</p></blockquote></li></ul><ul><li><p><code>git push origin master</code>与<code>git push -u origin master</code>的区别</p><blockquote><p>第一次将本地仓库的<code>master</code>分支推送到远程仓库的<code>master</code>分支上时，使用前者和后者都可以顺利推送</p><p>推荐使用 -u 参数,因为之后可以直接进行 git push推送</p></blockquote></li><li><p><code>git push -f origin master</code>  : <strong>强制推送</strong>,直接跳过与远程仓库的<code>master</code>分支合并的环节,即以本地的<code>master</code>分支内容为准。 慎用该命令, </p><blockquote><p>如果设置了分支追踪关系, 使用 <code>git push -f</code></p></blockquote></li></ul><ul><li><p><strong>设置远程分支对应的本地分支</strong> </p><blockquote><p><code>git checkout -b &lt;branch&gt; origin/&lt;branch&gt;</code>    </p><p><code>git checkout --track origin/&lt;branch&gt;</code>  </p></blockquote></li></ul><ul><li><p><strong>删除远程分支</strong></p><blockquote><p><code>git push origin :destBranch</code>    将空的分支推送到远程分支，这样就能将该远程分支删除</p><p><code>git push origin --delete destBranch</code></p></blockquote></li><li><p><code>git remote prune origin</code>   删除无效的远程分支对应的本地远程分支</p><blockquote><p>当远程分支被删除时, 那么对应的本地远程分支就是无效的</p></blockquote></li></ul><ul><li><p><strong>重命名分支</strong></p><blockquote><p>本地分支:</p><p><code>git branch -m dev develop</code>     将本地分支<code>dev</code>重命名为<code>develop</code></p><p>远程分支: </p><p>无法直接重命名远程分支，只能通过先删除原来的远程分支，再创建一个新名称的分支</p></blockquote></li></ul><h3 id="git-标签"><a href="#git-标签" class="headerlink" title="git 标签"></a>git 标签</h3><ul><li><p><code>Git</code>标签有两种：<code>轻量级标签</code>  <code>带有附注的标签</code>  , 标签标识的是某一次提交，这次提交可以是任何分支上的任何一次提交。</p></li><li><p>什么时候打标签?  版本发布时,会打上类似v1.0 的标签</p></li><li><p><strong>创建标签:</strong></p><blockquote><p><code>git tag &lt;tag_name&gt;</code>   </p><p> <code>git tag -a &lt;tag_name&gt; -m &#39;注释&#39;</code></p></blockquote></li><li><p>查看标签</p><blockquote><p><code>git tag</code>   </p><p><code>git show &lt;tag_name&gt;</code>   </p></blockquote></li><li><p>查找标签</p><blockquote><p><code>git tag -l &lt;tag_name&gt;</code>    该方式支持正则表达式查找；</p></blockquote></li><li><p>标签推送到远程</p><blockquote><p><code>git push origin &lt;tag_name&gt;</code>  将本地分支上的标签推送到远程仓库</p><p>也可以利用此推送多个本地标签</p><p><code>git push origin --tag</code>   推送本地所有的标签到远程仓库</p></blockquote></li><li><p>删除标签</p><blockquote><p>远程:</p><p><code>git push origin :&lt;tag_name&gt;</code>    </p><p><code>git push origin --delete &lt;tag_name&gt;</code></p><p>本地:</p><p><code>git tag -d &lt;tag_name&gt;</code>   </p></blockquote></li><li><p>切换标签</p><blockquote><p><code>git checkout &lt;tag_name&gt;</code>   切换标签与使用<code>reset</code>进行版本回退十分相似。只不过切换标签只改变了<code>HEAD</code>指针的指向，会造成游离的提交。若有需要可以创建一个新分支进行保存。</p></blockquote></li><li><p>Git别名</p><blockquote><p><code>git config &lt;作用域&gt; alias.&lt;别名&gt; &#39;&lt;命令&gt;&#39;</code>   设置<code>git</code>命令别名</p><p>设置完成后，该配置会被写入系统用户的配置文件<code>gitconfig</code>中</p></blockquote></li><li><p>垃圾回收 : git gc </p></li></ul><h3 id="Git-cherry-pick-rebase"><a href="#Git-cherry-pick-rebase" class="headerlink" title="Git cherry-pick rebase"></a>Git cherry-pick rebase</h3><ul><li><p><code>Git cherry-pick</code>的作用为移植提交。采用先删除再添加的方法将会很繁琐，而使用<code>cherry-pick</code>就能轻松实现这一需求。</p><blockquote><p>将多余的提交通过 cherry-pick 移植提交, 然后删除该分支上多余的提交</p></blockquote></li><li><p><code>rebase</code>有两个意思：<strong>变基</strong>、<strong>衍合</strong>，即变换分支的参考基点</p></li></ul><h3 id="git子库"><a href="#git子库" class="headerlink" title="git子库"></a>git子库</h3><ul><li><code>git</code>提供了子库的概念。可以将这些子模块存放在不同的仓库中，通过<code>submodule</code>或<code>subtree</code>实现仓库的嵌套。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World lalla</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="edit-github-from"><a href="#edit-github-from" class="headerlink" title="edit github from"></a>edit github from</h3><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h4 id="Github-action"><a href="#Github-action" class="headerlink" title="Github action"></a>Github action</h4><ul><li>加上 github action 就完成了自动打包 部署  不再使用hexo generate deploy, 直接提交代码就可以了</li></ul><h4 id="改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键"><a href="#改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键" class="headerlink" title="改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键"></a>改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键</h4>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
