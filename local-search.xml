<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JqueryApi 进阶</title>
    <link href="/2020/12/14/jquery%20%E6%8B%BE%E5%BF%86/"/>
    <url>/2020/12/14/jquery%20%E6%8B%BE%E5%BF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="Ajax-等待-高级ajax操作-高级DOM操作-对服务器传来的数排序"><a href="#Ajax-等待-高级ajax操作-高级DOM操作-对服务器传来的数排序" class="headerlink" title="Ajax (等待)  高级ajax操作  高级DOM操作(对服务器传来的数排序)"></a>Ajax (等待)  高级ajax操作  高级DOM操作(对服务器传来的数排序)</h4><ul><li>理解扩展事件 : 相当于给jquery新建事件,封装起来复用<h4 id="延迟对象-不理解"><a href="#延迟对象-不理解" class="headerlink" title="延迟对象(不理解)"></a>延迟对象(不理解)</h4><ul><li> promise  都用于ajax 这中耗时操作中, 延迟对象一般不需要手动建立,一般建立好的知道使用方法即可</li><li> 回调对象</li><li><blockquote><p>$.Callbacks()模块开发目的是：给内部$.ajax()和$.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能</p></blockquote></li></ul></li><li>涉及到jquery的原理层面<h5 id="自定义遍历符-开发插件的一部分-参考高级遍历"><a href="#自定义遍历符-开发插件的一部分-参考高级遍历" class="headerlink" title="自定义遍历符(开发插件的一部分) 参考高级遍历"></a>自定义遍历符(开发插件的一部分) 参考高级遍历</h5></li><li>选择符选择优化问题(原理)</li><li> 利用 $.expr[‘:’]  开发自定义选择器<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4></li></ul><hr><h3 id="根据API进行分类"><a href="#根据API进行分类" class="headerlink" title="根据API进行分类"></a>根据API进行分类</h3><h4 id="选择器过滤"><a href="#选择器过滤" class="headerlink" title="选择器过滤"></a>选择器过滤</h4><ul><li><p>.last()  获取匹配元素集合中最后一个元素 和:last 相同。  :last-child  判断匹配到的元素是否是其父元素的最后一个子元素  </p></li><li><p>:selected 选取select 中被选取的元素</p></li><li><p>:even 从0开始算</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4></li><li><p>add() 添加元素到匹配的元素集合。  addback([ selector]) 添加<strong>当前堆栈中</strong>元素<strong>集合</strong>到当前集合 ,(选择器可以筛选出之前堆栈内容 之后添加到当前集合)</p></li><li><blockquote><p>在end addback中的堆栈操作解释 : 每次遍历方法都会找到新的元素,这些新的元素构成一个jq对象压入堆栈</p></blockquote></li><li><p>end() addback()都是通过堆栈来实现的,end终止在当前链的过滤操作,返回匹配的元素的以前状态,本质使用了出栈操作,返回原来的一个状态</p></li><li><p>closest() 从元素本身开始，逐级向上找到符合条件的第一个元素，该元素可能是当前元素自身，也可能是最靠近当前元素的一个祖先元素。</p></li></ul><ul><li><p>.children()  获得元素的子元素(可以进行选择筛选)   .contents()获得元素的子元素包括文字注释节点</p></li><li><p>nextAll() prevAll() 返回的结果都不包括自身</p></li><li><p>next([selector ] )   返回元素紧邻的后面的同辈元素,如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。</p></li><li><p>has() 筛选相匹配的元素,如果符合条件就留下来,最后返回一个集合    not() 通过条件筛选,符合条件的去除 和has 相反</p></li><li><p> is()判断当前元素,返回布尔值</p></li><li><p>map(callback)  用于处理当前jQuery对象匹配的所有元素，并将处理结果封装为新的jq数组 </p></li><li><blockquote><p>特别适用于获取或设置元素集合中的值</p></blockquote></li><li><p>.slice(start [, end )  根据指定的下标范围，过滤匹配的元素集合 (从零开始计数,所以范围是到end-1) </p></li></ul><p>-find() 是往匹配元素的后代元素里寻找符合条件的</p><h4 id="偏移-尺寸"><a href="#偏移-尺寸" class="headerlink" title="偏移 尺寸"></a>偏移 尺寸</h4><ul><li><p>offsetparent() 获得被定位后的祖先元素的top left值,没有就返回undefined</p></li><li><p>position()  获得当前元素针对被定位祖先元素的偏移量 没有就返回针对document的偏移量</p></li><li><blockquote><p>被定位 指的是 position不为static的元素</p></blockquote></li><li><p>指的注意的是 偏移的top left值的计算是不包括margin值,到maigrin的边界的值才是偏移量</p></li><li><p>height() 获取高度值(只包括内容)  innerheight() 获取高度值(包含padding不包含border) outerheight(包括 padding border 参数为true 则包含margin)</p></li></ul><h4 id="DOM操作-css属性-html属性-DOM增删改查"><a href="#DOM操作-css属性-html属性-DOM增删改查" class="headerlink" title="DOM操作 (css属性 html属性 DOM增删改查)"></a>DOM操作 (css属性 html属性 DOM增删改查)</h4><ul><li><p>删除操作</p></li><li><p>empty() 这个方法不仅移除子元素（和其他后代元素),同样移除元素里的文本</p></li><li><p>remove() 和.empty()相似 , 当我们想将元素自身移除时我们用 .remove()</p></li><li><p>detach() 要删除的元素不删除数据和事件的情况下，使用.detach()来代替。 当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。</p></li><li><p>prop()  val() 对表单进行操作 </p></li><li><p>val() 主要用于获取表单元素的值, val()获得value属性内容,对于多选下拉列表则返回一个数组包含每个选择项     通过.val([ “表单value值”])可以设置被选中的状态 (对于select 没有value值的直接写选项中的值也可以被选中)</p></li><li><p>.prop( propertyName, value ) 获取/设置元素的property值(一般我们用在表单属性上,具体参考API)</p></li></ul><ul><li> html() 获取设置匹配元素内部的html内容(设置时会把之前的内容替换掉) </li><li> text() 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代.     可以用来给指定元素设置文本内容(文本内容会替换指定元素里的所有内容)</li></ul><ul><li><p>DOM 操作分为几类 : 内部/外部添加到前面/后面   调用顺序不同</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4></li><li><p>.triggerHandler()   .triggerHandler() 方法的行为与 .trigger() 相似,不会触发默认行为 事件冒泡, 只会对匹配到的第一个元素生效   trigger()与之相反</p></li><li><p>trigger() 除了一次模拟事件还可以给事件提供额外参数: .trigger( eventType [,extraParameters ])  额外参数是数组类型</p></li><li><blockquote><p>$(“p”).click( function (event, a, b) {}).triggr(“click”, [“foo”, “bar”]);</p></blockquote></li><li><p>.one() 要绑定一个事件，并且只运行一次，然后删除自己</p></li><li><p>on()函数  .on( events [, selector ] [, data ], handler(eventObject) ) </p></li><li><blockquote><p>.on( events [, selector ] [, data ] ) 这里的events是一个对象键值是事件名 值是处理函数,可以利用此一次处理多个事件</p></blockquote></li><li><p>keydown  keypress 事件区别 : keypress表示被输入哪个字符(字符代码) ,若想捕获敲击了哪个特殊键的话，例如，方向键(keycode)，  使用 .keydown()或.keyup() 更好。想要得到输入的文本内容只能是keyup,其他的只能获取输入前的文本</p></li></ul><ul><li>change 事件被&lt; input&gt;, &lt; select&gt;, 和&lt; textarea&gt; 触发,对元素值<strong>更改后</strong>触</li></ul><h4 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h4><ul><li><p>.animate() 所有用于动画的属性(设置变化的键值对)必须是数字的，除非另有说明,不要使用css简写属性<br>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。动画属性可以使用 +=</p></li><li><p>精细控制动画  animate 函数 step progress函数使用  : step函数被每个动画元素的每个动画属性调用 ,它接受两个参数（now 和 fx） this是当前正在执行动画的DOM元素集合</p></li><li><blockquote><p>now: 每一步动画属性的数字值 fx: jQuery.fx 原型对象的一个引用 </p></blockquote></li><li><blockquote><p>比如elem 表示前正在执行动画的元素，start和end分别为动画属性的第一个和最后一个的值，prop为进行中的动画属性。</p></blockquote></li><li><p>queue 属性,决定要不要进队列中一个动画接下一个,flase 则是会和下一个动画方法同时发生(前提 : 这些都是连缀书写动画方法)</p></li><li><p>progress函数 每一步动画(step大约13毫秒调用一次,progress相似的方式)完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数</p></li></ul><ul><li><p>.delay()  设置一个延时来推迟执行队列中后续的项  它无法取消延时,不是JavaScript的原生 setTimeout函数的替代品</p></li><li><p>.queue( [queueName ] 默认为fx),显示在匹配元素上已经执行的函数队列 (这里的执行不一定是已经完成了,有时动画可能在队列中排队,完成函数调用就算是执行) ,</p></li><li><p>.queue( [queueName ], newQueue ) newQueue是array类型代表函数数组,用来替换当前队列中的内容,newQueue可以是空的数组 [],可以用来取消队列中不想进行的函数操作  类似 clearQueue()操作</p></li><li><p>.queue( [queueName ], callback( next ) ) 它让我们把新函数置入到队列的末端。为jQuery集合中的每个元素执行一次回调函数。类似在动画方法提供回调函数</p><blockquote><p>当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。 从jQuery 1.4开始，向队列中追加函数时，可以向该函数中传入另一个函数next()</p></blockquote></li></ul><blockquote><p>队列允许一个元素来异步的访问一连串的动作，而不终止程序执行,在执行上一个同时还能继续下个操作,队列存储信息  :$(‘#foo’).slideUp().fadeIn(); ,这个元素开始立即做滑动动画，但渐入动画放置在 fx列队,  所以jq可以执行完slideup还能继续执行渐变, </p></blockquote><ul><li><p>.dequeue()  移除队列中的首个函数, 然后执行这个函数, 这个执行的函数中也应当直接或间接的包含.dequeue()语句，这样才能继续执行队列中的其它函数</p></li><li><p>.clearQueue( [queueName ] )方法被访问的时候，所有在这个列队中未执行的函数将被移除 。当不使用参数的时候，.clearQueue()会从标准的动画队列fx中移除剩下的函数</p></li><li><blockquote><p>这个方法类似.stop(true)。然而.stop()方法只适用在动画中。.clearQueue()还可以用来移除用.queue()方法添加到普通jQuery列表的任何函数。 </p></blockquote></li></ul><ul><li><p>stop()  , 只会停止当前动画,对于队列中的其他动画可以选择停止,stop停止的动画函数,无法执行动画里的回调函数</p></li><li><p>.stop( [clearQueue ] [, jumpToEnd ] ) 默认都为false</p></li><li><p>.stop( [queue ] [, clearQueue ] [, jumpToEnd ] ),还可以选择队列名称</p></li><li><p>finish() 在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值 和.stop(true, true)很相似,但是stop只会把当前的动画跳转到目标值</p></li></ul><blockquote><p>关于动画队列,每个元素维护自己的一个动画队列,不会不同的动画元素放在一起</p></blockquote><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li><p>data() 在匹配元素上存储任意相关数据. .removeData()移除存储数据 通过data()函数存取的数据都是临时数据，一旦页面刷新，之前存放的数据都将不复存在</p></li><li><p>toArry() 返回包含jquery对象的DOM元素数组  get()返回一个对应的DOM元素</p></li></ul><h4 id="高级事件处理"><a href="#高级事件处理" class="headerlink" title="高级事件处理"></a>高级事件处理</h4><ul><li>理解早委托 : 把事件绑定到document,不必等到文档全部加载好才能够处理事件,当委托加载好就可以</li><li>理解自定义事件 -自定义事件参数 : 用on函数定义 自定义事件处理 trigger 进行调用</li><li><blockquote><p>.on(“myCustomEvent”, function(e, myName, myValue){}) 自定义事件 还可以可以给与参数,在trigger调用时添加参数即可</p></blockquote></li></ul><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><ul><li>使用插件原理是一样的,默认的只需要调用一个(插件自定义函数),如果想要自定义内容就要在函数中提供参数,来修改一些属性(这些属性只能通过插件API 文档获得)</li></ul><h4 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h4><ul><li>添加jquery对象的全局函数    $.func    $.extend({})  </li><li>扩展jquery 对象的方法    $.fn.func  $.fn.extend({})</li><li><blockquote><p>jQuery.fn对象是jQuery.prototype的别名</p></blockquote></li><li><blockquote><p>在任何插件方法内部，关键字this引用的都是当前的jQuery对象</p></blockquote></li></ul><ul><li>使用命名空间隔离函数 : 其他jQuery插件也可能定义相同的函数名。为了避免和自己定义插件的函数冲突，最好的办法是 把属于一个插件的全局函数都封装到一个对象中 (实际上创建一个对象,在对象里定义方法,这样就起到隔离的效果)</li><li><blockquote><p> $.mathUtils = { 函数 ) </p></blockquote><h5 id="开发插件注意的问题"><a href="#开发插件注意的问题" class="headerlink" title="开发插件注意的问题"></a>开发插件注意的问题</h5></li></ul><p>-考虑方法的隐式迭代问题 :  jQuery的选择符表达式可能会匹配零、一或多个元素, 调用.each()方法；这样就会执行隐式迭代 (在调用的.each()方法内部，this依次引用每个DOM元素)</p><ul><li><blockquote><p>this.each(function(){})  这里this代表一个有很多元素集合的 jquery对象</p></blockquote></li><li><p>考虑方法的连缀问题:  函数的返回值要是一个jquery 对象</p></li><li><p>参数默认值 默认参数的可修改 自定义参数 问题</p></li><li><p>提供自定义参数,做到和animate()方法一样,能够给与参数修改属性值的操作, 提供默认值,有时候不用给参数的属性值也可以调用 或者给一部分, </p></li><li><p>方法参数也可能不是一个简单的数字值，可能会更复杂。在各种jQuery API中经常可<br>以看到另一种参数类型，即回调函数</p></li><li><p>多次调用一个插件,给与同一个参数改变默认值,很麻烦,可以直接修改默认值,例如 jquery.fx.interval 可以直接修改默认的动画频率</p></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123; <br>  $.fn.shadow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>&#123; <br>    <span class="hljs-keyword">var</span> defaults = &#123; <br>      copies: <span class="hljs-number">5</span>, <br>      opacity: <span class="hljs-number">0.1</span> <br>      copyOffset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;    <span class="hljs-comment">//默认方法参数是一个函数</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>: index, <span class="hljs-attr">y</span>: index&#125;;<br>    &#125;; <br>    <span class="hljs-keyword">var</span> options = $.extend(defaults, opts); <br>    <span class="hljs-keyword">var</span> offset = options.copyOffset(i);   <span class="hljs-comment">//自定义参数 (函数形式)</span><br>    <span class="hljs-comment">// ...  自定义参数格式: options.参数名</span><br>  &#125;; <br>&#125;)(jQuery);<br></code></pre></td></tr></table></figure><ul><li>extend函数,会使opt对象对defaults 进行覆盖.</li><li>上式只能改变自定义参数, 但是不能直接改变默认值,想直接改变默认值,默认值参数对象必须放在函数代码外,能够被外部调用</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123; <br>  $.fn.shadow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>&#123;  <br>    <span class="hljs-keyword">var</span> options = $.extend(&#123;&#125;,$.fn.shadow.defaults, opts); <span class="hljs-comment">//只能修改空对象,如果修改defaults, 在自定义参数中就会更改了默认值.</span><br> <br>    <span class="hljs-comment">// ...  自定义参数值 :  options.参数名</span><br>  &#125;; <br>  <span class="hljs-keyword">var</span> $.fn.shadow.defaults = &#123;<br>       copies: <span class="hljs-number">5</span>, <br>       opacity: <span class="hljs-number">0.1</span>,<br>  &#125;;<br>&#125;)(jQuery);<br><br></code></pre></td></tr></table></figure><ul><li>修改默认值 :   $.shadow.defaults.参数名=…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jquery指导</title>
    <link href="/2020/12/14/JQuery%20%20%E6%8C%87%E5%AF%BC/"/>
    <url>/2020/12/14/JQuery%20%20%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="Jquery-实践"><a href="#Jquery-实践" class="headerlink" title="Jquery 实践"></a>Jquery 实践</h1><ul><li><p>抽象jquery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax </p></li><li><p> jquery 总是面向对象,对节点集合可能会进行隐式迭代操作</p></li><li><p>编写程序时要尊重渐进增强,和平稳退化</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><blockquote><p>jQuery完全继承了css选择器风格,下面的选择器用法也是css选择器的用法<br>使用jquery选择器就算获取不到元素也不会报错,传统dom在获取之前要加上if判断是否存在,需要注意<br>$()获取的永远是一个对象,就算不存在该元素,所以jquery通过对象的长度大小.length//转换为dom对象判断,来评判是否存在该元素</p></blockquote><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4></li><li><p>id 标签名 类名 层次选择器(+ ~ &gt; 后代…)</p></li><li><p>表单选择器  :表单标签名字</p><h4 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h4><pre><code>基本过滤选择器 :first 选取第一个元素（单个元素）,:last:not(selector) 去除所有与给定选择器匹配的元素,:even :odd 索引从零开始:eq（index） 选取索引等于index的元素,:gt(index)  大于index :lt(index)：小于:header：选取所有的标题元素:animated：选取当前正在执行动画的所有元素:focus：选取当前获得焦点的元素属性选择器: element[attr] 选中拥有attr属性的元素,可以多选属性 element[attr][attr0]可以利用正则表达式进行判断属性 a[href^=&quot;mailto:&quot;] 判断href属性开头含有mailto的元素内容过滤器  :contains(text) 选取(直接)含有text文本内容的元素,(子元素含有并不算):empty 选取内容为空的元素(没有元素节点 没有文本节点)  :has(selector) 选取**含有**指定选择器选定的元素的元素  :parent 选取有子元素的元素:visible  选取所有可见的元素:hidden 子元素过滤器  nth-child() 参数可以为数字 even/odd  表达式  索引从1开始first-child last-child only-child表单元素过滤器 :checked :selected :enabled :disabled</code></pre></li></ul><blockquote><p>性能提示   DOM对象和jquery对象的互换(在jquery对象中调用DOM) </p></blockquote><blockquote><p>jQuery提供了一个jQuery.noConflict()方法，把对$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,jQuery(document).ready(function($) {正常使用符号} ) </p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li><p>在事件处理中常用内容:</p><pre><code>  当触发任何事件处理程序时，关键字this引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象  toggleClass(&quot;类名&quot;)方法,(类名不加点)能够根据相应的类是否存在而添加或删除类  is() 判断是否为一个选择器 DOM元素...  例如:  .is(&#39;:hidden&#39;) 判断元素是否是可见的  .one()只生效操作一次,参数和on函数一样,相当于一次的on函数调用</code></pre><h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5></li><li><p>.on(“click”,fn)  fn可以是函数引用或者匿名函数</p></li><li><p> 除了on绑定,还可以用事件名函数绑定  例如.click() 键盘事件 .keypress()…</p><blockquote><p>on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jquery隐式迭代机制,jquery的行为队列机制,可以给一个元素绑定多个相同事件不会被覆盖<br>老版本会有bind()查看jquery api<br>.on(),中的函数参数,可以是函数引用,函数引用,必须省略函数名称后面的圆括号。圆括号会导致函数被调用，而非被引用。</p></blockquote></li></ul><h5 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h5><ul><li>调用.off(“事件名”)方法移除</li><li>对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.<blockquote><p>例如:  .on(‘click.collapse’,fn);  .off(‘click.collapse’); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的</p></blockquote></li><li>对.off()的调用更有针对性,还可以在调用on(“click”,fn引用)时,在fn中进行判断事件对象,这样可以不用命名空间, 注意一个问题,如果重复触发事件,就会重复调用这个函数,比如重复点击.</li><li>重新绑定事件,只需要再次调用on函数.</li></ul><h5 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h5><ul><li>$(document).ready()  简写-&gt; $(function(){});<blockquote><p>window.onload和ready()区别：$(document).ready()，会在DOM完全就绪并可以使用时调用，但是关联文件不一定下载完毕,还有ready()可以一直添加不会被覆盖.</p></blockquote></li></ul><h3 id="事件传播（旅程）"><a href="#事件传播（旅程）" class="headerlink" title="事件传播（旅程）"></a>事件传播（旅程）</h3><ul><li><p>DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,</p><blockquote><p>在js编程中默认在冒泡阶段进行处理事件,改变addEventListener(type,fn,false)中的false为true,则是在事件捕获时进行处理事件(从最外层处理一直到最内层)</p></blockquote></li><li><p>jquery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。</p></li><li><p>避免事件传播的事件处理</p><pre><code>  hover(fn,fn)函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播  而mouseenter和mouseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。</code></pre></li></ul><h5 id="事件冒泡-–事件捕获"><a href="#事件冒泡-–事件捕获" class="headerlink" title="事件冒泡 –事件捕获"></a>事件冒泡 –事件捕获</h5><ul><li><p>冒泡副作用:错误的元素响应mouseover或mouseout事件的情况下,例如外层div最内层a,当最内层a元素鼠标离开时会触发mouseout事件向外层冒泡</p></li><li><p>事件冒泡,从具体元素到一般元素的理解: 具体元素指的是响应事件最(准确具体)的元素,例如a元素嵌套一个i元素图标,那么当不点击图标时,最具体的元素是a而不是 i元素,当li嵌套一个a(块级)时,响应没有最准确的那么选最具体的a元素</p></li><li><p>事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡</p><blockquote><p>mouseover out事件,在鼠标从父元素移入子元素时会触发 父元素out事件,over事件总是从父级元素到自己元素</p></blockquote><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3></li><li><p>事件对象是一种DOM结构，它会在元素获得处理事件时,获取触发事件的元素.这个对象中包含着与事件有关的信息,也提供了可以用来影响事件在DOM中传递进程的一些方法 (jquery对对象属性进行封装,使其可以兼容,以下是jquery封装过得,可能和原生DOM不同)</p><pre><code>属性: .target 获取触发事件的DOM元素 .type 获取事件类型 .pageX.pageY 获取相对于页面x坐标y坐标 .which 获取鼠标的左中右键 获取键盘事件的按键  .mateKey获取ctrl键方法:  preventDefault() 阻止默认行为  stopPropagation()阻止事件冒泡</code></pre></li></ul><blockquote><p>通过事件对象解决事件冒泡问题</p></blockquote><ul><li>事件传播和默认操作是相互独立的两套机制，在二者任何一方发生时，都可以终止另一方。<blockquote><p>如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false，这是对在事件对象上同时调用.stopPropagation()和.preventDefault()的一种简写方式。</p></blockquote></li></ul><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><ul><li><p>只在DOM中的一个祖先元素上指定一个单击处理程序。由于事件会冒泡，未遭拦截的单击事件最终会到达这个祖先元素,而我们可以在此时再作出相应处理.</p></li><li><p>使用内置的事件委托, on函数接受相应参数,例如: .on(‘click’, ‘button’, function(){}) :事件处理绑定到父元素上，同时比较event.target和选择符表达式（这里的’button’）。如果匹配执行事件处理.</p></li><li><p>某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素</p></li></ul><h5 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h5><ul><li>例如用户进入页面时,就触发点击事件,不要去点击它,这时需要模拟事件: trigger(“click”),也可以直接使用简化模式,调用.click();</li><li>tigger还可以触发自定义事件<blockquote><p>trigger()方法不仅会触发事件,还会触发默认行为 trigger(“focus”),这样除了触发事件,还会是该元素获得focus,单纯的触发事件使用triggerHandler()</p></blockquote></li></ul><h2 id="样式与动画"><a href="#样式与动画" class="headerlink" title="样式与动画"></a>样式与动画</h2><h3 id="css属性操作"><a href="#css属性操作" class="headerlink" title="css属性操作"></a>css属性操作</h3><ul><li><p>.css()方法,用来获取计算后的样式,设置内联样式.</p><pre><code> 获取使用: 单个样式属性   传递一个字符串形式的属性名，获取字符串形式的属性值, 多个样式属性   可以传入属性名的数组，得到的则是属性和值构成的对象, 对于属性名的格式,可以解释驼峰命名,也可以解释连字符的命名   设置使用: css()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值，另一种是为它传递一个由属性—值对构成的对象 例如:  1. $speech.css(&#39;fontSize&#39;, num + &#39;px&#39;);      2. var Obj =&#123;&#39;background-color&#39; : &#39;#ddd&#39;,&#39;color&#39; : &#39;rgb(0,40,244)&#39;&#125;;     $(this).css(Obj);</code></pre></li></ul><blockquote><p>浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在,。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性</p></blockquote><h3 id="样式变化"><a href="#样式变化" class="headerlink" title="样式变化"></a>样式变化</h3><ul><li><p>隐藏/显示元素:  .hide() .show()  -&gt;相当于设置display的值   默认是不带动画效果的.</p><blockquote><p>.hide()方法会将匹配的元素集合的内联style属性设置为display:none。但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局</p></blockquote></li><li><p>带动画效果: .hide(‘duration’)   duration:毫秒级   动画效果-&gt;会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,</p><blockquote><p>动画效果有两种预设的速度参数：’slow’和’fast’。也可以自定义指定显示速度. 以下动画效果都可以适用</p></blockquote></li><li><p>淡入和淡出, fadeIn(),fadeOut()  : 改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。</p></li><li><p>滑入和滑下, slideDown()和.slideUp() : 改变高度和display的值   元素本来就处在文档流中,适合使用滑入滑出</p></li><li><p>复合效果方法,  slideToggle() ,动画和slideDown(),slideUp()一样    toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3></li><li><p>.animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式</p><pre><code>第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:.animate(&#123;property1: &#39;value1&#39;, property2: &#39;value2&#39;&#125;, duration, easing, function() &#123;&#125;)第二种形式接受两个参数，一个属性对象和一个选项对象.animate(&#123; property1: &#39;value1&#39;, property2: &#39;value2&#39; &#125;, &#123; duration: &#39;value&#39;, easing: &#39;value&#39;,specialEasing: &#123; property1: &#39;easing1&#39;, property2: &#39;easing2&#39; &#125;, complete: function() &#123;&#125;, queue: true, step: callback &#125;);</code></pre></li><li><p>animate()方法最少要有两个参数,属性对象和duration</p><blockquote><p>.animate()方法针对CSS属性提供了方便简写值：’show’、’hide’和’toggle’,例如 : .animate({height: ‘toggle’}, ‘slow’);</p></blockquote></li><li><p>animate()方法中,属性对象中的值如果是 {“height” :”+=value” }表示在原来的基础上再加上value,而不是变化到value</p><h4 id="并发-同时发生-排队效果-一个接一个发生"><a href="#并发-同时发生-排队效果-一个接一个发生" class="headerlink" title="并发(同时发生)   排队效果(一个接一个发生)"></a>并发(同时发生)   排队效果(一个接一个发生)</h4></li><li><p> 同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.</p><blockquote><p>需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式</p></blockquote></li><li><p> 想要同时触发效果,要在一个方法内写多个属性</p></li><li><p> 多个元素,应用效果时,这些效果会同时发生,</p></li><li><p> 为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数,在效果方法中,它们是方法的最后一个参数。</p><blockquote><p>$clickedItem.next().slideDown(‘slow’, function() { $clickedItem.slideUp(‘slow’); }); 顺序为外层先执行,内层的回调函数在执行</p></blockquote><h5 id="越过队列-调整排队效果"><a href="#越过队列-调整排队效果" class="headerlink" title="越过队列(调整排队效果)"></a>越过队列(调整排队效果)</h5></li><li><p>第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始</p></li><li><p>对于非效果方法,如.css()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序</p><blockquote><p>解决方法1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({backgroundColor:’#f00’});next();}) ,传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码</p></blockquote></li></ul><blockquote><p>解决方法2:利用效果方法中的回调函数,在回调函数中书写.css(), 在外层函数完成时执行css,不需要调用next()</p></blockquote><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><h5 id="HTML-属性操作"><a href="#HTML-属性操作" class="headerlink" title="HTML 属性操作"></a>HTML 属性操作</h5><ul><li><p>.attr() 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值</p><blockquote><p>可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:</p></blockquote></li><li><p>$(‘div.chapter a’).attr({  title: ‘Learn more at Wikipedia’, id: function(index, oldValue) { return ‘wikilink-‘ + index; }</p><blockquote><p>这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用</p></blockquote></li><li><p>.removeAttr()方法 删除<em>一个</em>属性</p></li><li><p>类属性常用函数: .addClass()和.removeClass()   .toggleClass()方法交替添加删除类名</p><h5 id="DOM-属性"><a href="#DOM-属性" class="headerlink" title="DOM 属性"></a>DOM 属性</h5></li><li><p>在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同</p></li><li><blockquote><p>从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。</p></blockquote></li><li><p>DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性 例如:</p></li><li><blockquote><p>var id = div1.getAttribute(“id”)    var id = div1.id;</p></blockquote></li><li><p>HTML属性与DOM属性有一点区别。HTML属性是指页面标记中放在引号中的值，而DOM属性则是指通过JavaScript能够存取的值,HTML属性与DOM属性差别最大的地方是表单控件的属性,不要使用attr(),要使用val()获取/设置属性  或者是prop操作DOM属性(这个是要分情况的)</p><blockquote><p>.val()方法也可以接受一个函数作为其setter参数,与.attr()和.prop()一样 表单中最好都使用本函数</p></blockquote></li></ul><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul><li><p>创建节点 :  使用$(“”)函数创建节点</p></li><li><p>插入(添加).移动节点: </p><pre><code>内容.insertBefore(&quot;目标&quot;)在现有元素外部、之前添加内容；.prependTo()在现有元素内部、之前添加内容；.appendTo()在现有元素内部、之后添加内容；.insertAfter()在现有元素外部、之后添加内容。</code></pre></li></ul><blockquote><p>使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了<br>在隐式迭代添加多个节点时,插入顺序预定义的,不管是after before,从上到下顺序都是迭代顺序</p></blockquote><ul><li><p>反向插入方法 :内容目标的位置颠倒,名字更换了一下</p><pre><code> append() prepend() before() after()</code></pre><blockquote><p>反向插入方法,可以接受一个函数作为参数,这个函数会针对每个目标元素调用</p></blockquote></li><li><p>包裹节点</p><pre><code>被包裹的节点.wrap(&quot;节点&quot;)  .wrapAll(&quot;节点&quot;) 区别:后者在多个节点时,只包裹一次(最外面的节点),wrap每个节点都会包装,wrapInner()包裹匹配元素的子元素</code></pre></li><li><p>复制节点</p><pre><code>.clone()方法,默认不复制事件,如果想要复制.clone(true);  </code></pre></li><li><p>删除节点 </p><blockquote><p>从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件</p></blockquote><pre><code>remove(),detach()两者区别: 在于使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除,两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null empty()清空节点里的内容(文本 元素节点),*注意是节点里的,不是节点本身* 返回一个已经清空的元素</code></pre></li><li><p>替换节点(文本/元素)</p></li></ul><pre><code> .html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容 .text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本 .replaceAll(&quot;目标&quot;) 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动 .replaceWith(&quot;内容&quot;)   替换集合中所有匹配的元素,返回被删除元素的集合</code></pre><h4 id="DOM遍历"><a href="#DOM遍历" class="headerlink" title="DOM遍历"></a>DOM遍历</h4><ul><li>find(“选择器”)  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。</li><li>end() 终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.</li><li>each()方法就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次</li><li>.filter() 它可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中</li><li> next()方法 .nextAll() 获得后面所有的元素    对应方法: .prev()和.prevAll() </li><li>.siblings() 获取兄弟元素，无论这些元素处于当前元素之前还是之后.</li><li>  parent()     , children() :只考虑子元素,不考虑后代元素</li><li> jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]</li></ul><h3 id="jquery中的AJAX技术"><a href="#jquery中的AJAX技术" class="headerlink" title="jquery中的AJAX技术"></a>jquery中的AJAX技术</h3><blockquote><p>原生js的ajax并没有涉及,可以查阅资料了解</p></blockquote><ul><li>Ajax只不过是一种无需刷新页面即可从服务器（或客户端）上加载数据的手段。这些数据的格式可以是很多种,例如:HTML JSON XML js       </li><li>所有Ajax请求在默认情况下都是异步的<h5 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h5></li><li>HTML文件:  .load()方法,加载远程HTML代码插入DOM中,格式:load(URL,data,callback)</li><li>JSON文件:  $.getJson()方法用于加载json ,这是个全局函数, 可以接受第2个参数，这个参数是当加载完成时调用的函数(用来处理加载过来的数据)<blockquote><p>尽管JSON格式很简洁，但它却不容许任何错误，否则文件不会加载。而且在多数浏览器中当文件加载失败时我们看不到任何错误信息,脚本只是静默地彻底终止运转。</p></blockquote></li><li>js文件(可当做脚本文件): $.getScript()   (脚本文件基本有服务器端写,前端负责取数据直接调用)<blockquote><p>以这种方式取得的脚本会在当前页面的全局环境下执行。这意味着脚本有权访问在全局环境中定义的函数和变量，当然也包括jQuery自身。常见脚本php node.js… 一般纯j不用作脚本</p></blockquote></li><li>XML文件: $.get() <blockquote><p>通常，这个函数只是取得由URL指定的文件，然后将纯文本格式的数据提供给回调函数。但是,在根据服务器提供的MIME类型知道响应的是XML的情况下，提供给回调函数的将是XML DOM树。这样可以向操作html一样操作xML文件中数据</p></blockquote><h5 id="向服务器传递数据"><a href="#向服务器传递数据" class="headerlink" title="向服务器传递数据"></a>向服务器传递数据</h5></li><li>Ajax的价值只有当服务器能够基于浏览器的输入动态形成数据时才能得到充分体现</li><li>执行GET请求 根据 $.get函数,向服务器传递参数(要查询的数据),得到服务器返回的数据.<blockquote><p>load函数也可以,URL后面添加查询字符串,load()方法在接收到包含数据的对象参数时，会默认使用POST方法<br>发送请求</p></blockquote></li><li>执行POST请求  $.post()</li><li>表单提交——序列化表单</li></ul><h5 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h5><ul><li><p>jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。</p><pre><code>      .ajaxStart()和.ajaxStop()方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个      当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数       当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.      如.ajaxError()，会向它们的回调函数发送一个对XMLHttpRequest对象的      引用。这样就可以做到区别不同的请求来提供不同的行为      其他更具体的处理可以通过使用低级的$.ajax()函数来完成。</code></pre></li><li><p>错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 </p><h5 id="ajax中的常见问题"><a href="#ajax中的常见问题" class="headerlink" title="ajax中的常见问题"></a>ajax中的常见问题</h5></li><li><p>通过Ajax生成页面内容时的一个常见问题:事件绑定丢失</p><blockquote><p>事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。<br>解决方法: 每次页面内容更新重新绑定事件      使用事件委托</p></blockquote></li><li><p>安全限制 : 为了防止各种跨站点脚本攻击，一般情况下从提供原始页面的服务器之外的站点请求文档是不可能的。但是，从第三方来源中加载数据往往是很有必要的</p><blockquote><p>方法: 是通过服务器加载远程数据，然后在客户请求时提供给浏览器.    根据请求注入&lt; script&gt;标签或者$.getScript() 使用&lt; iframe&gt;这个HTML标签来加载远程数据。    从其他服务器取得JSONP文件.</p></blockquote></li><li><p>使用$.ajaxSetup()函数可以修改调用Ajax方法时每个选项的默认值。这个函数与.$.ajax()接受相同的选项对象参数，之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，</p></li><li><p>取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式</p></li></ul><hr><p>以上为最基础核心,掌握运用</p><blockquote><p>开发插件章节  需要后期编码后进行学习 </p></blockquote><h3 id="高级DOM遍历-高级事件处理-高级效果"><a href="#高级DOM遍历-高级事件处理-高级效果" class="headerlink" title="高级DOM遍历 高级事件处理  高级效果"></a>高级DOM遍历 高级事件处理  高级效果</h3><h5 id="高级遍历"><a href="#高级遍历" class="headerlink" title="高级遍历"></a>高级遍历</h5><ul><li> Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。<blockquote><p>使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异</p></blockquote></li><li>选择符优化问题 自定义选择符<blockquote><p>如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器</p></blockquote></li><li>DOM遍历背后的原理<blockquote><p>向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关</p></blockquote></li><li>addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑</li><li>DOM 遍历的性能问题 : 多使用连缀,和缓存jquery对象,来最低限度的重复使用选择符和遍历方法</li></ul><h5 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a>事件处理</h5><ul><li>扩展事件  自定义事件 节流事件</li></ul><h5 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h5><blockquote><p>使用jQuery自定义的:animated选择符, is(‘:animated’)判断是否在动画中</p></blockquote><ul><li><p>中止运行的动画 .stop([clearqueue][jumptoend]) 两个可选参数,默认都为false</p><blockquote><p>在1.7之前版本  在动画之前，这些简写的动画方法(slidedown fadein…)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。</p></blockquote></li><li><p>延迟动画执行 delay() </p></li></ul><ul><li><p>全局效果属性 :$.fx对象  \</p><pre><code>禁用所有动画效果-&gt; $.fx.off=true;定义效果时长 $.fx.speeds= ...  可以改变预设值的效果速度,可以自定义一个速度选项</code></pre></li></ul><ul><li><p>多属性缓动  </p><p>   通过动画方法中,specialEasing选项可以为每个要应用动画的属性设置不同的加速度曲线。任何没有包含在这个选项中的属性，都会使用easing选项中指定的缓动函数——如果提供了的话；否则，就要使用默认的swing函数</p></li><li><p>使用延迟对象,对于任何延迟对象，调用它的.promise()方法就可以取得其承诺对象,</p></li><li><blockquote><p>每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。通过在jQuery对象上调用.promise()方法，可以得到一个队列完成后被解决的承诺对象 .promise().done(showBio); 在队列完成之后调用showBio函数  .always() 在延迟对象完成任务时调用</p></blockquote></li><li><p>.animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  </p><blockquote><p>jQuery动画系统最底层的方法是$.Animation()和$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面</p></blockquote></li></ul><h5 id="高级DOM操作"><a href="#高级DOM操作" class="headerlink" title="高级DOM操作"></a>高级DOM操作</h5><ul><li>从服务端取得数据排序问题</li></ul><hr><p>第十三章 高级ajax操作,要等到node.js时开始</p><p>本文档参考                   &lt;  jquery 基础教程第四版  2020 6.30 &gt;</p>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Jq%20%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/14/Jq%20%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>在使用css函数和transition 进行样式设置时, 如果利用if语句判断当前css函数改变的值,可能会判断不正确,在css还没执行完,if语句已经进行判断(也可能不是if语句,其他语句也会在这期间执行),导致结果和预期不同,  可以使用settimeout()使css执行完之后在进行判断,效果和在动画方法的回调函数中一样</p></li><li><p>jQuery(window).height()代表了当前可见区域的大小，而jQuery(document).height()则代表了整个文档的高度</p></li><li><p>jq动态样式变化(需要时间的变化),不要和transition属性一起用,会导致动画混乱</p></li><li><p>事件委托on中的函数中 的this还是触发事件的元素,不是调用on()的那个元素 </p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World lalla</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="edit-github-from"><a href="#edit-github-from" class="headerlink" title="edit github from"></a>edit github from</h3><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h4 id="Github-action"><a href="#Github-action" class="headerlink" title="Github action"></a>Github action</h4><ul><li>加上 github action 就完成了自动打包 部署  不再使用hexo generate deploy, 直接提交代码就可以了</li></ul><h4 id="改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键"><a href="#改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键" class="headerlink" title="改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键"></a>改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键</h4>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3</title>
    <link href="/2020/12/13/CSS3/"/>
    <url>/2020/12/13/CSS3/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul><li><p>边框</p><ul><li><p>border-radius    圆角</p><blockquote><p>默认一个值应用在四个方向,如果想单独设置,可以各四个值分别代表 从左上顺时针到左下的角</p></blockquote></li><li><p>box-shadow   边框阴影 </p><blockquote><p>四个值分别   x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 </p></blockquote></li></ul></li><li><p>border-image    用图片创建边框</p><ul><li><blockquote><p>三个值 /* border-image: image-source image-height image-width image-repeat */</p></blockquote></li></ul></li><li><p>背景  </p><ul><li>background-size  规定背景图片的尺寸进行缩小扩大使用</li><li>background-origin  规定背景图片的定位区域<blockquote><p>参数:content-box、padding-box 或 border-box  以这几个区域为参考放置图片</p></blockquote></li></ul></li><li><p>文本</p><ul><li>text-shadow 文本应用阴影 (和box-shadow 格式一样)</li><li><blockquote><p>四个值分别 :水平阴影(px)、垂直阴影 (px)、模糊距离(px)，以及阴影的颜色</p></blockquote></li><li>word-break  指定了单词怎样断行</li><li><blockquote><p>有些英语单词单纯断行影响阅读</p></blockquote></li></ul></li><li><p>字体</p><ul><li>@font-face 规则   应用时设置font-family: name 使用自己设置的名字<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;ciclefina&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.eot&#x27;</span>);<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.eot?#iefix&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.woff2&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.woff&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.svg#ciclefina&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;svg&#x27;</span>);<br>  <span class="hljs-attribute">font-weight</span>: normal;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>渐变</p><ul><li> linear-gradient()函数创建  </li><li><blockquote><p> background: linear-gradient(to bottom right, blue, pink);  第一个参数可选 也可以替换成角度  颜色参数也可以是多种颜色  可以控制结束为止,渐变中心… 在使用角度的时候, 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右</p></blockquote></li></ul></li></ul><h3 id="CSS-变形-transforms"><a href="#CSS-变形-transforms" class="headerlink" title="CSS 变形 (transforms)"></a>CSS 变形 (transforms)</h3><ul><li><p>transform-origin 指定原点的位置,默认值为元素的中心，可以被移动</p></li><li><p>适用于三维的属性</p><blockquote><p>首先需要设置的属性是透视值（perspective）。透视正是三维空间的立体感的源泉。元素与观察者之间的距离越远，他们就越小。  CSS 属性 perspective 可以更加真实3d的变换效果,一般放在变换图像外的容器写</p></blockquote><blockquote><p>通过 perspective-origin 属性来设置。默认透视值中，为观察者被置于中心，但是这并不总是适当的。<br>CSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。如果选择平面，元素的子元素将不会有 3D 的遮挡关系。<br> backface-visibility 指定当元素背面朝向观察者时是否可见。</p></blockquote></li></ul><ul><li><p>以下为transform利用函数</p><ul><li><p>translate()   偏移</p></li><li><blockquote><p>元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标）  translatex()  translatey()</p></blockquote></li><li><p>rotate() 平面旋转 参数给与度数</p></li><li><blockquote><p>元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转 rotateX() 围绕x轴旋转多少度  rotateY()  以上两个旋转都是围绕某个轴的<strong>立体旋转</strong></p></blockquote></li><li><blockquote><p>这里所有的3d坐标系, 都是y轴是竖直的,z轴则是向屏幕里的方向</p></blockquote></li><li><p>scale()  </p></li><li><blockquote><p>元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴） 当超出 [-1, 1]范围外时，缩放将在坐标方向上放大元素 如果为负值会反射(反方向投射)</p></blockquote></li><li><p>skew() </p><blockquote><p>一个元素在二维平面上的倾斜转换</p><ul><li>transform-origin  指明元素变形的远点</li></ul></blockquote></li></ul></li></ul><h3 id="CSS过渡-transitions"><a href="#CSS过渡-transitions" class="headerlink" title="CSS过渡 (transitions)"></a>CSS过渡 (transitions)</h3><ul><li><p>transition 提供了一种在更改CSS属性时控制动画速度的方法</p></li><li><p>想让一个元素的属性 transition起来 , 必须要先有预设值, 比如div元素 想要变换width, 那么div元素必须首先定义width,然后通过覆盖/ 添加类名的方式改变width 才可以, 如果一开始div没有width值, 通过添加类给与width值, 这时候是不发生变幻的</p><blockquote><p> 定义 transition:width 2s, height 2s, transform 2s 定义的样式后面书写时间  简写属性</p></blockquote></li><li><p>transition-delay<br>指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</p></li><li><p>transition-duration 变换时间<br>-transition-timing-function 指定一个函数，定义属性值怎么变化</p></li><li><p>当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend</p></li><li><blockquote><p>如果需要循环，查看 animation</p></blockquote></li><li><p>transition 是非常好的工具，可以让 JavaScript 效果平滑而不用修改 JavaScript</p></li><li><p>书写多个过渡效果时，每个完整的要用逗号隔开</p></li><li><p>触发过渡效果,只需要某个属性更改值,这时就会触发,比如 hover写新值,每次移入移出时都能触发过渡,js给标签添加新类也行</p></li></ul><blockquote><p>当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd. propertyName字符串，指示已完成过渡的属性。 elapsedTime 浮点数，指示当触发这个事件时过渡已运行的时间</p></blockquote><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><p>使用keyframes定义动画序列:@keyframes中补写关键帧 from{} to{},</p></li><li><p>animation 简写属性</p><pre><code>animation-duration  设置动画一个周期的时长animation-timing-function 定义CSS动画在每一动画周期中执行的节奏(匀速/先快后慢...)animation-direction  设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行animation-delay 延迟animation-iteration-count 设置动画重复次数， 可以指定infinite无限次重复动画animation-name  指定由@keyframes描述的关键帧名称    </code></pre><blockquote><p> animation: 3s ease-in 1s 2 reverse both paused slidein    animation属性的最后slidein一定为动画名字由@keyframes 定义</p></blockquote></li><li><p>哪些 CSS 属性可以动画?  关注可动画属性列表 对CSS转换同样适用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3 布局总览</title>
    <link href="/2020/12/13/CSS3-%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88/"/>
    <url>/2020/12/13/CSS3-%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="布局拾忆"><a href="#布局拾忆" class="headerlink" title="布局拾忆"></a>布局拾忆</h2><ul><li>正常布局流,以下行为覆盖默认的布局流<ul><li>display 标准的有block inline , 其他的布局形式: </li><li>css Grid </li><li>Flexbox(弹性盒子)</li><li>position</li><li>多列布局</li><li>表格布局</li><li>float</li></ul></li><li>响应式布局</li></ul><h3 id="Flexbox-弹性盒子-专门设计出来用于创建横向或是纵向的一维页面布局"><a href="#Flexbox-弹性盒子-专门设计出来用于创建横向或是纵向的一维页面布局" class="headerlink" title="Flexbox(弹性盒子) : 专门设计出来用于创建横向或是纵向的一维页面布局"></a>Flexbox(弹性盒子) : 专门设计出来用于创建横向或是纵向的一维页面布局</h3><ul><li><p>flex 优势(出现的原因):使多列等高(不管内容)  所有子项有相同的宽/高度(不论还有多少宽高)  父元素中垂直居中块内容</p></li><li><p>flex布局 占用的空间是在设置 padding 和 margin 之后剩余的空间 即尺寸都是内容尺寸 弹性盒子的真正价值可以体现在它的灵活性/响应性 ,flex布局是弹性的 根据排列方式 对你的width进行增加 删除(所以设置的width不一定就按照这个)</p></li><li><p>flex-direction:column  指定主轴方向,默认row排成一排</p></li><li><p>flex-grow : 它指定了flex容器中剩余空间的多少应该分配给项目。剩余的空间是flex容器的大小减去所有flex项的大小加起来的大小</p></li><li><p>flex-basis: 元素的最低的一个值,根据元素的多少会变大(不会变小因为是先减去这个初始大小进行计算的宽/高度)</p></li><li><p>flex-wrap : nowrap  控制flex items换行,这里换行不是在指标签中的内容,而是容器中每个flex元素,每个flex元素看做一个整体控制进行换行否</p></li><li><p>flex (缩写):  flex-grow flex-shrink flex-basis      </p><blockquote><p>行内元素为弹性盒子,可以设置为inline-flex<br>flex-flow(缩写) : flex-direction flex-wrap<br>flex-basis: auto,auto将使用宽度 width作为flex-basis值。</p></blockquote></li><li><p>align-items 控制 flex 项在交叉轴上的位置,默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器, 如果父元素没有固定高度,那就和最长的那一列高度相等</p></li><li><blockquote><p>center 值会使这些项保持其原有的高度，但是会在交叉轴居中</p></blockquote></li><li><blockquote><p>align-self  可以覆盖align-items 一般用来设置某个特定的元素使用</p></blockquote></li><li><p>justify-content 控制 flex 项在主轴上的位置。默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处。 </p></li><li><blockquote><p>space-around ——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。 space-between 则不会再两端留有空间</p></blockquote></li></ul><ul><li>利用order 进行flex 项排序 ,默认值为0 order小的显示顺序在前 可以为负值</li></ul><h3 id="Grid布局-在两个维度把元素按行和列-排列整齐"><a href="#Grid布局-在两个维度把元素按行和列-排列整齐" class="headerlink" title="Grid布局 在两个维度把元素按行和列 排列整齐"></a>Grid布局 在两个维度把元素按行和列 排列整齐</h3><ul><li><p>通过display:gird转到grid布局,分别使用grid-template-rows/columns 两个属性定义一些行/列的大小</p><ul><li>grid-template-rows :规定每一行的高度,有几行写几个值,如果元素内容超过此高度,就会溢出</li><li>grid-template-columns :规定每一列的宽度,宽度内不会溢出内容</li><li><blockquote><p>默认你会看到列的高度调整为与最高的容器一样高<br>grid-template-columns: repeat(12, 1fr);创建12列等宽<br>fr 单位——这个为网格布局定义的单位,如果所有列都是1fr，它们将占用相等的空间量。这消除了计算百分比以创建灵活网格的需要。</p></blockquote></li></ul></li><li><p>利用 grid-column 和 grid-row 两个属性来指定元素跨越的列数/行数.</p></li><li><blockquote><p>grid-column: auto / span 6; 跨6列</p></blockquote></li><li><blockquote><p>grid-column:span 2/3 -&gt; 从第三基线向前扩展两行</p></blockquote></li><li><blockquote><p>grid-template-areas设置区域 ,用 grid-area  是设置行和列的grid-column/row的简写</p></blockquote></li><li><p>grid-gap 属性用来设置网格行与列之间的间隙</p></li></ul><blockquote><p>使用grip-row/column 时有时候会导致子项之间位置变化,这时候同时设置grip-row grip-column 两项保证位置不变的情况进行扩展</p></blockquote><ul><li>在不使用gird的情况下怎么创建网格布局: 可以利用div块 子元素的浮动属性,构建一个网格系统布局,但是这是固定的宽度,创建流体网格可以使用百分比设置宽度   flex也可以用来创建网格系统,但是flex仍然是一维设计的,用来处理网格还是需要计算width</li><li>第三方网格系统 :  Bootstrap 提供了独立的网格系统</li></ul><h3 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h3><p>-绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素</p><ul><li><p>absolute 定位 :元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。 没有非static祖先元素定位,则针对可视窗口定位(类似fixed)</p></li><li><blockquote><p>绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p></blockquote></li><li><p>绝对定位元素填充可用空间 :</p></li><li><blockquote><p>大多数情况下，height和width 被设定为auto的绝对定位元素，按其内容大小调整尺寸, 被绝对定位的元素可以通过指定top和bottom ，保留height未指定（即auto），来填充可用的垂直空间。它们同样可以通过指定left 和 right并将width 指定为auto来填充可用的水平空间。     当大小不足以满足上下 左右的px值时,top left优先级大于 rigtht bottom</p></blockquote></li><li><p>固定定位应用于视口(viewport)边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p></li><li><p>相对定位(relative positioning)让你能够把一个正常布局流(normal flow)中的元素从它的默认位置按坐标进行相对移动。</p></li><li><p>固定定位fixed：对于浏览器可视窗口进行定位</p></li><li><p>粘性定位(sticky position)  元素根据正常文档流进行定位，然后相对它的最近滚动祖先,无法做到能够随意在页面像absolute那样定位, 正常文档流,简单理解粘性定位,是针对外围的父元素(作为容器)进行定位</p></li></ul><blockquote><p>left rigth 的值如果是百分比,则是非static定位的祖先元素的宽度   top bottom则是高度的百分比<br>z-index属性。 “z-index”是对z轴的参考 ,当元素开始重叠，什么决定哪些元素出现在其他元素的顶部</p></blockquote><ul><li>定位层级z-index：在重叠时决定谁在上面<br>对于<strong>定位元素</strong>来说通过定义层级来决定谁的层级高<br>默认后者高于前者 <strong>同级的元素才有可比性</strong>,父子元素之间的z-index是失效的(除非子元素设置负值父元素设置auto)</li><li>对于同级元素说,z-index根据数值大小进行排列</li><li>z-index 也支持过渡效果,它没有在每一步改变它的值(没有渐变效果)，所以你认为它没有过渡效果，但实际上是有的<blockquote><p>对于float元素 z-index还有更复杂的状况.详细查询资料</p></blockquote></li></ul><h3 id="多列布局-通常也简写为-multicol"><a href="#多列布局-通常也简写为-multicol" class="headerlink" title="多列布局 通常也简写为 multicol"></a>多列布局 通常也简写为 multicol</h3><ul><li>column-count    column-width 属性把块变为多列容器<blockquote><p>column-width  浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p></blockquote></li><li>Multicol 创建的列无法单独的设定样式。 不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。<ul><li> column-gap 改变列间间隙。</li><li> column-rule 在列间加入一条分割线。</li></ul></li><li>多列布局的内容因为空间问题(分配内容是按一列一列的填充)被拆成多个内容(称为内容折断)  通过属性break-inside: avoid 在内容(子元素)中添加防止</li></ul><h5 id="float-浮动"><a href="#float-浮动" class="headerlink" title="float 浮动"></a>float 浮动</h5><ul><li><p>浮动后,文本和内联元素环绕它,如果文本或者内联元素包裹在div中,那么仍然会环绕它,(块级元素不会换行,除非div块中还有块级元素,块级元素后还有内容),</p></li><li><p>行级元素可以设置宽高有了块级元素的特征 ，不设置时有内容撑开元素<br>浮动元素向指定方向移动，直到遇见边框。<br>浮动元素浮动时子元素撑开父元素 (创建bfc时才行)</p></li><li><p>浮动元素会提升层级压住标准元素</p></li><li><p>clear 属性适用于浮动和非浮动元素。 clear方法可以让浮动元素撑开父容器</p></li></ul><h3 id="正常文档流"><a href="#正常文档流" class="headerlink" title="正常文档流"></a>正常文档流</h3><ul><li>取得元素的内容来放在一个独立的元素盒子中，然后在其周边加上内边距、边框和外边距 — 就是我们之前看到的盒子模型。</li><li>默认的，一个块级元素的内容宽度是其父元素的100%，其高度与其内容高度一致。行内元素的height width与内容一致,你无法设置行内元素的height width</li></ul><h3 id="表格布局-通常用于老的不支持-弹性盒子的浏览器"><a href="#表格布局-通常用于老的不支持-弹性盒子的浏览器" class="headerlink" title="表格布局(通常用于老的不支持 弹性盒子的浏览器)"></a>表格布局(通常用于老的不支持 弹性盒子的浏览器)</h3><ul><li>display: table  display: table-row ..</li></ul><hr><p>(待实践…)</p><h3 id="传统的布局方法"><a href="#传统的布局方法" class="headerlink" title="传统的布局方法"></a>传统的布局方法</h3><ul><li>我们在宽度的表示上都用的是百分比,这创建了一个流动布局（liquid layout），能够适应不同的屏幕大小，这是响应式网页非常有价值的一个工具。</li><li>固定宽度网格,通过浮动和div块固定的width创建一个网格</li><li>创建液态网格(弹性（流体）的网格),把固定宽度转为伸缩的基于百分比宽度的算式在下面：</li><li><blockquote><p>target (目标列长度)/ context (上下文)= result  你可以用 calc() 函数来在CSS里面做数学方面的计算</p></blockquote></li><li>我们挪动小数点两位，得到百分数,在css中我们使用百分比代替固定数值</li><li><blockquote><p>这个系统的最大限制是，它本质上是一维的。我们在处理列、让元素跨越列，但是处理不了行。如果不设置一个确定的高度，用老方法很难控制元素高。这个方法很不灵活 —它只有在你确定你的内容有个明确的高的情况下有用。</p></blockquote></li></ul><h3 id="旧浏览器支持"><a href="#旧浏览器支持" class="headerlink" title="旧浏览器支持"></a>旧浏览器支持</h3><ul><li>在CSS中构建回滚 CSS规范包含了在一个物件上同时应用两种布局的时候，解释浏览器反应的信息</li><li>特性查询  允许测试一个浏览器是否支持特定的一个css特性</li><li>测试旧浏览器</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS指导</title>
    <link href="/2020/12/13/CSS%E6%8C%87%E5%AF%BC/"/>
    <url>/2020/12/13/CSS%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS-指南"><a href="#CSS-指南" class="headerlink" title="CSS 指南"></a>CSS 指南</h3><h4 id=""><a href="#" class="headerlink" title=""></a><!doctype html></h4><ul><li><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“**怪异模式(兼容模式)**”的渲染模式。“<!DOCTYPE html>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></li><li><p>兼容模式下 会出现很多问题, 比如 css应用问题, 加上标签和不加标签可能会出现差异,不如各个浏览器排版会出现问题</p><h4 id="css引用方法"><a href="#css引用方法" class="headerlink" title="css引用方法"></a>css引用方法</h4></li></ul><ol><li>行内式 </li><li>内嵌式  在head标签中书写《style》</li><li>链接式  《link href  rel  type》<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4></li></ol><ul><li><p>选择器：基本选择器</p><pre><code>  元素选择器、  类选择器、格式.   id选择器 格式：#   伪类/元素选择器 格式--&gt;标签：伪类  标签 ::伪元素     通用选择器 格式 *</code></pre></li><li><p>复合选择器（对基本选择器的组合使用）</p><pre><code>  交集选择器 格式：中间无空格   并集选择器(对于多个标签同时修饰) 格式：,  后代选择器  格式：中间加空格    子元素选择器：格式：标签&gt;标签   相邻兄弟选择器(拥有相同的父元素) 格式：+  属性选择器：格式 ：标签[属性]   </code></pre><blockquote><p>子元素选择器范围比后代更小<br>一个页面只能有一个独特的ID，但是很多元素都有相同的类 </p></blockquote></li><li><p>伪类选择器不能被嵌套  ，他们不能被当作 :not() 中的参数 ，形如 :not(p::before) 这样的选择器将不会工作。</p></li><li><h4 id="css样式规则"><a href="#css样式规则" class="headerlink" title="css样式规则"></a>css样式规则</h4></li></ul><ol><li>优先级  id&gt;class&gt;…  那个选择器更具体 那个优先级就高</li></ol><ul><li>为目标元素直接添加样式，永远比继承样式的优先级高，无视优先级的遗传规则。从上面结果不难看出 行间style &gt; 后代 &gt; id &gt; class &gt; 元素<blockquote><p>判断优先级，以权重为指标，权重越大优先级越高：一般约定 id选择器的权重为100，类选择器权重为10，元素选择器权重为1。一个复杂的选择器的权重,例如后代选择器 ID选择器 元素选择器 权重为101,</p></blockquote></li></ul><ol><li><p>层叠  当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</p></li><li><p>继承  设置在父元素上的css属性是可以被子元素继承的，有些不行不如width border…</p><pre><code> 控制继承:  inherit 开启继承,浏览器默认值 inherit  unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样       all: unset:重设所有属性值</code></pre></li><li><p>!important打破优先级使用该属性 覆盖!important 唯一的办法就是另一个 !important  </p></li></ol><ul><li><p>有继承性的属性</p><pre><code>  font  text-indent：文本缩进  text-align：文本水平对齐  visibility:隐藏  line-height：行高  word-spacing：增加或减少单词间的空白（即字间隔）  letter-spacing：增加或减少字符间的空白（字符间距）  text-transform：控制文本大小写  direction：规定文本的书写方向  color</code></pre></li><li><p>@import  @media<br>font, background, padding, border, andmargin等属性称为速记属性</p></li></ul><h4 id="盒子模型-–参考MDN"><a href="#盒子模型-–参考MDN" class="headerlink" title="盒子模型  –参考MDN"></a>盒子模型  –参考MDN</h4><ul><li><p>基本盒子分为：块级盒子（Block box） 和 内联盒子（Inline box） </p></li><li><p>css的box模型有内部和外部显示类型 ，外部显示类型，来决定盒子是块级还是内联。同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局 </p></li><li><p>如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。</p></li><li><p>内联盒子的特征，width height无效，就是说内联盒子的内容大小不会发生改变，</p><blockquote><p>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 如果碰见边界的话设置垂直padding,也不会应用<br>水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。</p></blockquote></li><li><p>盒子模型分为 标准盒模型 替代盒模型 ，区别在于标准盒模型计算盒子大小是需要加上 padding border</p><blockquote><p>盒子大小是border以内的值不包括margin<br>如果使用替代盒模型 需要html设置，全部改为替代模型</p></blockquote></li></ul><p>-</p><ul><li>display: inline-block 不希望一个项切换到新行，但希望它可以设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。  外部仍然为inline的状态 <blockquote><p>inline或者block，来控制盒子的外部显示类型<br>flex属性：内部显示属性  内联显示，外部显示类型为块级元素</p></blockquote></li><li>inline-flex：内外部为内联属性  但是和inline属性有点差别</li></ul><ul><li><p>内边距 padding特点：</p><pre><code>  撑大元素的尺寸，上下左右多出padding设置值，也就是2*padding  背景会随着撑大元素的尺寸而扩大</code></pre></li></ul><h5 id="盒子模型是否被内容撑开的问题"><a href="#盒子模型是否被内容撑开的问题" class="headerlink" title="盒子模型是否被内容撑开的问题"></a>盒子模型是否被内容撑开的问题</h5><ul><li><p>块级元素不能正好的撑开内联元素,而是外部的内联元素会变得超级大,所谓内容决定内联元素的宽度指的是文字,图片img元素也不能撑开内联元素 ,(内联元素无法撑开内联元素,通过嵌套span考证,个人理解,内联元素只能被文本撑开)  如果想要撑开,就把外层的内联元素换成 inline-black元素</p></li><li><p>内联元素撑开块级元素,带有文档的内联元素可以撑开块级元素,不带有文字的内联元素,比如img 不能正好的撑开块级元素,会有缝隙,解决方法:设置内部为块级元素就可以撑开 或者固定块级元素高度</p></li><li><p>只有块级元素能正好的撑开元素</p></li><li><p>三层嵌套 依次块级元素 内联元素 块级元素  按照以上分析  最内层的块级元素不能正好撑开内联元素,但是可以正好撑开最外部的块级元素 </p></li><li><p>块级元素在内联元素中,不再影响内联元素外的元素 </p></li></ul><h5 id="外边距margin-折叠"><a href="#外边距margin-折叠" class="headerlink" title="外边距margin 折叠"></a>外边距margin 折叠</h5><blockquote><p>创建新的BFC避免两个相邻 &lt; div&gt; 之间的外边距合并问题   </p></blockquote><blockquote><p>注意有设定float和position=absolute的元素不会产生外边距重叠行为。脱离文档流不存在此问题</p></blockquote><ol><li><p>同一层相邻元素之间的外边距重叠</p><pre><code> 外边距合并：相邻元素margin-top 和margin-bottom 长度会合并成两者间较大的数值，如果有负值就是两者的和,两者都为负值就取绝对值最大的 解决: 后一个元素加上clear-fix清除浮动。</code></pre></li><li><p>没有内容将父元素和后代元素分开</p><pre><code> 父子元素外边距合并：如果没有边框border，内边距padding，行内内容(背景也算内容)，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top； 父子元素上外边距会合并,较大的值最终会溢出到父级块元素外面。表现为父元素向下推了子元素多出来的值</code></pre></li></ol><ol start="3"><li><p>空白div块</p><pre><code> 假设有一个空元素，它有外边距，但是没有边框或填充 高度 inline clear-fix。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。</code></pre></li></ol><h5 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h5><ul><li>块格式化上下文（Block Formatting Context，BFC)，<strong>是块盒子的布局过程发生的区域</strong>，也是浮动元素与其他元素交互的区域。<blockquote><p>块格式上下文 最主要的目的:  对浮动元素的限制  清除浮动的范围,块格式上下文有点像一个针对浮动元素的容器</p></blockquote></li></ul><ul><li>浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</li><li>一个新的 display 属性的值，它可以创建无副作用的 BFC。在父级块中使用 display: flow-root 可以创建新的 BFC。</li></ul><ul><li>overflow 值不为 visible 的块元素 绝对定位元素  行内块元素 浮动元素…<blockquote><p>更多创建bfc方法参考 MDN  </p></blockquote></li></ul><ul><li><p>clearfix方法</p></li><li><p>如果一个元素里只有浮动元素，那它的高度会是0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-pseudo">::after</span> &#123; <br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="高度塌陷和BFC"><a href="#高度塌陷和BFC" class="headerlink" title="高度塌陷和BFC"></a>高度塌陷和BFC</h6></li><li><p>在文档流中，父元素的高度默认是被子元素撑开的，当为子元素设置浮动以后，子元素会完全脱离文档流，此时就会导致子元素无法撑起父元素的高度，此引发父元素的高度塌陷</p></li><li><p>解决塌陷方法:创建一个会包含这个浮动的BFC:</p></li></ul><h5 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h5><ul><li><p>content-box(默认值),设置宽高仅仅是内容的, 任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p></li><li><p>border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。</p></li></ul><h4 id="隐藏标签"><a href="#隐藏标签" class="headerlink" title="隐藏标签"></a>隐藏标签</h4><ul><li>display:none —不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。</li><li>visible:hidden— 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。这是个继承元素</li><li>元素使用visibility:hidde时 如果在设置:hover状态,这是不会触发,因为这时已经隐藏不可能触发</li><li>opacity : 0 , 不可见,但保留位置</li></ul><h4 id="行内元素-可替换元素"><a href="#行内元素-可替换元素" class="headerlink" title="行内元素 可替换元素"></a>行内元素 可替换元素</h4><ul><li><p>一般情况下，行内元素只能包含数据和其他行内元素。行内元素列表</p><p>  b, big, i, small, tt<br>  abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var<br>  a, bdo, br, img, map, object, q, script, span, sub, sup<br>  button, input, label, select, textarea</p></li><li><p>可替换元素可以设置宽高,css对可替换元素的影响在 内容在框中的位置和定位方式  可替换元素</p><pre><code>  &lt;iframe&gt;  &lt;video&gt;  &lt;embed&gt;  &lt;img&gt;</code></pre><blockquote><p>“image” 类型的 &lt; input&gt; 元素就像&lt; img&gt;一样被替换。 </p></blockquote></li></ul><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><ul><li><p>根据各种设备特征和参数的值或者是否存在来调整您的网站或应用,它们是响应式设计的关键组成部分。</p></li><li><p>在html中应用媒体查询 : 在&lt; link&gt;元素的media属性中，它们定义了待应用链接资源（通常是CSS）的媒体。   在&lt; style&gt;元素的media属性中，它们定义待应用样式的媒体。</p></li><li><p> 在 CSS 中，使用 @media at-rule 根据媒体查询的结果有条件地应用样式表的一部分。 使用 @import 条件地应用整个样式表。</p><blockquote><p>格式  @media media-type 媒体类型(4种) and (media-feature-rule 媒体特性) { }<br>媒体类型: 告诉浏览器这段代码是用在什么类型的媒体上的  媒体查询中存在逻辑运算</p></blockquote></li><li><p>在 JavaScript 中使用媒体查询   使用 Window.matchMedia() 方法根据媒体查询测试窗口 MediaQueryList.addListener()在查询状态发生变化时收到通知  DOM 提供了通过编程方法来获得媒体查询结果的特性   具体参看MDN</p></li></ul><blockquote><p>使用媒体查询 需要参考 媒体特性  详情查询MSN @media</p></blockquote><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><ul><li><p>指的是允许Web页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践</p><blockquote><p>需要你理解的很重要的一点是响应式Web设计不是单独的技术,它是用来建立可以响应查看内容的设备的样式的一个词。</p></blockquote></li><li><p>响应式设计是三种技术的混合使用。第一个是液态网格,第二个是液态图像的理念,第三个关键的组件是媒体查询</p><ul><li>媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将CSS选择性地适应用户的需要应用在样式化页面上。</li></ul></li><li><p>你真的需要媒体查询吗？</p><blockquote><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。</p></blockquote></li></ul><ul><li><p>响应式设计方法: </p><pre><code>   你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做移动优先的响应式设计，很多时候是最值得仿效的做法。</code></pre></li></ul><ul><li>响应式图像 <ul><li>使用max-width : 100% 设置img ,这种方式的弊端显而易见,图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽(手机端不需要这么大的文件)</li><li>使用了&lt; picture&gt;元素 或者&lt; img&gt; srcset和sizes 特性 浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。 (详情查看picture)</li></ul></li></ul><ul><li>响应式排版(针对文本)</li><li>使用视口单位(vw)实现响应式排版,文本内容使用vw根据视口大小变化</li><li><blockquote><p>永远都不要只用viewport单位设定文本。这样会导致文本内容一直随着视口变化,没有了一个最低变化的限度,内容不能够放缩(通过改变宽度导致内容缩在边框之外)  将vw单位加到了使用固定大小解决</p></blockquote></li></ul><ul><li>视口元标签 &lt; meta name=”viewport” content=”width=device-width,initial-scale=1”&gt;</li><li><blockquote><p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度,为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为960像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本</p></blockquote></li></ul><h4 id="Css-条件规则组"><a href="#Css-条件规则组" class="headerlink" title="Css 条件规则组"></a>Css 条件规则组</h4><ul><li><p>格式 @ + name</p><h3 id="CSS-指北-–参考MDN"><a href="#CSS-指北-–参考MDN" class="headerlink" title="CSS 指北  –参考MDN"></a>CSS 指北  –参考MDN</h3><h4 id="样式化-文本"><a href="#样式化-文本" class="headerlink" title="样式化 (文本)"></a>样式化 (文本)</h4></li><li><p>字体种类<br>   网页安全字体 font-family 的例子</p></li><li><p>字体大小</p><ul><li>1em 等于我们设计的当前元素的父元素上设置的字体大小 </li><li><blockquote><p>font-size是一个继承属性</p></blockquote></li><li>浏览器的font-size 默认的值为 16px,其他元素也许有默认的大小，比如&lt; h1&gt;元素有一个 2em 的默认值，所以它的最终大小值为 32px</li><li><blockquote><p>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小 rem 不支持 Internet Explorer 8 和以下的版本</p></blockquote></li></ul></li><li><p>四种属性改变文本样式</p><pre><code>font-style 打开关闭斜体font-weight 设置字体粗细text-decoration  设置文本划线text-transform: 允许你设置要转换的字体 比如大小写,全半角 </code></pre></li><li><p>text-shadow 文本阴影</p></li><li><p>文本布局</p><pre><code>  text-align 属性定义行内内容（例如文字）如何相对它的块父元素(内容盒子)对齐,这里的行内内容不一定是文字,可能是a标签.  line-height 行高,设置文本每行之间的高 设置无单位的值 例如:1.5 1.5乘以font-size得到的是行高  letter-spacing  字母之间间距  word-spacing 单词与单词之间的间距  text-indent: 指定文本内容的第一行前面应该留出多少的水平空间。  text-overflow: 定义如何向用户表示存在被隐藏的溢出内容。  white-space: 定义如何处理元素内部的空白和换行。  word-break: 指定是否能在单词内部换行。  text-orientation: 定义行内文本的方向。  word-wrap: 指定浏览器是否可以在单词内换行以避免超出范围。  writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</code></pre></li></ul><ul><li><p>height = line-height时 文字垂直居中显示</p></li><li><p>内联元素的高度有其中的文本内容 的font-size line-height共同决定, 如果字体大小比行高小一定的值,那高度就是行高</p></li><li><p>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。</p></li><li><p>text-indent 属性能定义一个块元素首行文本内容之前的缩进量。设置负值用来移出文档显示,块内元素中如果有内联元素例如 img span等,会移出文档,  该属性为继承属性 ,对内联元素中的内容无效</p></li><li><p>vertical-align 用于以下两种情况  1.使行内元素盒模型与其行内元素容器垂直对齐</p></li><li><p>2.垂直对齐表格单元内容:</p></li><li><p>vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。</p></li><li><p>margin取负值margin-left 和 margin-top：影响自身元素，自身元素将向指定方向偏移margin-bottom将影响后元素，使后元素向上偏移对应像素</p></li></ul><h4 id="样式化列表"><a href="#样式化列表" class="headerlink" title="样式化列表"></a>样式化列表</h4><pre><code>    &lt;ul&gt;和&lt;ol&gt;元素默认设置margin的顶部和底部    &lt;li&gt;  默认是没有设置间距的    &lt;dl&gt;元素默认设置 margin的顶部和底部: 16px(1em) ，无内边距设定    &lt;dt&gt;     &lt;dd&gt; 元素设置为： margin-left  40px (2.5em)。           list-style-type ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。    list-style-position ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。    list-style-image ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。    速记属性 list-style 完成以上三个的设置</code></pre><ul><li>管理列表技术  <ul><li>ul ol上的属性    </li><li>start 属性允许你从1 以外的数字开始计数  </li><li>reversed 属性将启动列表倒计数</li><li>value 属性允许设置列表项指定数值</li></ul></li></ul><h4 id="样式化链接"><a href="#样式化链接" class="headerlink" title="样式化链接"></a>样式化链接</h4><ul><li>链接状态 通过伪类进行设置<ul><li>Link (没有访问过的): 这是链接的默认状态 </li><li>Visited: 这个链接已经被访问过了</li><li>Hover: 当用户的鼠标光标刚好停留在这个链接</li><li>Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab  移动到这个链接的时候)</li><li>Active: 一个链接当它被激活的时候 (比如被点击的时候)</li></ul></li><li>在链接中包含图片 通过background</li><li>样式化链接为按钮 </li></ul><h4 id="网络字体"><a href="#网络字体" class="headerlink" title="网络字体"></a>网络字体</h4><ul><li>在CSS的开始处有一个@font-face块，它指定要下载的字体文件</li></ul><h4 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h4><ul><li><p>使用 table-layout: fixed 创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。</p></li><li><blockquote><p>默认情况下表格及单元格的宽度取决于其包含的内容。</p></blockquote></li><li><p>使用 border-collapse: collapse 使单元格边框塌陷,使得多个边框合并成一条</p></li><li><p>caption-side属性 : 会将表格的标题&lt; caption&gt; 放到规定的位置</p></li><li><p>使用样式化文本的属性来对表格中的文字格式样式化,加上字体/背景色,完成了样式化的工作</p><h4 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h4></li><li><p>background 属性</p><pre><code>-clip  设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。三个参数为:border-box  padding-box padding-box-color  设置背景色  关键字transparent-image 用于为一个元素设置一个或者多个背景图像 url()-origin 指定背景图片的原点位置,从border开始 border-box;从内边距开始 padding-box;从内容开始 content-box;  (默认在左上角)- position 为每一个背景图片设置初始位置。这个位置是相对于由 background-origin 定义的位置图层的。如果被定义为两个值，那么第一个值代表水平位置，第二个代表垂直垂直位置。百分比值的偏移指定图片的相对位置和容器的相对位置重合。值0%代表图片的左边界（或上边界）和容器的左边界（上边界）重合。值100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值50%则代表图片的中点和容器的中点重合 关键字 center，用来居中背景图片。(并非把图片移动到中间显示) 关键字 top, left, bottom, right 中的一个。用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，- repeat 定义背景图像的重复方式 背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。- size   设置图片大小;  1个值,这个值指定图片的宽  2个值 宽和高;- 关键字cover 拉伸到新的尺寸覆盖容器全部空间  contain 按原有比例缩放到可用空间的尺寸,不一定能够覆盖完容器  - attachment 决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。 fixed表示背景相对于视口固定背景不会随着内容滚动 local 随着内容滚动    scroll 相对于内容固定,对于外部元素随之滚动  </code></pre></li></ul><ul><li><p>opacity属性指定了一个元素的透明度, 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待, 即使这个值没有被子元素继承</p></li><li><blockquote><p>因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值</p></blockquote></li><li><p>使用opacity属性，当属性值不为1时，会把元素放置在一个新的层叠上下文中。</p></li></ul><h4 id="处理不同方向的文本"><a href="#处理不同方向的文本" class="headerlink" title="处理不同方向的文本"></a>处理不同方向的文本</h4><ul><li>CSS中的书写模式是指文本的排列方向是横向还是纵向的。</li><li>writing-mode 属性使我们从一种模式切换到另一种模式,horizontal-tb模式,水平方式写入，写入方向从top到bottom</li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul><li>CSS中万物皆盒，因此我们可以通过给width和height（或者 inline-size 和 block-size）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，</li><li>只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。</li><li>overflow属性是你控制一个元素溢出的方式，</li><li>溢出建立了块级排版上下文 BFC，你改变了overflow的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。</li></ul><h4 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h4><ul><li><p>在CSS中使用了各种数值数据类型 :数字 长度 百分比</p></li><li><p>长度分为绝对长度 相对长度(em  rem lh),相对长度单位相对于其他一些东西</p></li><li><p>如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p></li><li><p>如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。</p></li><li><p>关于使用百分比来确定 元素的高度宽度,  body,html 百分比,是针对浏览器可视窗口的宽度高度,对于body中嵌套的子元素,如果也使用百分比确定宽高,那么针对的也是可视窗口</p></li></ul><h4 id="调节项目大小"><a href="#调节项目大小" class="headerlink" title="调节项目大小"></a>调节项目大小</h4><ul><li><p>块级元素的行为就是这样的。它没有高度，或者说高度为0，因为内部没有内容</p></li><li><p>块级元素我们可以给它一个具体的 width 和 height 值, 然后不论我们放什么内容进去它都是该尺寸,如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出</p></li><li><p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p></li><li><p>如果你把margins和padding设置为百分数的话，你会注意到一些奇怪的表现。你也许会希望上下的外边距是元素高的一个百分数，左右外边距是元素宽的百分数。但是，情况不是这样的！所有的值都是以父容器的宽度来计算的</p></li><li><p>min-和max-尺寸 这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p></li><li><p> max-width的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。作为示例，如果你设定一个图像的属性为width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p></li><li><blockquote><p>如果你使用了max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的100%。这个技术是用来让图片可响应的</p></blockquote></li><li><p>我们有与视口尺寸相关的度量单位，即意为视口宽度的vw单位，以及意为视口高度的 vh单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。1vh等于视口高度的1%，1vw则为视口宽度的1%.你可以用这些单位约束盒子的大小</p></li></ul><h4 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h4><ul><li>图像和视频被描述为替换元素。 这意味着CSS不能影响这些元素的内部布局-仅影响它们在页面上于其他元素中的位置,</li><li>你可以对容器内的图像作其他选择，例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。</li><li>object-fit属性可以在这里帮助你。当使用object-fit时，替换元素可以以多种方式被调整到合乎盒子的大小。 cover  contain fill …</li><li>在替换元素使用各式CSS布局技巧时，你可能深切地体会到他们的展现略微与其他元素不同，例如，在一个flex或者grid布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
