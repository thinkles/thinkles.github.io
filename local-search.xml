<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/webpack/"/>
    <url>/2020/12/14/Js-dom/webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul><li><p>为什么使用webpack?</p></li><li><blockquote><p>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。</p><p><strong>分块传输</strong>，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案,要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。</p><p>在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源,如果他们都可以视作模块，并且都可以通过<code>require</code>的方式来加载，将带来优雅的开发体验</p></blockquote></li><li><p>依赖图: 当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 <a href="https://webpack.docschina.org/concepts/entry-points/"><em>入口</em></a> 开始，webpack 会递归的构建一个<em>依赖关系图</em>，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 <em>bundle</em> —— 通常只有一个 —— 可由浏览器加载。</p></li><li><p>loader : Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p></li><li><p><em>在安装一个 package，而此 package 要打包到生产环境 bundle 中时，你应该使用</em> <code>npm install --save</code><em>。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用</em> <code>npm install --save-dev</code><em>。更多信息请查看</em> <a href="https://docs.npmjs.com/cli/install">npm 文档</a><em>。</em></p></li></ul><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><ul><li><p>chunk : 具有依赖关系的模块,打包时被封装为一个 chunk  可以理解为一个文件夹</p></li><li><p>path : 打包完成后存储在硬盘上的位置 ,绝对路径</p></li><li><p>publicPath : 指定资源的请求位置的,   (该配置项的原理: 在打包之后更改打包后文件内简介资源的路径,让打包后的资源正常获取)</p></li><li><blockquote><p>请求位置: 由JS或CSS所请求的间接资源路径,</p><p>间接资源指 : 不是首次必须加载的资源例如:</p><p>由html页面  script请求的 js 文件  link  </p><p>js 请求的 异步加载的js,( 首屏js 进一步加载的js) </p><p> css请求的图片和字体等..</p></blockquote></li><li><p>publicPath的三种形式</p></li><li><blockquote><p>“” “./js”  : 这是以html 文件 所在路径+publcPath路径 作为请求路径</p><p>“/“ “/js”  : 这是以该页面的 hostname 路径+publicPath  作为请求路径</p><p>“<a href="http://cdn.com/&quot;">http://cdn.com/&quot;</a>  以cdn + publicPath  作为请求路径</p></blockquote></li><li><p>publicPath 并不会对生成文件的路径造成影响，主要是对你的页面里面引入的资源的路径做对应的补全，常见的就是css文件里面引入的图片</p></li><li><blockquote><p>为了避免开发环境 和 生产环境产生不一致 , 我们把 wds 的publcPath  和webpack output.path 保持一致</p></blockquote></li><li><p>filename : 可以利用filename 提供的变量 控制客户端缓存, 每次内容更改就变换名字,防止浏览器使用缓存</p></li></ul><h4 id="预处理器loader"><a href="#预处理器loader" class="headerlink" title="预处理器loader"></a>预处理器loader</h4><ul><li><p>在引入loader时,可以通过options 提供额外的配置</p></li><li><p>loader 相关配置</p></li><li><blockquote><p>exclude  : 排除被正则匹配到的该模块  必加项 exclude: /node_modules/, 或者 include : /src/ </p><p> include: 只对该模块进行匹配正则</p><p>exclude 优先级更高</p></blockquote></li><li><blockquote><p>resource issuer : 可以更加精确的确定模块规则的作用范围</p><p>resource: 被加载模块   issuer:加载者</p><p>test exclude include 本质上是resource 的配置.我们也可以给issur 添加额外的配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">rules:</span>[&#123;<br><span class="hljs-symbol">test:</span>/\..<br><span class="hljs-symbol">issuer:</span>&#123;<br><span class="hljs-symbol">test:</span>/\<br><span class="hljs-symbol">include:</span>src/<br>&#125;&#125;<br>]<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ul><li><p>手动编译文件很麻烦 , webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码：</p><ol><li>webpack <a href="https://webpack.docschina.org/configuration/watch/#watch">watch mode</a>(webpack 观察模式) 其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建</li><li>webpack-dev-server  </li><li>webpack-dev-middleware</li></ol></li><li><blockquote><p>在 watch 触发增量构建后会删除 <code>index.html</code> 文件，</p><p>可以在 <code>CleanWebpackPlugin</code> 中配置 <a href="https://github.com/johnagan/clean-webpack-plugin#options-and-defaults-optional"><code>cleanStaleWebpackAssets</code> 选项</a> 来实现：</p></blockquote></li><li><blockquote><p>webpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。 webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。</p></blockquote></li><li><p><strong>webpack-dev-server:</strong></p></li><li><p>配置中的devserve 对象,是对webpack -dev-serve 准备的, ‘wds’可以看做是一个服务者,他接受浏览器的请求,返回资源浏览器,</p></li><li><blockquote><p>步骤: </p><p>服务启动时, ‘wds’进行模块打包,便准备好资源(js文件等),当浏览器请求时,首先它先效验url地址, 如果该地址是资源服务地址(配置的publickPath) ,就会从打包结果中寻找资源返回给服务器. 如果不是,就读取硬盘内的源文件返回给浏览器</p></blockquote></li><li><p><strong>webpack-dev-server 在编译打包之后不会写入到任何输出文件</strong> ,打包结果被放在了内存中而不是实际磁盘内。换句话说他不会生成新的文件,每次接到浏览器的请求,都只是将内存中的打包结果返回给浏览器</p></li><li><blockquote><p>删除输出目录 /dist 可以验证. 不存在输出目录也一样正常运行, 从开发角度看是符合情理的,如果每次更改都写入实际文件,会产生没有的垃圾文件</p></blockquote></li><li><p>“wds” 参数说明:</p></li><li><blockquote><p>ContentBase:    “wds”用来指定服务器资源的根目录,静态资源从该目录中找寻,默认使用和webpack-config.js 相同目录</p><p>PublicPath:    打包后的bundle.js,将在此路径下可用, 默认情况下，<code>devServer.publicPath</code> 为 <code>&#39;/&#39;</code></p><p>之后ContentBase 也会以该路径为基础,加上自身的路径,来查找静态资源, 所以建议 <code>devServer.publicPath</code> 与 <a href="https://webpack.docschina.org/configuration/output/#outputpublicpath"><code>output.publicPath</code></a> 相同。 或者<em>ContentBase 使用绝对路径。</em></p><p>./src/img/ba.jpg  相对于<a href="http://localhost:8080/+publicPath+">http://localhost:8080/+publicPath+</a></p><p>\src\img\ba.jpg  绝对路径  ContentBase+ 该路径</p></blockquote></li></ul><ul><li><p>wds  默认情况下开启之后, 会在当前根目录中寻找静态资源(图片..), 浏览器发送请求 <a href="http://localhost:3000/">http://localhost:3000/</a>, (该路径还可以使用publicPath更改,但是浏览器只默认打开localhost ), wds返回编译后在内存中的 打包文件和html文件,可以以该路径为基础,向别的文件夹请求.</p></li><li><blockquote><p>在不设置publicPath 路径情况下,  <a href="http://localhost:3000/">http://localhost:3000/</a>  加载虚拟服务器中打包在内存中的资源, 他也表示文件夹的根目录</p><p>在设置publicPath 路径下(不进入publicPath设置的路径),  <a href="http://localhost:3000/">http://localhost:3000/</a> 表示文件夹的根目录,默认加载根目录的index.html文件(不属于资源服务地址,直接读取硬盘内容), 所以这时改变源文件,页面不会自动变化必须得刷新一下重新请求,因为这时使用的不是内存中的文件</p></blockquote></li><li><blockquote><p>浏览器进入别的文件夹之后,自动解析该文件夹的index.html </p><p>本质上, wds 和打包后输出文件夹没有关系,启动wds 和打包文件没有关系, 因为启动wds会打包编译放入内存</p></blockquote></li><li><p> <strong>contentBase:</strong> 代表 <a href="http://localhost:3000/">http://localhost:3000/</a>   的资源请求路径, 默认请求路径是文件夹的根目录,  如果contentBase 设置为./dist,那么 <a href="http://localhost:3000/">http://localhost:3000/</a>  代表根目录下的dist目录,  注意这时请求的静态资源(图片..) 相对路径 是在dist目录下解析的</p></li><li><p><strong>资源加载:</strong></p></li><li><p>在 webpack 5 提供 资源模块类型 asset , 默认情况下，<code>asset/resource</code> 模块以 <code>[hash][ext][query]</code> 文件名发送到输出目录。可以通过在 webpack 配置中设置 <a href="https://webpack.docschina.org/configuration/output/#outputassetmodulefilename"><code>output.assetModuleFilename</code></a> 来修改此模板字符串. <code>Rule.generator.filename</code> 与 <a href="https://webpack.docschina.org/configuration/output/#outputassetmodulefilename"><code>output.assetModuleFilename</code></a> 相同，并且仅适用于 <code>asset</code> 和 <code>asset/resource</code> 模块类型。</p></li><li><p><strong>自动管理输出</strong> : </p></li><li><blockquote><p>HtmlWebpackPlugin  , html-webpack-插件将自动将所有必要的CSS、JS、清单和 favicon 文件注入到标记中</p></blockquote></li><li><p><strong>清理/dist 输出路径的文件夹</strong>,: <a href="https://www.npmjs.com/package/clean-webpack-plugin"><code>clean-webpack-plugin</code></a></p></li><li><p>源代码映射: 追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置 ,使用 <a href="http://blog.teamtreehouse.com/introduction-source-maps">source maps</a> 功能</p></li><li><p><strong>webpack-dashboard 插件</strong>可以使 控制台中打印的打包有关的信息以列表的形式提供,作为插件添加到webpack配置中,使用webpack-dashboard 模块命令替换原来的webpack启动方式即可</p></li><li><blockquote><p>speed-measure-webpack-plugin 可以分析出构建过程的时间, 可以找出构建过程中那个步骤最慢</p><p>size-plugin 每次打包后的体积和上次的体积变化值</p></blockquote></li></ul><ul><li><p><strong>热加载HMR</strong> :</p></li><li><p>模块热替换(<code>Hot Module Replacement</code>)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。</p></li><li><blockquote><p>不在进行刷新网页重新发送请求, HMR保留完全加载页面状态的前提下,只更新改动,不在进行刷新</p><p>原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。</p></blockquote></li><li><p><strong>引入HMR:</strong></p></li><li><blockquote><p>自动引入HMR : 设置devserve选项 ,  本质上给每个模块绑定了module.hot对象</p><p>手动引入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<br>   <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./print.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p><strong>模块热替换问题</strong> :    onclick事件处理函数可能会绑定在旧的函数上,必须手动重新渲染一遍, 有很多 loader（下面会提到一些）可以使得模块热替换变得更加容易。</p></li><li><p>借助于 <code>style-loader</code>，使用模块热替换来加载 CSS 实际上极其简单。此 loader 在幕后使用了 <code>module.hot.accept</code>，在 CSS 依赖模块更新之后，会将其 patch(修补) 到 <code>&lt;style&gt;</code> 标签中。</p></li><li><p>社区还提供许多其他 loader 和示例，可以使 HMR 与各种框架和库平滑地进行交互…… ,比如 vue-loader</p></li></ul><h4 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h4><ul><li><p>在生产环境下,我们希望样式存在于单独的css文件中, 而不是style标签内, 因为文件更有利于客户端缓存,  这时我们使用 mini-css-extract-plugin</p></li><li><blockquote><p> 多样式提取:</p><p>样式的提取是以资源入口开始的整个chunk单位的封装, 如果index.js引入很多的模块,每个模块引入各自的样式, 但是最终只会生成一个css文件,因为只有一个入口, 当有多个入口时,生成多个css文件,但是名字会重复,所以要使用[name].css 进行动态命名</p></blockquote></li><li><blockquote><p>pligins 设置中,处理可以指定同步加载的css文件 filename  也可以指定异步加载的css资源 chunkfileName</p><p>filename是主入口的文件名，chunkFilename是非主入口的文件名</p><p>主入口 : 指的是<code>entry</code>里面生成出来的文件名</p><p>非主入口  :指的是按需加载（异步）模块,在entry没有名字</p><p>在打包时,同步加载的会被打包成一个 称为 initial chunk    默认main</p><p>异步 按需加载的会被打包为另一个包 称为 :non-initial chunk,默认使用唯一 ID 来替代名称</p></blockquote><ul><li><p>在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组, <em>一个 chunk 组中可能有多个 chunk。例如，</em><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> <em>会将一个 chunk 拆分为一个或多个 chunk。</em></p></li><li><blockquote><p>想要在浏览器中查看css源码 需要给css-loader  scss-loader 单独配置source map选项</p></blockquote></li></ul></li></ul><h4 id="代码分离-分片"><a href="#代码分离-分片" class="headerlink" title="代码分离(分片):"></a>代码分离(分片):</h4><ul><li> 能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</li></ul><p>常用的代码分离方法有三种：</p><ul><li><blockquote><p>通过入口起点：entry 配置 ,手动地分离代码。  通过entry 配置生成多个入口文件,每个页面只加载对应的bundle</p><p>使用插件：使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 去重和分离 chunk。</p><p>动态导入：通过模块的内联函数调用来分离代码</p></blockquote></li><li><p>通过入口起点手动设置的坏处: </p></li><li><blockquote><p>如果入口 chunk 之间包含一些重复的模块(都引入了一个库)，那些重复模块都会被引入到各个 bundle 中。</p><p>如果将公共模块拆分出来为一个bundle,都加载这个公共模块,(如果只需要公共模块的一部分,手动拆分更麻烦) 但是并不是所有的页面都需要公共模块,还是需要手工配置</p><p>这变得十分复杂,不能动态地将核心应用程序逻辑中的代码拆分出来。 所以我们利用插件解决这个问题</p></blockquote></li><li><blockquote><p>提取公共模块的另一种方法:  该方法可以防止在入口chunk引入重复第三方库</p><p>配置 <a href="https://webpack.docschina.org/configuration/entry-context/#dependencies"><code>dependOn</code> option</a> 选项，这样可以在多个 chunk 之间共享模块。这个 chunk 就不会包含 <code>dependOn配置中</code> 的模块了</p></blockquote></li><li><p>通过插件进行代码切片 : </p></li><li><blockquote><p>公共模块提取的收益 :  开发过程少了重复模块的打包, 提升开发速度, 减少整体体积  合理分片之后更有效利用客户端缓存</p></blockquote></li><li><p>webpack4 之前的插件CommonsChunkPlugin ,  可以通过配置name /filename提取公共模块(第三方库 ..)</p></li><li><blockquote><p>chunks 配置项: 规定从哪些入口提取公共模块</p><p>通过minChunks , 设置提取规则    minChunks:3 被引用三次才提取 ,还可以传入函数</p></blockquote></li><li><blockquote><p>在使用该插件时, 绕不开的问题是 hash 和长效缓存</p><p>提取后的公共模块代码,往往包含 webapck runtime 初始化环境的代码, 导致每次打包就算内容没有改变, 也会影响chunk hash的变化,而我们使用 chunk hash 作为资源的版本号优化客户端的缓存,这导致用户频繁的更新资源</p><p>解决方法:</p><p>把runtime 的代码提取出来 , 通过在提取完公共模块后, 再调用该插件提取一次</p><p>或者 可使用 <a href="https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 <code>single</code> 来为所有 chunk 创建一个 runtime bundle</p><p>这叫做<strong>提取引导模板</strong></p></blockquote></li><li><blockquote><p>一个CommonsChunkPlugin 只能提取一个vendor, 异步加载出现错误, 提取runtime 的代码导致浏览器多加载资源</p><p>现在使用 optimization.SplitChunks 代替</p></blockquote></li><li><p><strong>optimization.SplitChunks</strong> </p></li><li><blockquote><p>默认情况下的自动提取条件:</p><p>被多次引用的 / 在node_modules 的被提取</p><p>提取出来的体积chunk体积 大于 20kg</p><p>按需加载(动态插入script便签) 并行请求数量小于等于30</p><p>首次加载时请求数量小于等于30</p></blockquote></li><li><blockquote><p>参数解释:</p><p>chunks :   =&gt; SplitChunks 默认针对异步资源生效, async(默认值)  initial: 只对入口chunk生效, all:对所有的</p><p>minChunks : 公共模块被共享的最底次数</p><p>cacahGroups :  分离chunks时的规则  一般有vendors 和default两种   vendors 代表在 node_module的区块</p><p>default : 代表多次被引用的区块</p></blockquote></li><li><p>资源异步加载问题</p></li><li><blockquote><p>页面初次渲染时为了下载的资源尽可能的小. 我们可以把一些资源延迟加载,不让其堵塞</p><p>通过使用import() 来延迟加载, 延迟加载的属于间接资源, 通过设置out.publicPath, 来设置获取资源的路径</p><p>import() 实现原理就是动态生成script插入文档</p></blockquote></li><li><p>异步资源的chunk ,资源生成名字默认为数字 id, 我们可以通过特有注释来获取异步资源 chunk的name</p></li><li><blockquote><p>import(/<em>webpackChunkName :”bar”</em>/  ‘./bar.js’) output”{ chunkFilename: [name].js }</p></blockquote></li></ul><h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><ul><li><p><em>development(开发环境)</em> 和 <em>production(生产环境)</em> 这两个环境下的构建目标存在着巨大差异。</p></li><li><blockquote><p>在<em>开发环境</em>中，我们需要：强大的 source map 和”wds”以及热替换。</p><p><em>生产环境</em>目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化(让用户更快加载资源,最大限度利用缓存, 资源的压缩)，</p><p>通过这些优化方式改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>。</p><p>也可以使用同一个配置文件,不过要在webpack.config.js文件内添加判断条件来使用那个配置</p></blockquote></li><li><p>编写<strong>彼此独立的 webpack 配置</strong> : 使用一个名为 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a> 的工具,此工具会引用 “common” 配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。</p></li></ul><ul><li><p>开发环境和生产环境通常需要添加不同的<strong>环境变量</strong> ,使用DefinePlugin 设置</p></li><li><blockquote><p>通过添加mode:”production” , 自动会进行设置, 不再人工进行添加</p></blockquote></li><li><p><strong>source map 配置</strong></p></li><li><p>对于 js文件添加devtool 配置即可,对于css less scss来说,需要添加额外的source map选项</p></li><li><blockquote><p>开发环境下 cheap-moudle-eval-source-map 通常是一个不错的选择</p><p>生产环境下  只有三种可供选择, 三种在安全性上各不相同 nosources-source-map 可以</p></blockquote></li><li><p><strong>资源压缩 (uglify)</strong> ,意思是移除多余空格, 换行 和不执行的代码, 缩短变量名.. 使代码形式变得更短, 压缩之后的代码基本上不可读</p></li><li><blockquote><p><strong>压缩JavaScript</strong> : webpack4之后默认 使用了terser 的插件 terser-webpack-plugin, 可以在optimization 中的minisize:true, 设置开启,   minimizer选项则可以自定义 terser插件的功能</p><p>如果mode : production  则会自动设置,不用再人为设置</p><p><strong>压缩 css:</strong> 通过mini-css-extract-plugin 将样式提取出来到单独文件, 再使用optimize-css-assets-webpack-plugin 进行压缩(本质上是使用 压缩器 cssnano)  </p><p>optimization.minimizer 配置项中提供一个/多个压缩工具,optimize-css-assets-webpack-plugin要在其中设置</p><p>现在使用 CssMinimizerWebpackPlugin 插件 ,他优化了上面的插件</p><p>如果要在开发中也运行它，则将 选项设置为 。<code>optimization.minimize``true</code>,不加的话仅在生产环境下压缩</p></blockquote></li><li><p>**缓存:**重复利用浏览器已经获取过的资源,合理的使用缓存是提升客户端性能的一个关键因素</p></li><li><blockquote><p>当开发者更新了bug,希望立即更新到用户的浏览器上,而不是使用客户端旧的缓存,最好的办法是改变资源的url,一个常用的办法时改变文件的名字 :</p><p>在每次打包时,对资源内容计算一次hash,作为版本号放在文件名中,每当代码更新,hash就会变化,改变文件名,迫使客户端重新下载更新过的代码(使用chunkhash 作为文件版本号)</p><p>每次更改完名字之后,html引入资源的路径就会改变,这时使用html-webpack-plugin自动化改变, 在该插件中还可以使用模板来指定html </p></blockquote></li><li><blockquote><p>为了使用缓存,我们经常将不变动的代码分离出来,但是注意在webpack 3以下,使用commonsChunkPlugin时,</p><p>会有vendor chunk hash变化的问题,原因是新的模块插入到公共模块之前,会导致模块的id发生变化,使用插件webpack-hashed-moudle-id-plugin 解决</p><p>webpack4之后id的生成发生变了,不在有这个问题 ,如果有问题参考<code>optimization.moduleIds</code>配置项</p></blockquote></li><li><p><strong>bundle体积分析:</strong> </p></li><li><blockquote><p>vscode 中import Cost 插件帮助我们实时的对引入模块大小监测, 或使用 <a href="https://github.com/webpack/analyse">官方分析工具</a>   来保证输出资源不会超限之后被发布出去</p></blockquote></li></ul><h4 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h4><ul><li><p>让打包速度更快,资源输出体积更小 (对应官网的构建性能)</p></li><li><p>使用 <strong>happyPack</strong> 多线程进行打包(webpack本身是单线程的,只能一个一个的通过依赖关系查找进行转译),适用于转译任务比较重的项目效果明显,对于小项目来说并不明显</p></li><li><p>缩小打包作用域 : </p></li><li><blockquote><p> 使用include exclude </p><p>有些库不希望webpack 进行解析,即不应用任何的loader,但仍然会被打包进资源文件,可以使用 moudle中的noParse: /loadsh/ 指明模块名字</p><p>使用ignorePlugin ,他可以完全排除一些模块, 即使被引用也不会被打包, 对于排除一些库的相关文件非常有用,</p><p>一些库产生的额外资源我们用不到,但是引用语句在库文件内,我们也无法去掉,这时使用该插件不打包</p></blockquote></li><li><p>loader 中的cache 选项.可以在转译之后保存一份缓存,当源文件不变,直接使用缓存,但是他不能检测缓存是否过期(比如更新babel-loader的配置,由于源代码没有变换,打包后将会使用缓存,这是不合理的),官方后期会优化,</p></li><li><p>使用 DIIplugin插件,对一些不经常改变的公共(第三方)模块,进行预先打包,到工程部署时使用DiiReferencePlugin来索引打包好的文件, DIIplugin和 代码分离类似,但是前者会把整个模块拆出来,代码分离会根据规则拆分, 相应的前者需要单独一个配置文件</p></li><li><p><strong>Tree Shaking:</strong></p></li><li><p>通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。该特性依赖于es6 Moudlede 静态编译的特性,es6会在代码编译时确定依赖关系,可以检测出,没有引用过的模块(代码块),webpack进行标记,在开发环境下仍然可见, 在生产环境下<strong>资源压缩时</strong>将他们从最终的bundle去掉</p></li><li><p>tree Shaking 只对es6 module 有用, 对于通过commonjs 引用进来的没有用处</p></li><li><blockquote><p>在工程中使用 babel-loader ,那么一定要通过配置来禁用它的模块依赖解析,因为解析过之后,webpack接受的都是commonjs形式的模块, 在loader 中options:{presets:[@babel/preset-env,{moudle:false}]}</p></blockquote></li><li><p>tree shaking 本身只对死代码进行标记, 真正去除死代码的是在生产环境下资源压缩那一步</p></li><li><p>tress shaking 的自身优化:</p></li><li><blockquote><p>配置 optimization: { usedExports: true,}  , 告知 webpack 去决定每个模块使用的导出内容。在压缩工具中的无用代码清除会受益于该选项，而且能够去除未使用的导出内容。</p><p>但是有些内容虽然没有使用,但是去除之后可能会有副作用,<code>usedExports</code> 依赖于 <a href="https://github.com/terser-js/terser">terser</a> 去检测语句中的副作用,我们可以通过 <code>/*#__PURE__*/</code> 注释来帮忙 terser。它给一个语句标记为没有副作用</p><p>所以使用**<code>sideEffects</code> 更为有效** 是因为它允许跳过整个模块/文件和整个文件子树,它类似于 <code>/*#__PURE__*/</code> 但是作用于模块的层面，而不是代码语句的层面。</p></blockquote></li><li><p><strong><code>sideEffects</code> 更为有效</strong></p></li><li><blockquote><p>如果所有代码都不包含 side effect，我们就可以简单地将该属性标记为 false<br>如果你的代码确实有一些副作用，可以改为提供一个数组,<br>“sideEffects”: [</p><pre><code>&quot;./src/some-side-effectful-file.js&quot;</code></pre><p>  ]  </p><p>还可以在 <code>module.rules</code> 配置选项中设置 <code>&quot;sideEffects&quot;</code>。</p></blockquote></li><li><blockquote><p>所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似<code>css-loader</code> 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除</p></blockquote></li><li><blockquote><p>在使用 tree shaking 时必须有 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a> 的支持，您可以通过设置配置项 <code>mode: &quot;production&quot;</code> 以启用它。如果您没有如此做，请记得手动引入 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a>。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/vue/"/>
    <url>/2020/12/14/Js-dom/vue/</url>
    
    <content type="html"><![CDATA[<h2 id="VUE一遍"><a href="#VUE一遍" class="headerlink" title="VUE一遍"></a>VUE一遍</h2><h4 id="vue的核心思想是什么"><a href="#vue的核心思想是什么" class="headerlink" title="vue的核心思想是什么"></a>vue的核心思想是什么</h4><ul><li>构建用户界面的渐进式框架  设计为可以<strong>自底向上逐层应用</strong>(—-串联线)  只关注视图层 提供MVVM数据双向绑定的库 其核心思想包括数据驱动，组件化思想</li><li><blockquote><p>渐进式  :  vue每个功能是独立的,你可以只用其中一种  </p></blockquote></li><li><blockquote><p>Vue的体系从内到外依次是声明式渲染(Declarative Rendering)、组件系统(Component System)、客户端路由(Client-side Routing)、大规模状态管理(Large Scale State Management)、构建系统(Build System)。 </p></blockquote></li><li><blockquote><p>MVVM  数据(Model)和视图(View)是不能直接通讯的，而是需要通过ViewModel来实现双方的通讯 (Viewmodel:就是连接视图与数据的中间件)</p></blockquote></li><li><blockquote><p>组件化思想:  把复杂逻辑分为多个组件处理, 所以本质上,我们是要写各个组件, 各个组件之间的通讯,渲染..</p></blockquote></li></ul><h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><ul><li>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</li><li></li></ul><h3 id="第一层-声明式渲染"><a href="#第一层-声明式渲染" class="headerlink" title="第一层:声明式渲染"></a>第一层:声明式渲染</h3><ul><li><h4 id="声明式地将数据渲染进-DOM-的系统"><a href="#声明式地将数据渲染进-DOM-的系统" class="headerlink" title="声明式地将数据渲染进 DOM 的系统:"></a>声明式地将数据渲染进 DOM 的系统:</h4></li></ul><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><ul><li><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p></li><li><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 可以不用模板，<a href="https://cn.vuejs.org/v2/guide/render-function.html">直接写渲染 render函数</a>，使用可选的 JSX 语法也是可以的</p></li></ul><p><strong>渲染数据</strong></p><ul><li><p><strong>文本</strong>   </p></li><li><blockquote><p>通过双括号插值</p></blockquote></li><li><blockquote><p>v-once 进行一次性插值, 后续改变不在变化</p></blockquote></li><li><p><strong>原始 HTML</strong>   双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html</p></li><li><blockquote><p>会直接渲染被标签处理过的文本内容,而不是连同标签一起输出</p></blockquote></li><li><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p></blockquote></li><li><p> <strong>attribute</strong>  作用在 HTML attribute 上，遇到这种情况应该使用 v-bind</p></li><li><blockquote><p>对于布尔 attribute 如果是null<code>、</code>undefined<code>或</code>false,那个该特性就不会渲染出来</p></blockquote></li><li><p>vue 提供了 JavaScript 表达式支持,可以在大括号中写表达式, 有个限制是只能包含<strong>单个表达式</strong></p></li><li><blockquote><p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。</p><p>你不应该在模板表达式中试图访问用户定义的全局变量</p></blockquote></li></ul><p><strong>指令</strong></p><ul><li><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute, 指令的职责是，当表达式的值改变时，将响应式地作用于 DOM</p></li><li><p><code>v-if</code> 指令将根据表达式 的值的真假来插入/移除 DOM元素</p></li><li><p><code>v-bind</code> 指令可以用于响应式地更新 HTML attribute, </p></li><li><p><code>v-on</code> 指令，它用于监听 DOM 事件,绑定事件参数</p></li><li><blockquote><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如:</p><a v-bind:href="url"> </blockquote></li><li><p>当使用v-bind 绑定 attribute 的时,将不再是静态字符串,而是一个JavaScript表达式</p></li><li><pre><code>&lt; p v-bind:value=&quot;a&quot;&gt; &lt;/p&gt; //这时 a 是一个 JavaScript 表达式而不是一个字符串.如果是字母 将会被解析成表达式,必须在vue定义数字      表达式进行计算,返回一个数字作为绑定的值<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- 动态参数:</span> 从 <span class="hljs-number">2.6</span>.<span class="hljs-number">0</span> 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数, 表达式将进行动态求值<br>  <br><span class="hljs-title">- 动态参数事项:</span><br>  <br>- &gt; 动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。<br>  &gt;<br>  &gt; <br>  &gt;<br><span class="hljs-title">  &gt; 动态参数表达式有一些语法约束:</span><br>  &gt;<br>  &gt; 因为某些字符，如空格和引号,放在 HTML attribute 名里是无效  <br>  &gt;<br>  &gt; 大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写<br>  <br><br><span class="hljs-title"> **修饰符** :</span> 用于指出一个指令应该以特殊方式绑定<br><br>- ```html<br><span class="hljs-title">  &lt;form v-on:</span>submit.prevent=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;...&lt;/form&gt; <br>  //.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：<br></code></pre></td></tr></table></figure></code></pre></li></ul><p> <strong>缩写:</strong></p><ul><li><blockquote><p>v-bind 缩写   =&gt; “:”  </p><p>  v-on 缩写 =&gt; “@”</p></blockquote></li></ul><h5 id="v-bind-绑定class-style"><a href="#v-bind-绑定class-style" class="headerlink" title="v-bind 绑定class style"></a>v-bind 绑定class style</h5><ul><li>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</li></ul><p><strong>绑定class基本语法:</strong></p><p>​        <strong>对象语法:</strong> 可以动态地切换 class</p><ul><li><pre><code class="html">1.把class名字内联写在模板里,通过更改isActive的bool值决定,是否渲染active类&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;  2.把class名字外联写在data中的classObject对象里,通过在data中改变 bool值渲染类名&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123;  classObject: &#123;    active: true,    &#39;text-danger&#39;: false  &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <br>    **数组语法:** 应用一个 <span class="hljs-class"><span class="hljs-keyword">class</span> 列表</span><br>    <br>- ```html<br>  &lt;div v-bind:<span class="hljs-class"><span class="hljs-keyword">class</span>=&quot;[<span class="hljs-title">activeClass</span>, <span class="hljs-type">errorClass]&quot;&gt;</span>&lt;<span class="hljs-type">/div</span>&gt;</span><br>  <span class="hljs-keyword">data</span>: &#123;<br>    activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,<br>    errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>在数组语法中也可以使用对象语法</strong>:</p></li><li><pre><code class="html">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>**绑定在自定义组件上**:<br><br>- &gt; 当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的**根元素**上面。<br>  &gt;<br>  &gt; 这个元素上已经存在的 class 不会被覆盖。<br><br>  ------<br><br>  <br><br>**绑定style基本语法:**<br><br>**对象语法:**<br><br>​      内联式:<br><br>- `v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。<br><br>- ```html<br>  <br>  &lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br>  CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名<br></code></pre></td></tr></table></figure>外联式:</code></pre></li><li><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p></li><li><pre><code class="html">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123;  styleObject: &#123;    color: &#39;red&#39;,    fontSize: &#39;13px&#39;  &#125;&#125;<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><br><span class="hljs-comment">**数组语法:**数组语法可以将多个样式对象应用到同一个元素上</span><br><br>- ```html<br>  &lt;<span class="hljs-built_in">div</span> v-bind:style=<span class="hljs-string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;&lt;/<span class="hljs-built_in">div</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>自动添加前缀:</strong></p><ul><li><blockquote><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀</p></blockquote></li></ul><p><strong>多重值:</strong></p><ul><li><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值,这样写只会渲染数组中最后一个被浏览器支持的值</p></li><li><pre><code class="html">&lt;div :style=&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;/div&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>##### v-if /v-show条件渲染<br><br>**v-if条件渲染:**<br><br>- 条件渲染一块内容:<br><br>- ```html<br>  &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>可以添加<code>v-else</code> 添加一个“else 块” : 还可以添加 v-else-if块</p><p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p></blockquote></li><li><p>条件渲染多个元素:   </p></li><li><pre><code class="html">在 &lt;template&gt; 元素上使用 v-if 条件渲染分组:&lt;template v-if=&quot;ok&quot;&gt;  &lt;h1&gt;Title&lt;/h1&gt;  &lt;p&gt;Paragraph 1&lt;/p&gt;  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">**用 key 管理可复用的元素:</span>**<br><br>  - Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染. <br><br>  - &gt; 即两个相同的标签,不会渲染第二个,而是复用第一个,<br>    &gt;<br>    &gt; 把标签内的值进行更换, 但是特殊情况 input 输入内容,会被复用而不是清空<br>    &gt;<br>    &gt; 因此,我们使用key 方式,表达“这两个元素是完全独立的，不要复用它们”<br><br>-  只需添加一个具有唯一值的 `key` attribute 即可<br><br>- &gt;  &lt;input placeholder=<span class="hljs-string">&quot;Enter your email address&quot;</span> key=<span class="hljs-string">&quot;email-input&quot;</span>&gt;<br><br><span class="hljs-title">**v-show条件渲染:</span>**<br><br>- `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。<br><br>- &gt; 注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。<br><br><span class="hljs-title">- **v-show v-if的区别:</span>** <br><br>- &gt; v-if  是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>  &gt;<br>  &gt; 也是**惰性的**：直到条件第一次变为真时，才会开始渲染条件块。<br>  &gt;<br>  &gt; `v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换<br>- &gt; 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。<br>  &gt;<br>  &gt; 因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。<br><br>  <br><br>##### v-for列表渲染<br><br><span class="hljs-title">- 用 `v-for` 指令基于一个数组来渲染一个列表:</span><br><br>- ```html<br>  &lt;li v-for=<span class="hljs-string">&quot;item in items&quot;</span> &gt;   items 是源数据数组，而 item 则是被迭代的数组元素的别名<br>  &lt;li v-for=<span class="hljs-string">&quot;(item, index) in items&quot;</span>&gt;      支持一个可选的第二个参数，即当前项的索引。<span class="hljs-number">0</span>开始   of可以代替in<br></code></pre></td></tr></table></figure></code></pre></li><li><p>用 <code>v-for</code> 来遍历一个对象的 property</p></li><li><pre><code class="html">&lt;li v-for=&quot;value in object&quot;&gt;   以此遍历对象的属性值&lt;li v-for=&quot;(value,name) in Object&quot;&gt;&lt;/li&gt;  遍历对象属性值 value 属性名 name&lt;div v-for=&quot;(value, name, index) in object&quot;&gt; 用第三个参数作为索引：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> &gt; 在遍历对象时，会按 <span class="hljs-code">`Object.keys()`</span> 的结果遍历，但是<span class="hljs-strong">**不能**</span>保证它的结果在不同的 JavaScript 引擎下都一致。<br><br><span class="hljs-strong">**列表渲染状态**</span><br><br><span class="hljs-bullet">-</span> 当 Vue 正在更新使用 <span class="hljs-code">`v-for`</span> 渲染的元素列表时，它默认使用“就地更新”的策略。<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-strong">**如果数据项的顺序被改变**</span>，Vue 将<span class="hljs-strong">**不会移动 DOM 元素**</span>来匹配数据项的顺序，而是就地更新每个元素.只会渲染数据,不会更改DOM元素<br><br><span class="hljs-bullet">-</span> 这个默认的模式是高效的，但是<span class="hljs-strong">**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**</span>。<br>  <br><span class="hljs-bullet">-</span> &gt; 但是并不总是高效的,为了更好的重用现有元素提高效率,要利用<span class="hljs-code">`key`</span> 让其能跟踪每个节点的身份.<br>  <br><span class="hljs-bullet">-</span> <span class="hljs-strong">**使用key 值的原因:**</span><br><br>  &gt; vue Dom 更新原理,通过Virtual DOM diff算法 ==&gt; 通过对比DOM中的值,不一致进行更新值,直到没有数据.<br>  &gt;<br>  &gt; 例子 : 当把一条数据插入到很多数据的中间,那么它将会比对DOM中的数据是否一致,不一致,新的数据项将替换旧的数据项,一直渲染到没有数据,导致在中间插入一条数据,需要更新多个DOM的值,很没有效率.<br>  &gt;<br>  &gt; <br>  &gt;<br>  &gt; 通过添加 key 值, 我们以相同的key值为基准(相同的key之间进行对比),进行新旧DOM值比对,不一致进行值更新,没有的key值渲染新的DOM添加进来,这样大大提高了效率<br>  &gt;<br>  &gt; <br>  &gt;<br>  &gt; 所以一句话，key的作用主要是在新旧 nodes 对比时辨识 VNodes,更高效的更新虚拟DOM。<br>  &gt;<br>  &gt; 另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。<br><br><span class="hljs-bullet">-</span> key 值最好不要使用数组中的 index, 因为这会导致key变化,更新很多的dom数据,降低效率<br><br>  <br><br><span class="hljs-bullet">-</span> &gt; 不要使用对象或数组之类的非基本类型值作为 <span class="hljs-code">`v-for`</span> 的 <span class="hljs-code">`key`</span>。请用字符串或数值类型的值。<br><br><br><br><span class="hljs-strong">**列表源数据(数组)的方法:**</span><br><br><span class="hljs-bullet">-</span> Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br><br><span class="hljs-bullet">-</span> 更改数组(变更方法)<br><br><span class="hljs-bullet">-</span> &gt; push()      pop()<br>  &gt;<br>  &gt; shift()    unshift()<br>  &gt;<br>  &gt; splice()      sort()        reverse()  <br><br><span class="hljs-bullet">-</span> 替换数组:(非变更方法)<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">`filter()`</span>、<span class="hljs-code">`concat()`</span> 和 <span class="hljs-code">`slice()`</span>。它们不会变更原始数组，而<span class="hljs-strong">**总是返回一个新数组**</span> ,<br>  &gt;<br>  &gt; 这不会使Vue 丢弃现有 DOM 并重新渲染整个列表,Vue 为了使得 DOM 元素得到最大范围的重用使用了优化方法<br>  &gt;<br>  &gt; 所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。<br><br><span class="hljs-bullet">-</span> 由于 JavaScript 的限制，Vue <span class="hljs-strong">**不能检测**</span>数组和对象的变化<br><br><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**直接使用过滤/排序后的结果:**</span><br><br><span class="hljs-bullet">-</span> 我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。<br><br><span class="hljs-bullet">-</span> &gt; 解释: 不再进行把原数据替换/重置后,更新视图. 而是直接使用处理过的数组显示视图. 这样省去了更新dom的麻烦<br><br><span class="hljs-bullet">-</span> 在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。使用这个数组进行渲染<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```html</span><br><span class="hljs-code">  &lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="hljs-code">  computed: &#123;</span><br><span class="hljs-code">    evenNumbers: function () &#123;返回处理后的数组&#125;</span><br><span class="hljs-code">    &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个方法</p></li><li><blockquote><p>待拓展</p></blockquote></li></ul><ul><li><p><strong>在 v-for 里使用值</strong> : </p></li><li><pre><code class="html"> `v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt; //输出 1 2 3..10<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>- **v-for重复渲染多个元素:**<br><br>- &gt; 可以利用带有 `v-for` 的 `&lt;template&gt;` 来循环渲染一段包含多个元素的内容<br><br>- **使用 `v-if` 和 `v-for`:**<br><br>- &gt; 当它们处于**同一节点**，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中<br>  &gt;<br>  &gt; 如果你的目的是有条件地跳过循环的执行，那么可以将 `v-if` 置于外层元素 <br>  <br>  **在组件上使用 v-for:**<br>  <br>- &gt; 在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。<br>   &gt;<br>   &gt; 2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。<br><br><br><br><br>##### v-on处理事件<br><br>**监听事件:** <br><br>- 内联式:<br><br>- ```html<br>  1.直接传入js代码段<br>  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;<br><span class="hljs-attribute">2.直接调用一个方法</span><br>   &lt;button v-on:click=&quot;say(&#x27;hi&#x27;)&quot;&gt;Say hi&lt;/button&gt;<br>     用特殊变量 `$event` 把它传入方法,可以访问原始的DOM事件<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>外联式</p></li><li><pre><code class="html"> 1.传递一个方法 methods &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt; <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>  **事件修饰符:**<br><br>- 方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**<br><br>- &gt; .stop 停止冒泡<br>  &gt;<br>  &gt; .prevent  阻止默认事件<br>  &gt;<br>  &gt; .capture  捕获模式<br>  &gt;<br>  &gt; .self  只当在 event.target 是当前元素自身时触发处理函数<br>  &gt;<br>  &gt; .once  只会触发一次<br>  &gt;<br>  &gt; &gt; 不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的**组件事件**上<br>  &gt;<br>  &gt; .passive  会告诉浏览器你**不**想阻止事件的默认行为。<br>  &gt;<br>  &gt; &gt; 不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告<br><br>  <br><br>  **按键/系统修饰符:**<br>  <br>- Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：只在满足修饰符的情况下执行事件<br><br>- ```html<br>  &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;<br>  &lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>按键码:  <code>keyCode</code> 的事件用法<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">已经被废弃了</a>并可能不会被最新的浏览器支持。但使用 <code>keyCode</code> attribute 也是允许的：</p></li><li><pre><code>&lt;input v-on:keyup.13=&quot;submit&quot;&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>- &gt; 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：<br>  &gt;<br>  &gt; .enter  .tab  .delete  (捕获“删除”和“退格”键)   .esc    .space  .up  .down    .left   .right<br>  &gt;<br>  &gt; 你还可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](https://cn.vuejs.org/v2/api/#keyCodes)：<br>&gt;<br>  &gt; Vue.config.keyCodes.f1 = 112<br><br>  <br><br>- 系统修饰符 : `.ctrl .alt .shift .meta`   仅在按下相应按键时才触发鼠标或键盘事件的监听器<br><br>- ```html<br>  &lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; &lt;!-- Ctrl + Click --&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><blockquote><p>请注意<strong>修饰键与常规按键不同</strong>，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态然后释放另一个按键。</p></blockquote></li></ul><ul><li><p><strong><code>.exact</code> 修饰符: **允许你控制由</strong>精确的**系统修饰符组合触发的事件。</p></li><li><pre><code class="html">&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">-  **鼠标按钮修饰符:</span> ** `.left` `.right` `.middle` 仅响应特定的鼠标按钮<br><br><br><br>##### v-model处理表单输入<br><br>- `v-model` 指令在表单 `&lt;input&gt;`、`&lt;textarea&gt;` 及 `&lt;select&gt;` 元素上创建双向数据绑定。<br><br>- &gt; `v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源<br><br><span class="hljs-title">- **各个类型的表单基本用法:</span>**<br><br><span class="hljs-title">- &gt; 1.文本/多行文本  input  textarea   数据使用字符串 例如:</span><br>  &gt;<br>  &gt; ```html<br>  &gt; &lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> placeholder=<span class="hljs-string">&quot;edit me&quot;</span>&gt;<br><span class="hljs-title">  &gt; &lt;p&gt;Message is:</span> &#123;&#123; message &#125;&#125;&lt;/p&gt;<br><span class="hljs-title">  &gt;  vue 绑定数据 message:</span><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>&gt;&gt; 2.复选框 type=&quot;checkbox&quot;    单个复选框 : 数据使用字符串   多个复选框: 数据使用数组&gt;&gt; <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">单个复选框:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>  // checked:&quot;&quot;,数据是字符串, 默认会显示ture false<br>多个单选框:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>&#123;&#123;checkedNames&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br><br>// checkedNames:[],数据是数组, 使用value 属性进行显示<br></code></pre></td></tr></table></figure>&gt;&gt; 数据使用数组,复选框没有value 值 ,那么数组中显示null,  有value值显示value&gt;&gt; 数据使用字符串, 复选框没有value 值, 显示ture/false 并且会造成全选.&gt;&gt; &gt;&gt; 3.单选框  type=&quot;radio&quot;  &gt;&gt; <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;One&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;picked&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>&gt;&gt; 数据使用字符串,必须有value值才会显示,没有value值会造成全选,还不会显示值&gt;&gt; 数据使用数组, 有value值的话也可以,也只会显示单个value值,没有value值会造成全选,不显示值&gt;&gt; 想让radio 单选框默认被选中,必须是数据和 value值相同, radio不存在 true/false值, 它只使用value &gt;&gt; &gt;&gt; 4.选择框   &lt;select&gt;  数据可以是数组/字符串,有value显示value值,没有value值显示option中的值,但是都只显示一个值&gt;&gt; **表单的值(value)绑定:**</code></pre></li><li><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串,这里指的是表单的value属性值,我们可以使用<code>v-bind</code> 绑定value 属性到一个动态值上.</p></li><li><pre><code class="html">&lt;select v-model=&quot;selected&quot;&gt;  &lt;option v-bind:value=&quot;number&quot;&gt;123&lt;/option&gt;&lt;/select&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">  **修饰符:</span>**<br><br><span class="hljs-title">- **.lazy** :</span>  在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步, 使用 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步, <br><br>- ```html<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model.lazy=<span class="hljs-string">&quot;msg&quot;</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>.number</strong> : 如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符</p></li><li><blockquote><p>因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p></blockquote></li><li><p><strong>.trim</strong> :  如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p></li><li><blockquote><p>对于需要使用输入法的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。</p><p>在文本区域插值 (<code>&lt;textarea&gt;&#123;&#123;text&#125;&#125;&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p></blockquote></li></ul><p><strong>v-model实现原理:</strong></p><ul><li><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p></li><li><blockquote><p>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</p><p>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</p><p>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</p></blockquote></li></ul><ul><li><p>v-model 只不过是一个语法糖而已 </p></li><li><pre><code class="html">&lt;input v-model=&quot;searchText&quot;&gt;  等价于=&gt;&lt;input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event.target.value&quot;&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- **自定义组件上使用v-model**<br><br>- &gt; 1.需要定义 绑定value属性一个动态值<br>  &gt;<br>  &gt; 2.需要在组件模板内$emit 触发input事件,并抛出一个值给父组件<br><br>- ```vue<br>  Vue.component(&#x27;custom-input&#x27;, &#123;<br>    props: [&#x27;value&#x27;],<br>    template: `<br>      &lt;input<br>        v-bind:value=&quot;value&quot;             <br>        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;<br>      &gt;<br>    `<br>  &#125;)<br>  这样父组件就可以使用 v-model 了<br>  <br>  &lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;<br>  相当于=&gt;<br>  &lt;custom-input<br>    v-bind:value=&quot;searchText&quot;<br>    v-on:input=&quot;searchText = $event&quot;<br>  &gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突</p></li><li><blockquote><p>首先解释下默认利用 value input的问题 : 在html正常使用 v-model,它会根据type,选择不同的属性 和事件进行处理,这点可以参考上面的原理部分,   </p><p>在 自定义组件内,就算使用 type=”checkbox”, 它也会默认使用value  input事件(绑定别的事件/属性没有用), 会影响选框类组件的 value属性,导致提交时的问题.</p><p>所以我们使用 <code>model</code> 解决这样的问题,这样我们可以自定义value值进行其他目的</p></blockquote></li><li><pre><code class="js"> Vue.component(&#39;base-checkbox&#39;, &#123;  model: &#123;    prop: &#39;checked&#39;,    event: &#39;change&#39;  &#125;,  ...  props;&#123;  checked:Boolen,  &#125;  &#125;  //注意使用model 选项,仍然需要在props 里声明这个 checked<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>  <br><br><br><br>##### 计算属性和监听器<br><br>- 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,所以，对于任何复杂逻辑，你都应当使用**计算属性**.    computed: &#123; reverMessage:function()&#123;&#125;&#125;<br><br>- 计算属性 vs方法<br><br>- &gt; 我们可以将同一函数定义为一个方法而不是一个计算属性,两种方式的最终结果确实是完全相同的。然而，不同的是**计算属性是基于它们的响应式依赖进行缓存的**。<br>  &gt;<br>  &gt; 也就是说 计算属性中函数不发生更新, 就**只返回缓存**不在进行执行函数<br><br>- 如果你不希望有缓存，请用方法来替代。(双大括号中也可以放置方法的)<br><br>- 计算属性 v s侦听属性<br><br>- &gt; Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**: watch, <br>  &gt;<br>  &gt; 通常更好的做法是使用计算属性而不是命令式的 `watch` 回调<br><br>- 计算属性的setter<br><br>- &gt; 计算属性默认只有 getter(通常返回一个值)，不过在需要时你也可以提供一个 setter<br><br>**侦听器 watch:**<br><br>- 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器,<br><br>- &gt; 当需要在**数据变化时**执行**异步或开销较大**的操作时，这个方式是最有用的。除了 `watch` 选项之外，您还可以使用命令式的 [vm.$watch API](https://cn.vuejs.org/v2/api/#vm-watch)。  (开销较大的操作不应该是 使用计算属性吗??)<br><br>- watch 中的选项含义 `deep` `immediate`<br><br>- &gt; deep : bool  告诉Vue使用递归方式侦听**嵌套对象内部值**的变化  (如果没有deep选项,想要侦听内部值必须手动设置),<br>  &gt;<br>  &gt; immediate :bool  侦听开始就调用函数,不在等到属性变化时再调用<br><br>### 第二层:组件系统<br><br>- #### Vue使用组件化进行开发<br><br>  <br><br>#### 组件基础<br><br>- **什么是组件 :** 组件是可复用的 Vue 实例，且带有一个名字<br><br>- &gt; 因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。<br>  &gt;<br>  &gt; 仅有的例外是像 `el` 这样根实例特有的选项。<br><br>  <br><br>- **组件的复用:** 每个组件都会各自独立维护它的数据, 可以进行任意次复用, 原因:<br><br>- &gt; **一个组件的 `data` 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立的拷贝, 如果 Vue 没有这条规则,那么data属性将被共享, 无法进行复用<br><br>- &gt; `data` 选项返回的数据,作用域只在**组件内 模板中**, 而不能作用在自定义组件上(指自定义标签)<br><br>  <br><br>- **组件名:**<br><br>- &gt;两种命名方法:   推荐使用连字符的写法,因为直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>  &gt;<br>  &gt;**字母全小写且必须包含一个连字符**, ( kebab-case)<br>  &gt;<br>  &gt;使用 PascalCase (**首字母大写命名**)  驼峰命名<br>  <br>  <br><br>- **每个组件模板内必须只有一个根元素**, <br><br><br><br>- **组件注册**: <br><br>- *全局注册*:<br><br>- ```js<br>  Vue.component(&#x27;my-component-name&#x27;, &#123;<br>    // ... options ...<br>  &#125;)<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>全局注册的组件可以用在其被注册之后的任何 新创建的 Vue 根实例(通过 new Vue)模板中，也可以用在子组件中</p><p>例如: 全局注册三个组件, 三个组件可以在各自内部中相互使用</p></blockquote></li><li><p>全局注册往往是不够理想的。如果使用webpack构建系统,全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中</p></li><li><p><em>局部注册:</em></p></li><li><pre><code class="js">//1.通过普通对象 来定义组件:var ComponentA = &#123; /* ... */ &#125;//2.然后在 components 选项中定义你想要使用的组件：new Vue(&#123;  el: &#39;#app&#39;,  components: &#123;    &#39;component-a&#39;: ComponentA,  //属性名是自定义便签名  &#125;&#125;)//如果需要子组件之间使用:var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123;  components: &#123;    &#39;component-a&#39;: ComponentA  &#125;,  // ...&#125;<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>- **模块系统下的组件注册注意事项:**<br><br>- 如果使用 es2015+ 模块系统,子组件局部注册<br><br>- ```<span class="javascript">javascript</span><br><span class="javascript">  <span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA&#x27;</span></span><br><span class="javascript">  <span class="hljs-keyword">import</span> ComponentC <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentC&#x27;</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    components: &#123;</span><br><span class="javascript">      ComponentA,   <span class="hljs-comment">//同时代表 自定义标签名</span></span><br><span class="javascript">      ComponentC</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-comment">// ...</span></span><br><span class="javascript">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>对于一些频繁用到的<strong>基础组件</strong>,我们往往会进行全局注册, 如果你使用webpack/vue cli 构建系统,那么就可以使用 <code>require.context</code> <strong>一次性,自动化全局注册</strong>这些基础组件</p></li><li><blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C">基础组件的自动化全局注册</a>  代码参考</li></ul></blockquote></li></ul><h4 id="组件间的数据-内容传递"><a href="#组件间的数据-内容传递" class="headerlink" title="组件间的数据/内容传递"></a>组件间的数据/内容传递</h4><h5 id="父子组件之间传递数据"><a href="#父子组件之间传递数据" class="headerlink" title="父子组件之间传递数据"></a><strong>父子组件之间传递数据</strong></h5><ul><li><p><em>父组件通过 <code>prop </code>向子组件传递数据:</em></p></li><li><p>*<em>什么是Prop:  **Prop 是你可以在组件上注册的一些</em>自定义 attribute*。(渲染时并不会被渲染成 html attribute)</p></li><li><blockquote><p>当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 <strong>property</strong>。变成了一个 <strong>property</strong>说明传递的数据不会被渲染成 html attribute ,而是在实例中使用的属性.</p><p>这个值可以是静态字符串,也可以是v-bind 绑定的动态值</p><p>一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。</p></blockquote></li><li><blockquote><p>问题 : 改变这个 传递给prop的值 会引起外部数据的变化吗     不推荐 警告</p></blockquote></li></ul><ul><li>**prop命名:**HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</li><li><strong>prop类型:</strong> 字符串形式/ 对象形式</li></ul><ul><li><p> **prop注册: ** 给 prop 传入一个静态的值, 或者也可以使用 <code>v-bind</code> 来动态传递 prop。</p></li><li><pre><code class="html">//这里 prop 注册的是  props: [&#39;title&#39;]&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;  //静态值&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post  v-for=&quot;post in posts&quot;  v-bind:key=&quot;post.id&quot;  v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;                                   //动态值//通过 v-bind 的动态绑定,就算是静态字符串也会被解析成js表达式<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs stata">  <br>- 如果你想要将一个对象的所有 property 都作为 <span class="hljs-keyword">prop</span> 传入,可以使用`v-bind=<span class="hljs-string">&quot;post&quot;</span> `, 把整个<span class="hljs-keyword">post</span>对象传入<span class="hljs-keyword">prop</span><br><br>- **<span class="hljs-keyword">prop</span>单向数据流:** <br><br>- &gt; 所有的 <span class="hljs-keyword">prop</span> 都使得其父子 <span class="hljs-keyword">prop</span> 之间形成了一个**单向下行绑定** :父级 <span class="hljs-keyword">prop</span> 的更新会向下流动到子组件中,但是反过来则不行<br>  &gt;<br>  &gt; 每次父级组件发生变更时，子组件中所有的 <span class="hljs-keyword">prop</span> 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 <span class="hljs-keyword">prop</span>。<br><br>- 两种试图改变 <span class="hljs-keyword">prop</span>的情形 :<br><br>  &gt; 1. 子组件希望<span class="hljs-keyword">prop</span>当成本地的数据进行使用:  定义一个本地的 data 属性, 并将这个 <span class="hljs-keyword">prop</span> 用作其初始值：<br>  &gt; 2. <span class="hljs-keyword">prop</span> 传入后需要进行转换 :  定义一个计算属性,返回一个转换后的副本<br>  &gt;<br>  &gt; <br>  &gt;<br>  &gt; 注意js中数组/对象传递的是引用,所以在子组件中改变这个,会影响到父组件的状态<br><br><br><br>- **<span class="hljs-keyword">Prop</span> 验证:**<br><br>- 我们可以为组件的 <span class="hljs-keyword">prop</span> 指定验证要求, 为了定制 <span class="hljs-keyword">prop</span> 的验证方式，你可以为 `props` 中的值提供一个带有验证需求的对象，<br><br>- ```js<br>  Vue.component(&#x27;my-component&#x27;, &#123;<br>    props: &#123;<br>  <br>      <span class="hljs-comment">// 多个可能的类型</span><br>      propB: [String, Number],<br>      <br>      <span class="hljs-comment">// 必填的字符串</span><br>      propC: &#123;<br>        <span class="hljs-keyword">type</span>: String,<br>        required: true<br>      &#125;,<br>      <br>      <span class="hljs-comment">// 带有默认值的数字</span><br>      propD: &#123;<br>        <span class="hljs-keyword">type</span>: Number,<br>        default: 100<br>      &#125;,<br>      <br>      <span class="hljs-comment">// 带有默认值的对象</span><br>      propE: &#123;<br>        <span class="hljs-keyword">type</span>: Object,<br>        <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br>        default: function () &#123;<br>          <span class="hljs-keyword">return</span> &#123; message: &#x27;hello&#x27; &#125;<br>        &#125;<br>      &#125;,<br>      <br>      <span class="hljs-comment">// 自定义验证函数</span><br>      propF: &#123;<br>        validator: function (value) &#123;<br>          <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>          <span class="hljs-keyword">return</span> [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>注意那些 prop 会在一个<strong>组件实例创建之前进行验证</strong>，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p></blockquote></li></ul><ul><li><p><strong>非 prop 的 attribute:</strong>  </p></li><li><blockquote><p> attribute 传向一个组件，但是该组件并没有相应 prop 定义.</p><p> 这些 attribute 会被添加到这个组件的根元素上。对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。</p><p>但是<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来</p></blockquote></li><li><pre><code class="html">&lt;blog-postv-bind:post=&quot;post&quot; title=&quot;this is se&quot;&gt;&lt;/blog-post&gt;// 声明组件中props: [&#39;post&#39;],只有一个post属性, 那么title attribute就会被传递给模板的根元素 //  title 就是非prop的 attribute <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- 如果你**不**希望组件的根元素继承 非prop的attribute，你可以在组件的选项中设置 `inheritAttrs:</span> <span class="hljs-literal">false</span>`<br><br><span class="hljs-title">- &gt; `inheritAttrs:</span> <span class="hljs-literal">false</span>` 选项**不会**影响 `style` 和 `class` 的绑定。<br><br><span class="hljs-title">- 通过`inheritAttrs:</span> <span class="hljs-literal">false</span>` 和 `$attrs`, 决定attribute 会被赋予哪个元素,而不总是根元素<br><br>- ```html<br>   &lt;label&gt;<br>        &#123;&#123; label &#125;&#125;<br>        &lt;input<br>          v-bind=<span class="hljs-string">&quot;$attrs&quot;</span><br>          &gt;        //通过 v-bind=<span class="hljs-string">&quot;$attrs&quot;</span> 传入内部组件<br>   &lt;/label&gt;<br></code></pre></td></tr></table></figure>------</code></pre></li></ul><p><strong>子组件通过<code>事件</code>向父组件传递数据:</strong></p><ul><li><blockquote><ol><li>子组件模板内可以通过<code>v-on:click =$emit(&#39;enlarge-text&#39;, 0.1)  </code> 触发事件并传递数据</li><li>父级组件监听这个自定义事件,内联式直接处理,或者传递一个函数,在methods中处理</li></ol></blockquote></li><li><pre><code class="HTML">&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;  //子组件模板内&lt;blog-post  v-on:enlarge-text=&quot;postFontSize += $event&quot;  //父级组件,通过内联式处理     $event:代表数据&gt;&lt;/blog-post&gt;&lt;blog-post  v-on:enlarge-text=&quot;onEnlargeText&quot;       //父级组件,通过函数处理 , 函数第一个参数接受子组件的数据&gt;&lt;/blog-post&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs">  <br><br><br><br>**自定义事件**:<br><br>- **事件名**: 不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。(触发一个 camelCase 名字的事件, 监听这个名字的 kebab-case 版本是不会有任何效果)<br><br>- &gt; `v-on` 事件监听器在 **DOM 模板中**会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 `v-on:myEvent` 将会变成 `v-on:myevent`——导致 `myEvent` 不可能被监听到。<br><br><br>- **将原生事件绑定到子组件:**<br><br>- 想要在一个组件的根元素(含有模板的父组件)上直接监听一个**原生事件**。这时，你可以使用 `v-on` 的 `.native` 修饰符：  如果不使用 native 将无法监听事件<br><br>- &gt; 针对组件 Vue 有自己的事件系统,在父组件山 v-on希望监听一个自定义事件, 而不是原生事件, 所以需要加上native告诉他.<br>  &gt;<br>  &gt; $on $emit 并不是addeventlistener dispatcheventlistener 的别名,这和浏览器事件是不同的两个系统<br><br>- &gt; 为什么在父组件 监听原生组件而不是直接在根元素上 ??<br>  &gt;<br>  &gt; 原因是 :  <br>  &gt;<br>  &gt; 因为我们在使用时,经常使用父组件, 不会去特意去修改组件里的 template 模板内容, 使用native 父组件绑定的事件传递给子组件<br>  &gt;<br>  &gt; 1.作用域的原因, 事件将使用父作用域,<br>  &gt;<br>  &gt; 2.而且不加native,父组件绑定的事件无法传给 子组件, 不像 非prop 的attribute<br><br><br><br>- &gt; &lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;  <br>  &gt;<br>  &gt; //这会传递到组件上的根元素上, 但是当根元素是个特殊元素,没有该事件,父级的 `.native` 监听器将静默失败。它不会产生任何报错<br><br>- 为了解决这个问题，Vue 提供了一个 `$listeners` property，它是一个对象，里面包含了作用在这个组件上 (不含 `.native` 修饰器的) `v-on` 事件监听器的所有监听器,你就可以配合 `v-on=&quot;$listeners&quot;` 将所有的事件监听器指向这个组件的某个特定的子元素<br><br>  <br><br>  **.sync修饰符**:*(子组件通过事件的形式,改变prop绑定的值, 即像父组件传递了数据)*<br><br>- 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。<br><br>- 这也是为什么我们推荐以 `update:myPropName` 的模式触发事件取而代之:<br><br>- &gt; 在一个包含 `title` prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图<br>  &gt;<br>  &gt; ```html<br>  &gt; this.$emit(&#x27;update:title&#x27;, newTitle)<br>  &gt; <br>  &gt; 然后父组件可以监听那个事件并根据需要更新一个本地的数据 property<br>  &gt; <br>  &gt; &lt;text-document <br>  &gt; <br>  &gt; v-bind:title=&quot;doc.title&quot; <br>  &gt; <br>  &gt; v-on:update:title=&quot;doc.title = $event&quot; &gt;<br>  &gt; <br>  &gt; &lt;/text-document&gt;<br>  &gt; <br></code></pre></td></tr></table></figure>&gt;&gt; &gt;&gt; 我们为这种模式提供一个缩写，即 `.sync` 修饰符, 类似于v-model 也是一个语法糖&gt;&gt; <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title.sync</span>=<span class="hljs-string">&quot;doc.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br>// 子组件设置 this.$emit(&#x27;update:title&#x27;, newTitle)<br>// 父组件将会自动绑定prop 并且添加用于更新的 v-on 监听器。<br></code></pre></td></tr></table></figure>&gt;&gt; </code></pre></li><li><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p></li><li><pre><code class="html">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;//用在一个字面量的对象上，例如 v-bind.sync=”&#123; title: doc.title &#125;”，也是无法正常工作的<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- 注意带有 `.sync` 修饰符的 `v-bind` **不能**和表达式一起使用, 你只能提供你想要绑定的 property 名<br><br>  <br><br>  <br><br>##### **通过插槽传递内容**<br><br>- 和 HTML 元素一样，我们经常需要向一个组件传递内容，(注意不是数据 而是内容)<br><br>*插槽的基本用法*::<br><br>- **插槽内容:**<br><br>- ```html<br>  父组件: <br>  &lt;navigation-link url=&quot;/profile&quot;&gt;<br>    Your Profile<br>  &lt;/navigation-link&gt;<br>  <br>  子组件:<br>  &lt;a<br>    v-bind:href=&quot;url&quot;<br>    class=&quot;nav-link&quot;<br>  &gt;<br>    &lt;slot&gt;当组件渲染的时候，将会被替换为“Your Profile”。&lt;/slot&gt;<br>  &lt;/a&gt;<br>  <br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>如果子组件中没有<slot>标签 , 父组件的内容将会被抛弃</p><p><strong>slot 插槽可以包含任何模板代码</strong>, 可以是html标签…</p></blockquote></li><li><p><strong>后备内容:</strong>(插槽的默认内容)</p></li><li><pre><code class="html">例如在一个 &lt;submit-button&gt; 组件template中:&lt;button type=&quot;submit&quot;&gt;  &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- **插槽中使用数据:**<br><br>- ```html<br>  &lt;navigation-link url=&quot;/profile&quot;&gt;<br>    Logged in as &#123;&#123; user.name &#125;&#125;<br>  &lt;/navigation-link&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>当你想在一个插槽中使用数据时, 这里的作用域只能使用和父组件作用域一样的,(使用vue实例中的数据)</p><p>而子组件只能使用, Vue组件定义内数据, 两个作用域<strong>相互独立</strong>  =&gt;</p><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p></blockquote></li><li><p><strong>作用域插槽:</strong></p></li><li><blockquote><p>让插槽内容能够访问子组件作用域的数据*, 插槽内容作用域和子组件的作用域是独立的, 使用作用域插槽,可以访问到子组件的作用域</p></blockquote></li><li><pre><code class="html">&lt;current-user&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;  //将包含所有插槽 prop 的对象命名为 slotProps    &#123;&#123; slotProps.user.firstName &#125;&#125;  &lt;/template&gt;&lt;/current-user&gt;     子组件 :  &lt;span&gt;    &lt;slot v-bind:user=&quot;user&quot;&gt;   // 绑定在 &lt;slot&gt; 元素上的 attribute 被称为插槽 prop,通过该prop访问子组件的数据      &#123;&#123; user.lastName &#125;&#125;    &lt;/slot&gt;  &lt;/span&gt;<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">- 在上述情况下，当被提供的内容*只有*默认插槽时，组件的标签才可以被当作插槽的模板来使用。不再使用template</span><br><br><span class="xml">- ```html</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span><br><span class="xml">  //default 也可以省略</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确,只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法</p></li></ul><ul><li><p><strong>解构插槽prop</strong>:</p></li><li><blockquote><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里:  </p><ul><li>function (slotProps) {  // 插槽内容 }</li><li>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。可以使用<strong>解构语法</strong>来<strong>传入具体的插槽 prop</strong>:    在该插槽提供了多个 prop 的时候很有用</li></ul></blockquote></li></ul><ul><li><pre><code class="html">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;  &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt;prop 重命名:&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt;  &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt;定义后备内容，用于插槽 prop 是 undefined 的情形:&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &#39;Guest&#39; &#125; &#125;&quot;&gt;&#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt;<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs http"><br><br><br><br>- **具名插槽:**(*多个插槽时需要起名字*)<br><br>- ```html<br>  //&lt;base-layout&gt;组件的template中:<br>  &lt;div&gt;<br>  &lt;header&gt;<br>      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>    &lt;/header&gt;<br>  &lt;main&gt;<br>      &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;/div&gt;<br>  <br>  &lt;base-layout&gt;组件中:<br>      <br>  &lt;base-layout&gt;<br>  &lt;template v-slot:header&gt;<br>      &lt;h1&gt;Here might be a page title&lt;/h1&gt;<br>    &lt;/template&gt;<br>  <br>    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;<br>    &lt;p&gt;And another one.&lt;/p&gt;<br>  &lt;/base-layout&gt; ```<br>  <br> <br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p></blockquote></li><li><p>默认插槽内容也可以使用<template v-slot:default> </template> 包裹起来</p></li><li><blockquote><p>默认插槽内容没有被包裹在<code>&lt;template&gt;</code>中 和包裹在<template v-slot:default> </template> 中的元素,后者优先级更高</p></blockquote></li><li><p> <em>v-slot 只能添加在 <template> 上</em> </p></li></ul><ul><li><p><strong>动态插槽名 :</strong></p></li><li><pre><code class="html">&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt;  &lt;/template&gt;&lt;/base-layout&gt;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>- **具名插槽的缩写**:   `v-slot`: 替换为字符 `#`<br><br><br>- **废弃语法:**<br><br>- &gt; 带有 slot attribute 的具名插槽 &lt;template slot=&quot;header&quot;&gt;<br>  &gt;<br>  &gt; 带有 slot-scope attribute 的作用域插槽&lt;template slot=&quot;default&quot; slot-scope=&quot;slotProps&quot;&gt;<br><br><br><br>#### 组件切换(动态组件) / 异步组件:<br><br>- `is attribute`<br><br>- 有的时候，在**不同组件之间进行动态切换**是非常有用的,可以通过 Vue 的 `&lt;component&gt;` 元素加一个特殊的 `is` attribute 来实现:<br><br>- ```html<br>  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;<br>  `currentTabComponent `  可以是 已注册组件的名字，或 一个组件的选项对象(带有component选项的对象)<br>  <br>  注意和注册组件  components 选项的区别<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><blockquote><p><code>is  attribute </code>可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。</p><p> 意味着像 <code>value</code> 这样的 property,只能表示用户输入的值,而不是预设的值  参考js attr property区别    value 只能从特性 同步到 属性</p></blockquote></li><li><p><strong>解析 DOM 模板时的注意事项:</strong></p></li><li><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p></li><li><pre><code>&lt;table&gt;  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt;   //无法解析该自定义组件&lt;table  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;   // 使用 is  attribute 解决该状况&lt;/table&gt;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> 但是从以下来源使用模板,这条限制不存在 :<br><br><span class="hljs-selector-tag">-</span> &gt; <span class="hljs-selector-tag">-</span> 字符串 (例如：<span class="hljs-built_in">`template: &#x27;...&#x27;`</span>)<br>  &gt; <span class="hljs-selector-tag">-</span> <span class="hljs-selector-attr">[单文件组件 (`.vue`)]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//cn.vuejs.org/v2/guide/single-file-components.html)</span><br>  &gt; - &lt; script type=<span class="hljs-string">&quot;text/x-template&quot;</span>&gt;<br>  <br>- **<span class="hljs-attribute">keep-alive</span>:**<br><br>- 使用 <span class="hljs-built_in">`is`</span> attribute 来切换不同的组件,当在这些组件之间切换的时候，会重新渲染这些组件, 你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。  :可以用一个 <span class="hljs-built_in">`&lt;keep-alive&gt;`</span> 元素将其动态组件包裹起来。<br><br>- <span class="hljs-built_in">``</span>`html<br>  &lt;keep-alive&gt;  <br>  &lt;component <span class="hljs-attribute">v-bind</span>:is=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;&lt;/component&gt; <br>  &lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p><strong>异步组件:</strong> </p></li><li><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件, 这个工厂函数会异步解析你的组件定义。</p></li></ul><ul><li><blockquote><p>…待拓展</p></blockquote></li><li><pre><code class="vue">Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;  setTimeout(function () &#123;    // 向 `resolve` 回调传递组件定义    resolve(&#123;      template: &#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;    &#125;)  &#125;, 1000)&#125;)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br><br><br>#### 处理边界情况<br><br>- &gt; 这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。<br><br>  - **访问元素&amp;组件**<br><br>  - 每个 `new Vue` 实例的子组件中, 通过 `$root` property 进行访问根实例<br><br>  - &gt; this.$root.foo  //获取根实例的数据<br><br>    <br><br>  - 和 `$root` 类似, `$parent` property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。<br><br>  - 但是对于嵌套过深的父子元素推荐**依赖注入**<br><br>  - &gt; 依赖注入 : 实例选项：`provide` 和 `inject`<br>    &gt;<br>    &gt; `provide` 选项允许我们指定我们想要**提供**给后代组件的数据/方法。<br>    &gt;<br>    &gt; 然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的 property：<br><br>  - 依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。<br><br>    <br><br>  - 尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里**直接访问一个子组件**。通过 `$ref` , 这个 attribute 为子组件赋予一个 ID 引用, 调用$ref , 访问子组件实例(即定义组件的整个作用域), 还可以在子组件实例上再次调用ref 获得子元素<br><br>  - ```html<br>    &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;<br></code></pre></td></tr></table></figure>- &gt; `$refs` 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 `$refs`。</code></pre></li><li><p><strong>程序化的事件侦听器:</strong> </p></li><li><blockquote><p>Vue 实例同时在其事件接口中提供了其它的方法。</p><p>你通常不会用到这些，但是当你需要在一个<strong>组件实例上手动侦听事件</strong>时，它们是派得上用场的</p></blockquote></li><li><blockquote><ul><li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li><li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li><li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li></ul></blockquote></li><li><p><strong>循环引用:</strong></p></li><li><p><strong>组件本身的循环引用:</strong></p></li><li><p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事：</p></li><li><blockquote><p>使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p></blockquote></li><li><pre><code class="html">template: &#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> 请确保递归调用是条件性的(使用v-<span class="hljs-keyword">if</span>) , 否则组件将会导致“max stack size exceeded”错误(组件无限循环)</span><br><br><span class="ruby">- **组件间的循环引用<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- &gt; 待拓展: ...</span><br><br><span class="ruby">- **模板定义的替代品<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- 内联模板 : <span class="hljs-string">`inline-template`</span> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板</span><br><br><span class="ruby">- <span class="hljs-string">``</span><span class="hljs-string">`html</span></span><br><span class="ruby">  &lt;my-component inline-template&gt;</span><br><span class="ruby">    &lt;div&gt;</span><br><span class="ruby">      &lt;p&gt;These are compiled as the component<span class="hljs-string">&#x27;s own template.&lt;/p&gt;</span></span><br><span class="ruby">      &lt;p&gt;Not parent<span class="hljs-string">&#x27;s transclusion content.&lt;/p&gt;</span></span><br><span class="ruby">    &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="ruby">  &lt;<span class="hljs-regexp">/my-component&gt;</span></span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p></blockquote></li><li><p>X-Template:  在一个 <code>&lt;script&gt;</code> 元素中，带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。</p></li><li><pre><code class="html">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;  &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&#39;hello-world&#39;, &#123;  template: &#39;#hello-world-template&#39;&#125;)<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> **控制更新<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- 强制更新 : [<span class="hljs-string">`$forceUpdate`</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/cn.vuejs.org/v</span>2/api/<span class="hljs-comment">#vm-forceUpdate) </span></span><br><br><br><br><span class="ruby">- 通过 <span class="hljs-string">`v-once`</span> 创建低开销的静态组件<span class="hljs-symbol">:</span></span><br><br><span class="ruby">- &gt; 组件包含了**大量**静态内容。在这种情况下，你可以在根元素上添加 <span class="hljs-string">`v-once`</span> attribute 以确保这些内容只计算一次然后缓存起来, (这导致的副作用是, 该内容是无法进行更新的)</span><br><br><span class="ruby">- <span class="hljs-string">``</span><span class="hljs-string">`html</span></span><br><span class="ruby">  Vue.component(<span class="hljs-string">&#x27;terms-of-service&#x27;</span>, &#123;</span><br><span class="ruby">    <span class="hljs-symbol">template:</span> <span class="hljs-string">`</span></span><br><span class="ruby">      &lt;div v-once&gt;</span><br><span class="ruby">        &lt;h1&gt;Terms of Service&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="ruby">        ... a lot of static content ...</span><br><span class="ruby">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="ruby">    <span class="hljs-string">`</span></span><br><span class="ruby">  &#125;)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="番外-vue-提供的额外内容"><a href="#番外-vue-提供的额外内容" class="headerlink" title="番外: vue 提供的额外内容"></a>番外: vue 提供的额外内容</h3><h4 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h4><ul><li><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果</p></li><li><blockquote><ul><li>在 CSS 过渡和动画中自动应用 class(可以使用第三方css动画库 Animate.css自定义)</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM ,(可以使用第三方 JavaScript 动画库 Velocity.js)</li></ul></blockquote></li><li><p><strong>单元素/组件的过渡:</strong>   使用<code>transition</code> 的封装组件</p></li><li><blockquote><p>在下列情形中,可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 <code>v-if</code>)</li><li>条件展示 (使用 <code>v-show</code>)</li><li>动态组件</li><li>组件根节点</li></ul></blockquote></li><li><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p></li><li><blockquote><p>1.检查元素是否应用了css过渡/动画, 如果是在恰当的时机添加/删除类名</p><p>2.过渡组件是否提供了JavaScript钩子函数, 这些钩子函数在恰当时机调用</p><p>3.如果以上都没有找到, 立即执行DOM操作</p></blockquote></li></ul><ul><li><p><strong>过渡的类名:</strong></p></li><li><blockquote><ol><li><code>v-enter</code>：元素进入过渡的开始状态, 元素插入dom之前,添加该类到元素中,元素插入的<strong>下一帧</strong>移除</li><li><code>v-enter-active</code>：进入过渡状态激活应用该类。在元素插入DOM之前添加该类到元素 ,在过渡/动画完成之后移除</li><li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入DOM之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，<strong>下一帧</strong>被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li></ol><p>没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>  则 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p></blockquote><ul><li><blockquote><p>一般不设置 <code>v-enter-to</code>   <code>v-leave</code> 类</p><p>因为 <code>v-enter-to</code>在结束动画时该类会被移除,移除后样式恢复默认(会发生突然变化无法保存最后的样式效果), 不添加时,直接应用v-enter 类往默认的样式过渡</p><p><code>v-leave</code>类 在离开过渡时立即生效,下一帧移除,导致看不到初始效果(看起来还是默认效果)</p></blockquote></li><li><p><strong>css过渡&amp;动画:</strong></p></li><li><pre><code class="html"> 插入或删除包含在 `transition` 组件中的元素,自动应用类完成过渡  &lt;transition name=&quot;slide-fade&quot;&gt;      &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;    &lt;/transition&gt;  .slide-fade-enter-active &#123;    transition: all .3s ease;&#125;...省略<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">  <br>  - CSS 动画用法同 CSS 过渡，区别是在动画中 `v-enter` 类名在节点插入 DOM 后不会立即删除，而是在 `animationend` 事件触发时删除。<br>  <br>    <br>  <br><span class="hljs-title">  - **自定义过渡的类名(使用第三方css库):</span>**<br>  <br>- &gt; 我们可以通过以下 attribute 来自定义过渡类名：<br>    &gt;<br>    &gt; - `enter-class`<br>    &gt; - `enter-active-class`<br>    &gt; - `enter-to-class` (<span class="hljs-number">2.1</span>.<span class="hljs-number">8</span>+)<br>    &gt; - `leave-class`<br>    &gt; - `leave-active-class`<br>    &gt; - `leave-to-class` (<span class="hljs-number">2.1</span>.<span class="hljs-number">8</span>+)<br>  <br>  - ```html<br>    &lt;link href=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span> type=<span class="hljs-string">&quot;text/css&quot;</span>&gt; <br>  &lt;transition<br>        name=<span class="hljs-string">&quot;custom-classes-transition&quot;</span><br>      enter-active-class=<span class="hljs-string">&quot;animated tada&quot;</span><br>        leave-active-class=<span class="hljs-string">&quot;animated bounceOutRight&quot;</span><br>     &gt;<br>        &lt;p v-if=<span class="hljs-string">&quot;show&quot;</span>&gt;hello&lt;/p&gt;<br>    &lt;/transition&gt;  <br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ul><li><p><strong>同时使用过渡和动画:</strong>  使用过渡 动画其中一种, Vue 能自动识别类型并设置监听,事件是否完成。在一些场景中，你需要给同一个元素同时设置两种过渡动效，</p></li><li><blockquote><p>在这种情况中，你就需要使用 <code>type</code> attribute 并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p></blockquote></li><li><p><strong>显性的过渡持续时间:</strong> 默认情况下，Vue 会等待其在过渡效果的根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</p></li><li><blockquote><p>你可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间 ,在过渡/动画上的事件失效</p><p><transition :duration="{ enter: 500, leave: 800 }">…</transition></p></blockquote></li><li><p><strong>JavaScript钩子:</strong></p></li><li><pre><code class="html">&lt;transition  v-on:before-enter=&quot;beforeEnter&quot;  v-on:enter=&quot;enter&quot;  v-on:after-enter=&quot;afterEnter&quot;  v-on:enter-cancelled=&quot;enterCancelled&quot;  v-on:before-leave=&quot;beforeLeave&quot;v-on:leave=&quot;leave&quot;  v-on:after-leave=&quot;afterLeave&quot;v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;!-- ... --&gt;&lt;/transition&gt;这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <br>  - 当只用 JavaScript 过渡(**只在钩子函数中定义样式变化**,一般使用第三方js库在钩子函数中实现)的时候，**在 `enter` 和 `leave` 中必须使用 `done` 进行回调**。否则，它们将被同步调用，过渡会立即完成。<br>  <br>  - &gt; 推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=&quot;false&quot;`，Vue 会跳过 CSS 的检测。<br>  <br>- **初始渲染的过渡:** 初始渲染过渡就是界面初始化时的过渡，在界面刚打开或刚刷新的时候就进入过渡渲染。<br><br>- 可以通过 `appear` attribute 或者`v-on:appear `设置节点在初始渲染的过渡, 设置类(appear-class...)样式<br><br>- 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。自定义 JavaScript 钩子：<br><br>- ```html<br>  &lt;transition<br>    appear<br>    appear-class=&quot;custom-appear-class&quot;<br>    appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)<br>    appear-active-class=&quot;custom-appear-active-class&quot;<br>  &gt;<br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p><strong>多个元素的过渡:</strong> </p></li><li><blockquote><p>对于原生标签可以使用 <code>v-if</code>/<code>v-else</code></p><p>当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p></blockquote></li><li><p>也可以通过给同一个元素的 <code>key</code> attribute 设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code></p></li><li><p><strong>过渡模式:</strong>   </p></li><li><p><code>&lt;transition&gt;</code> 的默认行为 - 进入和离开过渡同时发生。</p><ul><li><blockquote><ul><li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li><li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul></blockquote></li></ul></li><li><p><strong>多个组件间的过渡:</strong> </p></li><li><blockquote><p>我们只需要使用绑定 is , 使用动态组件</p></blockquote></li></ul><ul><li><p><strong>列表过渡:</strong></p></li><li><p>以上都是单个元素/组件的过渡,或者同一时间多个节点中的一个, 如何同时渲染一个列表?</p></li><li><blockquote><p>使用 <transition-group> 组件, 不同于<transition></p><ol><li>它默认是一个<span>作为根节点,  可以通过tag=”” 更换其他的元素</li><li>过渡模式不可用,因为不再切换特定元素,</li><li>内部元素<strong>总是需要</strong>一个key, 因为vue高度复用dom节点的问题, 不加key造成指定的DOM节点并没有动态变化</li><li>css过渡/动画都是应用在内部的元素中, 而不是这个容器中</li></ol></blockquote></li><li><p><strong>列表的进入/离开过渡:</strong></p></li><li><pre><code class="html">&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt;  &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;  &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;  &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;    &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;      &#123;&#123; item &#125;&#125;    &lt;/span&gt;  &lt;/transition-group&gt;&lt;/div&gt;<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- **列表的排序过渡:**(即被动移动元素的平滑过渡)<br><br>- 在操作元素的位置变化时，由于DOM文档流的变化，会同时引起其它（邻近）节点元素的位置变化, 对于这些“被动”移动的元素来说，也可以实现过渡，这就用到了`v-move` 特性。<br><br>- &gt;      1.**`v-move` class**，它会在元素的**改变定位的过程中**(交换数据位置也算改变定位)应用。<br>  &gt;<br>  &gt;    可以通过 `name` attribute 来自定义前缀，也可以通过 `move-class` attribute 手动设置 <br>  &gt;<br>  &gt;    2. 也可以给列表的所有元素都添加一个类，直接给这个类设置CSS transition属性，元素移动的时候自动获得v-move。<br>  &gt;    3.  用splice删除数组的元素，由于删除的元素经历过渡时，始终占据文档流的这个位置，导致下一个元素要等待其过渡结束,DOM移除时才移动过来，造成一个生硬的效果。要达到平滑过渡，就要在删除元素leave-active阶段用position:absolute将其移出文档流，后面的元素才能同时平滑过渡过来<br>&gt;<br>  &gt;    <br>  &gt;<br>  &gt;    内部的实现，Vue 使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 简单的动画队列,使用 transforms 将元素从之前的位置平滑过渡新的位置。<br>  &gt;<br>  &gt;    需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中<br><br>  <br><br>- **列表的交错过渡:**  通过 data attribute 数据 和 js钩子函数, 直接在函数中根据data操作过渡时间, 形成交错过渡的效果<br><br>- **可复用的过渡:** 要创建一个可复用过渡组件，你需要做的就是将 `&lt;transition&gt;` 或者 `&lt;transition-group&gt;` 作为根组件<br><br>- **动态过渡:** 在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 `name` attribute 来绑定动态值。<br><br>- &gt; 不仅仅只有 attribute 可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。根据数据  使用js过渡会有不同的表现<br><br>#### 状态过渡<br><br>- 数据元素本身的动效, 这些数据要么本身就以数值形式存储，要么可以转换为数值。<br><br>- 比如：<br><br>  - 数字和运算<br>  - 颜色的显示<br>  - SVG 节点的位置<br>  - 元素的大小和其他的 property<br><br>- 通过侦听器我们能监听到任何数值 property 的数值更新, 再使用第三方动画库, 实现数据的动效<br><br>- **动态状态过渡:** 类似于组件的动态过渡<br><br>- &gt; 管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，可以提取到子组件中。<br><br><br><br>#### 可复用性&amp;&amp;组合<br><br>- **混入(mixin)** : 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。<br><br>- 一个混入对象可以包含**任意组件选项**。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项<br><br>- 混合语法: <br><br>- ```javascript<br>  var myMixin = &#123;<br>    created: function () &#123;<br>      this.hello()<br>    &#125;,<br>    methods: &#123;<br>      hello: function () &#123;<br>        console.log(&#x27;hello from mixin!&#x27;)<br>      &#125;<br>    &#125;<br>  &#125;<br>  var Component = Vue.extend(&#123;         //使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。<br>    mixins: [myMixin]<br>  &#125;)<br>  <br>  var component = new Component() // =&gt; &quot;hello6 from mixin!&quot;<br>  <br></code></pre></td></tr></table></figure></code></pre></li><li><p>混合规则: </p></li><li><blockquote><p>数据对象(data)在内部会进行递归合并，并在发生冲突时以组件数据优先。</p><p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p><p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p></blockquote></li><li><p>全局混入:一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例。</p></li><li><pre><code class="js">new Vue(&#123;  mixins: [mixin],  created: function () &#123;    console.log(&#39;组件钩子被调用&#39;)  &#125;&#125;)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- 自定义选项混合规则:<br><br>- &gt; `Vue.config.optionMergeStrategies` 添加一个函数<br><br>  <br><br>**自定义指令:**<br><br>- Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。<br><br>- 自定义指令:<br><br>- &gt; 定义全局指令:<br>  &gt;<br>  &gt; Vue.directive(&#x27;指令name&#x27;, &#123;&#125;);<br>  &gt;<br>  &gt; 定义局部指令: <br>  &gt;<br>  &gt; 组件中也接受一个 `directives` 的选项<br><br>- 一个指令定义对象可以提供如下几个**钩子函数**:<br><br>- &gt;bind  只调用一次，指令第一次绑定到元素时调用。<br>  &gt;<br>  &gt;inserted 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>  &gt;<br>  &gt;update  所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。<br>  &gt;<br>  &gt;componentUpdated  指令所在组件的 VNode **及其子 VNode** 全部更新后调用。<br>  &gt;<br>  &gt;unbind 只调用一次，指令与元素解绑时调用。<br><br>- 上述钩子函数的参数:<br><br>- &gt; - `el`：指令所绑定的元素，可以用来直接操作 DOM。<br>  &gt;<br>  &gt; - ```<br>  &gt;   binding：一个对象，包含以下 property：<br></code></pre></td></tr></table></figure>&gt;&gt;   - `name`：指令名，不包括 `v-` 前缀。&gt;   - `value`：指令的绑定值，例如：`v-my-directive=&quot;1 + 1&quot;` 中，绑定值为 `2`。&gt;   - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。&gt;   - `expression`：字符串形式的指令表达式。例如 `v-my-directive=&quot;1 + 1&quot;` 中，表达式为 `&quot;1 + 1&quot;`。&gt;   - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `&quot;foo&quot;`。&gt;   - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `&#123; foo: true, bar: true &#125;`。&gt;&gt; - `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://cn.vuejs.org/v2/api/#VNode-接口) 来了解更多详情。&gt;&gt; - `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。</code></pre></li><li><p><strong>指令的参数可以是动态的</strong>。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。通过调用binding.arg 来获取该动态值 </p></li><li><p><strong>函数简写</strong>:你可能想在 <code>bind</code> 和 <code>update</code> 时触发相同行为，而不关心其它的钩子</p></li><li><pre><code class="javascript">Vue.directive(&#39;color-swatch&#39;, function (el, binding) &#123;  el.style.backgroundColor = binding.value&#125;)<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>- **对象字面量 :**  如果指令需要多个值，可以传入一个 JavaScript 对象字面量<br><br>- ```<br>  &lt;<span class="hljs-keyword">div</span> v-demo=<span class="hljs-string">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  <span class="hljs-comment">//通过binding.value.color , binding.value.text调用</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>渲染函数&amp;&amp;JSX</strong></p><ul><li><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。但是有时候你需要<strong>动态编辑模板</strong>中内容,需要js的完全编程控制,这是需要 渲染函数</p></li><li><blockquote><p>模板 也是一种限制, 渲染函数可以对渲染的模板进行完全的编辑, 利用函数控制渲染出的DOM</p></blockquote></li><li><p><strong>vue更新DOM方法:</strong></p></li><li><blockquote><p>1.在vue里使用模板 <h1></h1></p><p>2.或者使用渲染函数  :</p><p>render: function (createElement) { </p><p> return createElement(‘h1’, this.blogTitle) </p><p>}</p><p>在这两种情况下，Vue 都会自动保持页面的更新</p></blockquote></li><li><p><strong>vue更新DOM原理:</strong></p></li><li><p><strong>虚拟 DOM</strong> : Vue 通过建立一个<strong>虚拟 DOM</strong> 来追踪自己要如何改变真实 DOM</p></li><li><blockquote><p>return createElement(‘h1’, this.blogTitle)</p><p>createElement 返回的不是一个实际的DOM元素, 而是createNodeDescription, 它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点包括及其子节点的描述信息。</p><p>我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<strong>VNode</strong>”。</p></blockquote></li><li><p><strong>渲染函数:</strong></p></li><li><p><strong>createElement 参数</strong></p></li><li><pre><code class="javascript">createElement(  // &#123;String | Object | Function&#125;  // 一个 HTML 标签名、组件选项对象，或者  &#39;div&#39;,  // &#123;Object&#125;  // 一个与模板中 attribute 对应的数据对象。可选。  &#123;  // 允许你绑定普通的 HTML attribute      &#39;class&#39;: &#123;    foo: true,    bar: false  &#125;,       domProps: &#123;    innerHTML: &#39;baz&#39;  &#125;,  &#125;,  // &#123;String | Array&#125;  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，  // 也可以使用字符串来生成“文本虚拟节点”。可选。  [    &#39;先写一些文字&#39;,    createElement(&#39;h1&#39;, &#39;一则头条&#39;),    createElement(MyComponent, &#123;      props: &#123;        someProp: &#39;foobar&#39;      &#125;    &#125;)  ])<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 待拓展`createElement` 函数...<br><br><span class="hljs-title">- **使用 JavaScript 代替模板功能:</span>**<br><br>- &gt; 只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。<br>  &gt;<br><span class="hljs-title">  &gt; 比如 :</span> 模板中的 v-if v-for  , 在渲染函数中使用 js 的 if/else/map重写即可<br><br>- 渲染函数中没有与 `v-model` 的直接对应——你必须自己实现相应的逻辑<br><br>- 对于 `.passive`、`.capture` 和 `.once` 这些事件修饰符, Vue 提供了相应的前缀可以用于 `on`(createlement 函数中)<br><br><span class="hljs-title">- 你可以通过 [`this.$slots`](https://cn.vuejs.org/v2/api/#vm-slots) 访问静态插槽的内容，每个插槽都是一个 VNode 数组, 也可以通过 [`this.$scopedSlots`](https:</span>//cn.vuejs.org/v2/api/#vm-scopedSlots) 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数<br><br><span class="hljs-title">- JSX :</span> 在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上。<br><br><span class="hljs-title">**模板编译:</span>**<br><br>- Vue 的模板实际上被编译成了渲染函数<br><br>#### 插件<br><br><span class="hljs-title">- 使用插件:</span> 通过全局方法 `Vue.use()` 使用插件。它需要在你调用 `new Vue()` 启动应用之前完成：<br><br>- &gt; `Vue.use` 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。<br>  &gt;<br>  &gt; Vue.js 官方提供的一些插件 (例如 `vue-router`) 在检测到 `Vue` 是可访问的全局变量时会自动调用 `Vue.use()`。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 `Vue.use()`：<br><br><span class="hljs-title">- 开发插件 :</span>  Vue.js 的插件应该暴露一个 `install` 方法。这个方法的第一个参数是 `Vue` 构造器，第二个参数是一个可选的选项对象<br><br>#### 过滤器<br><br>- Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。<br><br>- &gt; 过滤器可以用在两个地方：**双花括号插值和 `v-bind` 表达式** (后者从 <span class="hljs-number">2.1</span>.<span class="hljs-number">0</span>+ 开始支持)。<br><br>- ```js<br>  //过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：<br>  <br>  &lt;!-- 在双花括号中 --&gt;<br>  &#123;&#123; message | capitalize &#125;&#125;<br>  <br>  &lt;!-- 在 `v-bind` 中 --&gt;<br><span class="hljs-title">  &lt;div v-bind:</span>id=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;&lt;/div&gt;<br>  <br><span class="hljs-title">  局部过滤器:</span>  在一个组件的选项中定义<br><span class="hljs-title">  filters:</span> &#123;<br><span class="hljs-title">    capitalize:</span> function (value) &#123;<br>      if (!value) <span class="hljs-keyword">return</span> &#x27;&#x27;<br>      value = value.toString()<br>      <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.slice(<span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>  <br>  <br>  全局过滤器： 在创建 Vue 实例之前使用函数<br>  Vue.filter(&#x27;capitalize&#x27;, function (value) &#123;<br>    if (!value) <span class="hljs-keyword">return</span> &#x27;&#x27;<br>  value = value.toString()<br>    <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.slice(<span class="hljs-number">1</span>)<br>  &#125;)<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。</p></li></ul><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><ul><li><p>由于js 原因无法检测对象 和数组</p></li><li><blockquote><p>Vue 无法检测 property 的添加或移除。</p></blockquote></li><li><blockquote><p>Vue 不能检测以下数组的变动：</p><ol><li>当你利用索引直接设置一个数组项时</li><li>当你修改数组的长度时</li></ol></blockquote></li></ul><ul><li><p>这样规则对 watch 一样使用 , 对于对象内部的变化需要使用deep选项</p></li><li><blockquote><p>对象 : watch 无法检测到 对象某个属性的值 /嵌套对象 改变, 使用deep</p><p>数组同上</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/vue%20router/"/>
    <url>/2020/12/14/Js-dom/vue%20router/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><ul><li><p>通过不同参数匹配到的所有路由，全都映射到同个组件</p></li><li><blockquote><p>例如 :  将<code>/user/foo</code> 和 <code>/user/bar</code> 映射到相同的路由。</p></blockquote></li></ul><ul><li><p>通过动态路径参数实现这个效果:</p></li><li><table><thead><tr><th align="left"></th><th><strong>$route.params</strong></th></tr></thead><tbody><tr><td align="left">/user/:username</td><td>{ username: ‘evan’ }</td></tr><tr><td align="left">/user/:username/post/:post_id</td><td>{ username: ‘evan’, post_id: ‘123’ }</td></tr></tbody></table></li><li><blockquote><p><strong>$route.params</strong> 获得动态路径参数</p><p>$route.query    $route.hash  提供其他信息</p></blockquote></li></ul><p>监听路由变化</p><ul><li><p>由于动态路由使用不同参数,访问的都是同一组件，组件会被复用以提升效率；</p></li><li><blockquote><p><strong>这也意味着组件的生命周期钩子不会再被调用</strong>。那怎么监听路由的变化呢？</p><p>可以利用Watch <code>$route</code> 对象来对路由参数的变化进行监测  , 监听$route(to, from)判断去处和来源；</p><p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫 </p></blockquote></li><li><pre><code class="javascript">组件:const User = &#123;  template: &#39;...&#39;,  watch: &#123;    $route(to, from) &#123;      // 对路由变化作出响应... &#125; &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- 有时路由不存在会得不到任何结果，可以设置捕获所有路由或 404<br><br>- ```javascript<br>  &#123;<br>    // 会匹配所有路径<br>    path: &#x27;*&#x27;&#125;<br>  &#123;<br>    // 会匹配以 `/user-` 开头的任意路径<br>    path: &#x27;/user-*&#x27;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分</p></li><li><blockquote><p> { path: ‘/user-*’ }<br>this.$router.push(‘/user-admin’)<br>this.$route.params.pathMatch // ‘admin’</p></blockquote></li></ul><ul><li><p>路由路径高级匹配模式</p></li><li><blockquote><p><code>vue-router</code> 使用 <a href="https://github.com/pillarjs/path-to-regexp/tree/v1.7.0">path-to-regexp</a> 作为路径匹配引擎，所以支持很多高级的匹配模式，查看文档获取更高级的匹配形式</p></blockquote></li><li><p>同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序</p></li></ul><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><ul><li><p>实际应用界面中, 通常由多层嵌套的组件组合而成:类似栏目分类,而路由也应该按某种结构对应这种嵌套关系,借助 <code>vue-router</code>，使用嵌套路由配置，就可以很简单地表达这种关系。</p></li><li><pre><code class="js">// 在 children 选项中定义嵌套路由设置new VueRouter(&#123;routes: [    &#123;      name:&#39;user&#39;      path: &#39;/user/:id&#39;, component: User,      children: [        // 当 /user/:id 匹配成功，        //  UserHome组件会被渲染在 User组件中的 &lt;router-view&gt;中        &#123; path: &#39;username&#39;, component: UserHome &#125;,        // ...其他子路由      ]              &#125;)<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- &gt; 如果不在父路由组件中使用 &lt;router-view&gt;, 那么将不会渲染子路由组件<br><br>- &gt; 这里组件名称和路径设置的不一样，路由采用的是路径； <br>  &gt;<br>  &gt; 子路由不需要 / ，因为斜杠会被当成根路径； <br><br>- 可以嵌套多层路由,而且子路由不需要 / 设置更方便, 不要忘记 &lt;router-view&gt;否则不会渲染<br><br><br><br><br><br><span class="hljs-comment">#### 编程式导航</span><br><br>- 使用 `&lt;router-link&gt;` 可以创建 a 标签来定义导航链接,但是缺乏编程性<br><br>- | 声明式                  | 编程式           |<br>  | ----------------------- | ---------------- |<br>  | &lt;router-link :to=<span class="hljs-string">&quot;...&quot;</span>&gt; | router.push(...) |<br><br>- **在 Vue 实例内部，你可以通过 `<span class="hljs-variable">$router</span>` 访问路由实例** (注意和<span class="hljs-variable">$route</span>的区别  route路由对象的属性)<br><br>- **router.push()**函数:<br><br>- &gt; 想要导航到不同的 URL，则使用 `router.push` 方法。这个方法会向 history 栈添加一个新的记录<br><br>- ```js<br>  <span class="hljs-regexp">//</span> 该方法的参数可以是一个字符串路径，或者一个描述地址的对象<br>  router.push(<span class="hljs-string">&#x27;/home&#x27;</span>)  <span class="hljs-regexp">//</span> 注意加上/就代表根目录, <br>  <br>  <span class="hljs-regexp">//</span> 命名的路由<br>  router.push(&#123; name: <span class="hljs-string">&#x27;user&#x27;</span>, params: &#123; userId: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br>  <br>  <span class="hljs-regexp">//</span> 带查询参数，变成 /register?plan=private<br>  router.push(&#123; path: <span class="hljs-string">&#x27;register&#x27;</span>, query: &#123; plan: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br>  <br>  <span class="hljs-regexp">//</span> 如果提供了 path，params 会被忽略,path和query是配套的<br>  <br>  const userId = <span class="hljs-string">&#x27;123&#x27;</span><br>  router.push(&#123; path: `<span class="hljs-regexp">/user/</span><span class="hljs-variable">$&#123;userId&#125;</span><span class="hljs-regexp">/test` &#125;) /</span><span class="hljs-regexp">/ -&gt; /u</span>ser<span class="hljs-regexp">/123/</span>test <br>  <span class="hljs-regexp">//</span>嵌套多层路由时,只能通过path解析路径<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p><strong>router.replace(…)函数:</strong></p></li><li><blockquote><p>跟 <code>router.push</code> 很像，但是它不会向 history 添加新记录， 而是替换掉当前的 history 记录。</p></blockquote></li><li><p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p></li><li><p><strong>router.go(n):函数:</strong></p></li><li><blockquote><p>类似 <code>window.history.go(n)</code>,意思是在 history 记录中向前或者后退多少步</p><p>1 前进一步   -1 后退一步</p></blockquote></li></ul><ul><li>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，你需要使用 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 来响应这个变化 (比如抓取用户信息)</li></ul><h4 id="命名路由和视图"><a href="#命名路由和视图" class="headerlink" title="命名路由和视图"></a>命名路由和视图</h4><ul><li><p>通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候,通过Router实例中的<code>name</code>属性实现</p></li><li><pre><code>routes: [    &#123;      path: &#39;/user/:userId&#39;,      name: &#39;user&#39;,      component: User    &#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- 要链接到一个命名路由，可以给 `router-link` 的 `<span class="hljs-keyword">to</span>` 属性传一个对象：<br><br>- &gt; &lt;router-link :<span class="hljs-keyword">to</span>=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;<span class="hljs-keyword">User</span>&lt;/router-link&gt;<br>  &gt;<br>  &gt; 注意这时候的 <span class="hljs-keyword">to</span>是通过 v-bind绑定的, 我们通过<span class="hljs-type">name</span>值 ,完成跳转<br><br><br><br>- **命名视图** : 有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar` (侧导航) 和 `main` (主内容) 两个视图，这个时候命名视图就派上用场了。<br><br>- &gt; 如何理解同级展示 嵌套展示:  当通过嵌套路由设置router-<span class="hljs-keyword">view</span> 这时会渲染成嵌套的div, 而通过命名视图设置router-<span class="hljs-keyword">view</span> ,则是  同级的div块<br><br>- 通过设置多个带有名字的 `router-<span class="hljs-keyword">view</span>`,没有名字默认为 `<span class="hljs-keyword">default</span>`<br><br>- ```html<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view one&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view two&quot; <span class="hljs-type">name</span>=&quot;a&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br>  &lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view three&quot; <span class="hljs-type">name</span>=&quot;b&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。这时在路由上需要使用<code>components</code>来规定子组件</p></li><li><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;     path: &#39;/&#39;,      components: &#123;        default: Foo,  //还可以是懒加载, () =&gt; import(&#39;../views/About.vue&#39;)也是可以        a: Bar,        b: Baz      &#125;    &#125;  ]&#125;)<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> &gt; 我们也有可能使用命名视图创建嵌套视图的复杂布局, 展示嵌套视图时还存在嵌套路由<br><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">js</span><br>  &#123; <br>      <span class="hljs-attribute">path</span>:<span class="hljs-string">&#x27;/long/:id&#x27;</span>,<br>      <span class="hljs-attribute">name</span>:<span class="hljs-string">&#x27;long&#x27;</span>,<br>      <span class="hljs-attribute">component</span>:long,<br>      <span class="hljs-attribute">children</span>:[&#123;<br>        <span class="hljs-attribute">path</span>:<span class="hljs-string">&quot;test&quot;</span>,<br>        <span class="hljs-attribute">components</span>:&#123;<br>          <span class="hljs-attribute">default</span>:Test,  <br>          <span class="hljs-attribute">sec</span>:button,<br>        &#125;,<br>        <span class="hljs-attribute">children </span>: [<br>          &#123;<br>              <span class="hljs-attribute">path </span>: <span class="hljs-string">&#x27;list&#x27;</span>,<br>              <span class="hljs-attribute">component </span>:List,<br>          &#125;<br>      ]   <br>      <span class="hljs-comment">/* 展示嵌套视图里的嵌套路由 , 默认children 是第一个元素的 */</span><br>   &#125;,<br>   ]&#125;, <br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h4><ul><li><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code></p></li><li><p>使用 redirect，可以配置路由的重定向功能，有多种方式；</p></li><li><pre><code class="js">routes: [    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;   //使用路径    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;   //使用路由名字  ]方法:routes: [    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123; &#125;      // 方法接收 目标路由 (被跳转的路由) 作为参数      // return 重定向的 字符串路径/路径对象    &#125; //每次点击不同的链接跳转时 总会触发redirect函数<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><br>  <span class="hljs-selector-tag">-</span> 注意<span class="hljs-selector-attr">[导航守卫]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//router.vuejs.org/zh/guide/advanced/navigation-guards.html)并没有应用在跳转路由上，而仅仅应用在其目标上。</span><br><br>- 别名 : **<span class="hljs-built_in">`/a`</span> 的别名是 <span class="hljs-built_in">`/b`</span>，意味着，当用户访问 <span class="hljs-built_in">`/b`</span> 时，URL 会保持为 <span class="hljs-built_in">`/b`</span>，但是路由匹配则为 <span class="hljs-built_in">`/a`</span>，就像用户访问 <span class="hljs-built_in">`/a`</span> 一样。**<br><br>- &gt; <span class="hljs-built_in">``</span>`js<br>  &gt;  <span class="hljs-attribute">routes</span>: [<br>  &gt;     &#123; <span class="hljs-attribute">path</span>: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attribute">component</span>: A, <span class="hljs-attribute">alias</span>: <span class="hljs-string">&#x27;/b&#x27;</span> &#125;<br>  &gt;   ]<br>  &gt; “别名”的功能让你可以自由地将 <span class="hljs-selector-tag">UI</span> 结构映射到任意的 <span class="hljs-selector-tag">URL</span>，而不是受限于配置的嵌套路由结构。<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="路由组件间的传参"><a href="#路由组件间的传参" class="headerlink" title="路由组件间的传参"></a>路由组件间的传参</h4><ul><li><p>在组件中使用<code>$route</code>会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p></li><li><p>使用 <code>props</code> 将组件和路由解耦:</p></li><li><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)解耦 :const User = &#123;  props: [&#39;id&#39;],  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    &#123;      path: &#39;/user/:id&#39;,      components: &#123; default: User, sidebar: Sidebar &#125;,      props: &#123; default: true, sidebar: false &#125;    &#125;  ]&#125;)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- 三种模式 : 布尔模式  对象模式 函数模式<br><br>- &gt;布尔模式 :  `props` 被设置为 `true`，`route.params` 将会被设置为组件属性。<br>  &gt;<br>  &gt;这样可以直接使用 route.params 中的对象, 注意这里的 prop 的名字 需要对应route.params 中的数据<br><br>  &gt;有对于静态路由，可以使用对象模式；<br>  &gt;<br>  &gt;```html<br>  &gt;props : &#123; <br>  &gt;name : &#x27;列表&#x27; <br>  &gt;&#125;,<br>  &gt;&lt;template&gt; <br>  &gt;&lt;h3&gt;这里是 List 页面 : &#123;&#123;name&#125;&#125;&lt;/h3&gt; <br>  &gt;&lt;/template&gt;<br>  &gt;<br>  &gt;对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：<br>  &gt;props : &#123; default : &#123; name : &#x27;列表&#x27; &#125; &#125;,<br>  &gt;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>函数模式  创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">routes: [<br>   &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-attr">component</span>: SearchUser, <span class="hljs-attr">props</span>: <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> (&#123; <span class="hljs-attr">query</span>: route.query.q &#125;) &#125;<br> ]<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h4><ul><li><p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p></li><li><p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p></li><li><blockquote><pre><code class="js">const router = new VueRouter(&#123;  mode: &#39;history&#39;,  routes: [...]&#125;)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 需要后台配置   <br><br><span class="hljs-bullet">-</span> &gt; 待拓展<br><br><br><br><br><br><span class="hljs-section">#### 导航守卫</span><br><br><span class="hljs-bullet">-</span> 什么是导航 : 表示路由正在发生改变。导航守卫主要作用: 是通过跳转/取消的方式 守卫导航 ,路由跳转时会触发一些钩子函数,这些钩子函数被称为导航守卫<br><br><span class="hljs-bullet">-</span> &gt; 记住<span class="hljs-strong">**参数或查询的改变并不会触发进入/离开的导航守卫**</span>。你可以通过[<span class="hljs-string">观察 `$route` 对象</span>](<span class="hljs-link">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化</span>)来应对这些变化，或使用 <span class="hljs-code">`beforeRouteUpdate`</span> 的组件内守卫。<br><br><span class="hljs-bullet">-</span> 导航守卫有多种: 全局  组件  路由独享<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局前置守卫**</span> :<br><br><span class="hljs-bullet">-</span> 使用 <span class="hljs-code">`router.beforeEach((to,from,next)=&gt;&#123;&#125;)`</span> 注册一个全局前置守卫<br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-strong">**`to: Route`**</span>: 即将要进入的目标 [<span class="hljs-string">路由对象</span>](<span class="hljs-link">https://router.vuejs.org/zh/api/#路由对象</span>)<br><br><span class="hljs-strong">**`from: Route`**</span>: 当前导航正要离开的路由<br><br><span class="hljs-strong">**`next: Function`**</span>: 一定要调用该方法来 <span class="hljs-strong">**resolve**</span> 这个钩子。执行效果依赖 <span class="hljs-code">`next`</span> 方法的调用参数。<br><br> 不执行 next 函数,无法继续运行<br><br><span class="hljs-bullet">-</span> next()   next(false)   next(&#x27;/&#x27;)  <span class="hljs-code">`next(error)`</span> 四类不同的调用方式<br><br><span class="hljs-bullet">-</span> 确保 <span class="hljs-code">`next`</span> 函数在任何给定的导航守卫中都被严格调用一次。他可以出现多次但只能调用一次, <br><br><span class="hljs-bullet">-</span> &gt; <span class="hljs-code">` RangeError: Maximum call stack size exceeded`</span> <br><br>注意无限递归问题 ,因为不加判断条件往往导致无限递归 <br><br> <br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局解析守卫**</span> :  <span class="hljs-code">`router.beforeResolve`</span> 注册一个全局守卫。<br><br><span class="hljs-bullet">-</span> &gt; 和<span class="hljs-code">`router.beforeEach`</span> 类似, 区别在于 调用顺序的不同   待拓展...<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**全局后置钩子**</span> : <span class="hljs-code">`router.afterEach((to, from) =&gt; &#123;&#125;`</span> , 这些钩子和守卫不同, 不会接受 <span class="hljs-code">`next`</span>函数自然不会改变导航本身, ，一般用于路由页面加载完毕之后操作一些动作，比如取消 loading<br><br><br><br><span class="hljs-strong">**路由独享的守卫**</span>:<br><br><span class="hljs-bullet">-</span> 在路由配置上直接定义 <span class="hljs-code">`beforeEnter`</span> 守卫：<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```js</span><br><span class="hljs-code"> const router = new VueRouter(&#123;</span><br><span class="hljs-code">   routes: [</span><br><span class="hljs-code">     &#123;</span><br><span class="hljs-code">       path: &#x27;/foo&#x27;,</span><br><span class="hljs-code">       component: Foo,</span><br><span class="hljs-code">       beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="hljs-code">         // ...</span><br><span class="hljs-code">       &#125;&#125;]&#125;)</span><br><span class="hljs-code"> // 这些守卫与全局前置守卫的方法参数是一样的。</span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><blockquote><p>路由中配置的守卫, 当从该路由跳转  或者进入该路由调用守卫</p></blockquote></li></ul><p><strong>组件内的守卫:</strong></p><ul><li><pre><code class="js">const Foo = &#123;  template: `...`,  beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  &#125;&#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- beforeRouteEnter 守卫不能 访问 `this`, 不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫<br><br>- ```<br>  beforeRouteEnter (to, from, next) &#123;<br>    next(vm =&gt; &#123;<br>      // 通过 `vm` 访问组件实例<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>导航守卫钩子函数的执行顺序  : <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">#</a>完整的导航解析流程 </p></li></ul><h4 id="路由元信息-过渡效果"><a href="#路由元信息-过渡效果" class="headerlink" title="路由元信息  过渡效果"></a>路由元信息  过渡效果</h4><ul><li><p>定义路由的时候可以配置 <code>meta</code> 字段, 一般设置为对象</p></li><li><p>过渡效果:</p></li><li><pre><code class="html">&lt;transition name=&quot;fade&quot;&gt;&lt;router-view/&gt;&lt;/transition&gt;//Transition 的所有功能 在这里同样适用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>- 单个路由的过渡: 在路由组件上使用<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br><br>- ```<br>  const Foo = &#123;<br>    template: `<br>      <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slide&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>    `<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>基于当前路由与目标路由的变化关系,动态设置过渡</p></li><li><pre><code class="html">&lt;transition :name=&quot;transitionName&quot;&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;接着在父组件内// watch $route 决定使用哪种过渡watch: &#123;  &#39;$route&#39; (to, from) &#123;   const toDepth = to.path.split(&#39;/&#39;).length...&#125;</code></pre></li></ul>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>#### 数据获取<br><br>- 有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：<br><br>- &gt; 1. **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。<br>  &gt; 2. **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。<br><br><br><br>#### 滚动行为  路由懒加载<br><br>滚动行为:<br><br>- 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样<br><br>- &gt; **注意: 这个功能只在支持 `history.pushState` 的浏览器中可用。**<br><br>- ```js<br>  const router = new VueRouter(&#123;<br>    routes: [...],<br>    scrollBehavior (to, from, savedPosition) &#123;<br>    if (savedPosition) &#123;<br>      return savedPosition  //保存之前的位置  通过浏览器的 前进/后退 按钮触发<br>    &#125; else &#123;<br>      return &#123; x: 0, y: 0 &#125;<br>    &#125;<br>      // return 期望滚动到哪个的位置<br>    &#125;<br>  &#125;)<br>  //  <br></code></pre></td></tr></table></figure><ul><li><p>路由懒加载 : 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p></li><li><pre><code class="js">&#123; path: &#39;/about&#39;, name: &#39;About&#39;, component: () =&gt; import(&#39;../views/About.vue&#39;) &#125;</code></pre></li></ul><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/js%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/12/14/Js-dom/js%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><ul><li><p><strong>传统网页的网络请求:</strong></p></li><li><p>最初加载页面很简单 – 你为网站发送一个请求到服务器， 只要没有出错你将会获取资源并显示网页到你的电脑上。</p></li><li><blockquote><p>这种方法导致不管 用户是否需要全部数据,都会重新加载整个页面</p><p>例如 : </p><p>填写表单时错误,跳转网页后重定向回注册表单,但是信息消失</p><p>只需要加载部分内容,(例如:导航栏侧边栏一样不在加载),但仍然会加载整个页面,导致资源浪费</p></blockquote></li></ul><ul><li>这时出现了AJAX技术, 允许网页请求小块数据,实现局部刷新而不是重新加载</li></ul><h2 id="AJAX-Asynchronous-JavaScript-and-XML-早期称呼"><a href="#AJAX-Asynchronous-JavaScript-and-XML-早期称呼" class="headerlink" title="AJAX (Asynchronous JavaScript and XML 早期称呼)"></a>AJAX (Asynchronous JavaScript and XML 早期称呼)</h2><ul><li><p>使用诸如 <strong>XMLHttpRequest</strong> 之类的API或者<strong>Fetch API</strong> 来实现,这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。</p></li><li><p><strong>AJAX原理:</strong></p></li><li><blockquote><p>通过xml /fetch api 作为中间件, 帮客户端发送数据,接收数据,使客户端可以做其他的事,数据接收之后再进行处理,不再堵塞等待数据</p></blockquote></li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><ul><li><p>在现代 Web 开发中，出于以下三种原因，我们还在使用 XMLHttpRequest：</p></li><li><blockquote><p>我们需要支持现有的使用了 XMLHttpRequest 的脚本。<br>我们需要兼容旧浏览器，并且不想用 polyfill（例如为了使脚本更小）。<br>我们需要做一些 fetch 目前无法做到的事情，例如跟踪上传进度。</p></blockquote></li></ul><h5 id="异步网络请求过程"><a href="#异步网络请求过程" class="headerlink" title="异步网络请求过程"></a>异步网络请求过程</h5><ul><li><ol><li><em>建立连接</em>:</li></ol></li><li><pre><code class="javascript">let xhr = new XMLHttpRequest();xhr.open(method, URL, [async, user, password])// open 调用与其名称相反，不会建立连接。它仅配置请求，而网络活动仅以 send 调用开启, xhr.send([body])// 可选参数 body 包含了 request body。像例如post传递才需要,get没有body<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">  <br>- &gt; method —— HTTP 方法。通常是 <span class="hljs-string">&quot;GET&quot;</span> 或 <span class="hljs-string">&quot;POST&quot;</span>。<br>  &gt;<br>  &gt; <span class="hljs-built_in">URL</span> —— 要请求的 <span class="hljs-built_in">URL</span>，通常是一个字符串，也可以是 <span class="hljs-built_in">URL</span> 对象。<br>  &gt; async —— 如果显式地设置为 <span class="hljs-literal">false</span>，那么请求将会以同步的方式处理，我们稍后会讲到它。<br>  &gt; user，password —— HTTP 基本身份验证（如果需要的话）的登录名和密码。  如果填写该功能 请求地址会加上该参数   `<span class="hljs-keyword">http</span>://user:pass@domain.com` 类似这种,但是有些浏览器可能不支持 ,<br>&gt;<br>  &gt; 这时我们需要在<span class="hljs-built_in">open</span> 方法之后 设置头setRequestHeader(<span class="hljs-string">&quot;Authorization&quot;</span>,..)<br>  <br>- &gt; 如果在 <span class="hljs-built_in">open</span> 方法中将第三个参数 async 设置为 <span class="hljs-literal">false</span>，那么请求就会以**同步的方式进行**。JavaScript 执行在 <span class="hljs-built_in">send</span>() 处暂停，并在收到响应后恢复执行。这有点儿像 alert 或 prompt 命令<br><br><br><br>- <span class="hljs-number">2.</span> *监听事件*<br><br>- 网络请求是异步的,所以我们需要监听`xhr`事件来获取响应:<br><br>- ```js<br>  xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>() &#123;&#125;</span><br>  xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">event</span>)&#123;&#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p> load —— 当请求完成（即使 HTTP 状态为 400 或 500 等），并且响应已完全下载。<br>  error —— 当无法发出请求，例如网络中断或者无效的 URL。<br>  progress —— 在下载响应期间定期触发，报告已经下载了多少。progerss 事件存在两个对象属性 event.loaded 已经下载了多少字节  event.total 总字节数</p></blockquote></li></ul><ul><li><ol start="3"><li><em>获得数据</em></li></ol></li></ul><ul><li><p>一旦服务器有了响应，我们可以在以下 <strong>xhr 属性中</strong>接收结果：</p></li><li><pre><code class="js"> xml.onload=function()&#123;   if(xml.status ==200)&#123;     console.log(xml.responseText);   &#125;<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> &gt;status  : HTTP 状态码（一个数字）：<span class="hljs-number">200</span>，<span class="hljs-number">404</span>，<span class="hljs-number">403</span> 等，如果出现非 HTTP 错误，则为 <span class="hljs-number">0</span>。</span><br><span class="ruby">  &gt;</span><br><span class="ruby">  &gt;statusText : HTTP 状态消息（一个字符串）：状态码为 <span class="hljs-number">200</span> 对应于 OK，<span class="hljs-number">404</span> 对应于 Not Found，<span class="hljs-number">403</span> 对应于 Forbidden。</span><br><span class="ruby">  &gt;</span><br><span class="ruby">  &gt;response（旧脚本可能用的是 responseText）  : 服务器的 response body。</span><br><span class="ruby">  </span><br><span class="ruby">  </span><br><br><span class="ruby">- **xhr 其他属性<span class="hljs-symbol">:**</span></span><br><br><span class="ruby">- <span class="hljs-string">`timeout属性`</span> 指定超时：xhr.timeout = <span class="hljs-number">10000</span>;  <span class="hljs-regexp">//</span> timeout 单位是 ms，此处即 <span class="hljs-number">10</span> 秒, 如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件。</span><br><br><span class="ruby">- <span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="ruby">  xhr.timeout = <span class="hljs-number">10000</span>;   <span class="hljs-regexp">//</span> 在建立连接时设置使用, 在监听事件时监听 timeout事件</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>**<code>xhr.responseType 属性</code>**来设置响应格式：</p></li><li><pre><code class="js">xhr.responseType = &#39;json&#39;;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- &gt;&quot;&quot;（默认）—— 响应格式为字符串，<br>  &gt;&quot;text&quot; —— 响应格式为字符串，<br>  &gt;&quot;arraybuffer&quot; —— 响应格式为 ArrayBuffer（对于二进制数据，请参见 ArrayBuffer，二进制数组），<br>  &gt;&quot;blob&quot; —— 响应格式为 Blob（对于二进制数据，请参见 Blob），<br>  &gt;&quot;document&quot; —— 响应格式为 <span class="hljs-type">XML</span> document（可以使用 XPath 和其他 <span class="hljs-type">XML</span> 方法），<br>  &gt;&quot;json&quot; —— 响应格式为 <span class="hljs-type">JSON</span>（自动解析）。<br>  &gt;<br>  &gt;<br>  &gt;<br>  &gt;使用response属性, 通过设置responseType 属性,会进行自动解析, 获取响应后可以直接使用<br>&gt;<br>  &gt;老的脚本使用 responseTEXT  responseXML 获取响应, 响应只以文本字符/<span class="hljs-type">xml</span>的形式返回 , 使用时要进行解析  <br><br>  <br><br>- **`XMLHttpRequest` 的state属性**<br><br>- XMLHttpRequest 的状态（state）会随着它的处理进度变化而变化。可以通过 **xhr.readyState** 来了解当前状态。<br><br>- &gt; UNSENT = <span class="hljs-number">0</span>; // 初始状态<br>  &gt; OPENED = <span class="hljs-number">1</span>; // <span class="hljs-keyword">open</span> 被调用<br>  &gt; HEADERS_RECEIVED = <span class="hljs-number">2</span>; // 接收到 response <span class="hljs-keyword">header</span><br>  &gt; LOADING = <span class="hljs-number">3</span>; // 响应正在被加载（接收到一个数据包）<br>  &gt; DONE = <span class="hljs-number">4</span>; // 请求完成<br>  &gt;<br>  &gt; XMLHttpRequest 对象以 <span class="hljs-number">0</span> → <span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → … → <span class="hljs-number">3</span> → <span class="hljs-number">4</span> 的顺序在它们之间转变。每当通过网络接收到一个数据包，就会重复一次状态 <span class="hljs-number">3</span>。我们可以使用 readystatechange 事件来跟踪它们：<br>- &gt; readystatechange 事件 存在于很老的代码中, 现在被<span class="hljs-keyword">load</span>/error/progress事件替代<br><br><br><br><br>- 调用 `xhr.<span class="hljs-keyword">abort</span>()` ,  我们可以随时**终止请求**。<br><br><br><br>- XMLHttpRequest 允许发送自定义 <span class="hljs-keyword">header</span>，并且可以从响应中读取 <span class="hljs-keyword">header</span>。<br><br>  ```javascript<br>  setRequestHeader(<span class="hljs-type">name</span>, <span class="hljs-keyword">value</span>), //使用给定的 <span class="hljs-type">name</span> 和 <span class="hljs-keyword">value</span> 设置 request <span class="hljs-keyword">header</span>。<br>  xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>  <br>  getResponseHeader(<span class="hljs-type">name</span>) : 获取具有给定 <span class="hljs-type">name</span> 的 <span class="hljs-keyword">header</span>（<span class="hljs-keyword">Set</span>-Cookie 和 <span class="hljs-keyword">Set</span>-Cookie2 除外）。<br>  getAllResponseHeaders()  返回除 <span class="hljs-keyword">Set</span>-Cookie 和 <span class="hljs-keyword">Set</span>-Cookie2 外的所有 response <span class="hljs-keyword">header</span>。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>一些 header 是由浏览器专门管理的，例如 Referer 和 Host 为了用户安全和请求的正确性，XMLHttpRequest 不允许更改它们。</p><p>XMLHttpRequest 的另一个特点是不能撤销 setRequestHeader。一旦设置了 header，就无法撤销了。其他调用会向 header 中添加信息，但不会覆盖它</p><p>xhr.setRequestHeader(‘X-Auth’, ‘123’);<br>xhr.setRequestHeader(‘X-Auth’, ‘456’);</p></blockquote></li></ul><h5 id="post方法-和-FormData-对象"><a href="#post方法-和-FormData-对象" class="headerlink" title="post方法 和 FormData 对象:"></a><strong>post方法 和 FormData 对象:</strong></h5><ul><li><p>建立一个 POST 请求，可以使用内建的 FormData 对象来传递信息</p></li><li><pre><code class="javascript">let formData = new FormData([form]); // 创建一个对象，可以选择从 &lt;form&gt; 中获取数据 formData.append(name, value); // 附加一个字段formData.append(&quot;middle&quot;, &quot;Lee&quot;); xhr.open(&#39;POST&#39;, ...);xhr.send(formData); // 将表单发送到服务器。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <br>- &gt; send发送 FormData 对象,它会自动以 Content-<span class="hljs-keyword">Type</span>: multipart/form-data 发送数据,不用在设置Content-<span class="hljs-keyword">Type</span><br>  <br><br>  <br>- **post方法:**<br><br>- 如果我们想用其他的数据类型发送,那就不再使用FormData 对象,使用普通的post即可,但是不要忘记`Content-<span class="hljs-keyword">Type</span>`: <br><br>- &gt; 因为客户端只能发送字符串格式, 设置`Content-<span class="hljs-keyword">Type</span>`告诉服务器你发送的数据是什么格式的，然后服务器才能以对应格式解析请求.  <br><br>- ```js<br>  let <span class="hljs-type">json</span> = <span class="hljs-type">JSON</span>.stringify(&#123;<br>    <span class="hljs-type">name</span>: &quot;John&quot;,<br>    surname: &quot;Smith&quot;<br>  &#125;);<br>  <br>  xhr.<span class="hljs-keyword">open</span>(&quot;POST&quot;, <span class="hljs-string">&#x27;/submit&#x27;</span>)<br>  xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>);<br>  <br>  xhr.send(<span class="hljs-type">json</span>);<br>  // 如果我们更喜欢 <span class="hljs-type">JSON</span>，那么可以使用 `<span class="hljs-type">JSON</span>.stringify` 并以字符串形式发送( 客户端只能发送字符串)但是不要忘记设置 <span class="hljs-keyword">header</span> `Content-<span class="hljs-keyword">Type</span>: application/<span class="hljs-type">json</span>`<br>  // *<span class="hljs-string">&#x27;Content-type&#x27;</span>,<span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>* 发送 <span class="hljs-string">&#x27;name=fef&amp;age=23&#x27;</span>格式数据<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><strong>.send(body) 方法,它几乎可以发送任何 body</strong>，包括 Blob 和 BufferSource 对象。</li></ul><h5 id="上传进度"><a href="#上传进度" class="headerlink" title="上传进度:"></a><strong>上传进度:</strong></h5><ul><li><p>也就是说：如果我们 POST 一些内容，XMLHttpRequest 首先上传我们的数据（request body），然后下载响应。如果我们要上传的东西很大，那么我们肯定会对跟踪上传进度感兴趣。但是 xhr.onprogress 在这里并不起作用。(progress 事件仅在下载阶段触发。)</p></li><li><p>xhr.upload。它会生成事件，类似于 xhr，但是 xhr.upload 仅在上传时触发它们：</p></li><li><blockquote><p>loadstart —— 上传开始。<br>progress —— 上传期间定期触发。<br>abort —— 上传中止。<br>error —— 非 HTTP 错误。<br>load —— 上传成功完成。<br>timeout —— 上传超时（如果设置了 timeout 属性）。<br>loadend —— 上传完成，无论成功还是 error。</p></blockquote></li><li><pre><code class="js">xhr.upload.onprogress = function(event) &#123;alert(`Uploaded $&#123;event.loaded&#125; of $&#123;event.total&#125; bytes`);&#125;;<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs http"><br>  <br><br>- &gt; xhr 自身还具有 上述事件,(不需要调用.upload属性)<br>  &gt; loadstart —— 请求开始。<br>    &gt; progress —— 一个响应数据包到达，此时整个 response body 都在 response 中。<br>    &gt; abort —— 调用 xhr.abort() 取消了请求。<br>    &gt; error —— 发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。<br>    &gt; load —— 请求成功完成。<br>    &gt; timeout —— 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。<br>    &gt; loadend —— 在 load，error，timeout 或 abort 之后触发。<br>    &gt;<br>    &gt; <br>    &gt;<br>    &gt; error，abort，timeout 和 load 事件是互斥的。其中只有一种可能发生。<br>  <br>    <br><br>##### **带有凭证的跨源请求:**<br><br>- XMLHttpRequest 可以使用和 fetch 相同的 CORS 策略进行跨源请求。<br><br>- &gt; 就像 fetch 一样，默认情况下不会将 cookie 和 HTTP 授权发送到其他域。<br>  &gt;<br>  &gt; 要启用它们，可以将 xhr.withCredentials 设置为 true, 服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true。<br><br><br><br>#### Fetch<br><br><br><br>#####   网络连接过程<br><br>- 1. 建立连接<br><br>- 基本语法 :<br><br>- ```js<br>  let promise = fetch(url, [options])<br>  // options —— 可选参数：method，header , body等,<br>  //没有 options，那就是一个简单的 GET 请求，下载 url 的内容。<br>  <br>  fetch(url, &#123;<br>      body: JSON.stringify(data), <br>      headers: &#123;<br>        &#x27;content-type&#x27;: &#x27;application/json&#x27;<br>      &#125;,<br>      method: &#x27;POST&#x27;,<br>      ....<br>      &#125;)<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><ol start="2"><li>获取响应 (promise 的原因不再监听事件)</li></ol></li></ul><ul><li><blockquote><p>获取响应通常需要经过两个阶段:</p><p><strong>第一阶段</strong>，当<strong>服务器</strong>发送了响应头（response header），fetch 返回的 promise 就使用内建的 <strong>Response class</strong> 对象来对响应头进行解析。 请求成功相当于 promise resolve(Response class),失败相当于reject(Response class)</p><p>在这个阶段，我们可以通过检查响应头，来检查 HTTP 状态以确定请求是否成功，当前还没有响应体</p><p>我们可以在 response 的属性中看到 HTTP 状态：</p><ul><li><strong><code>status</code></strong> —— HTTP 状态码，例如 200。</li><li><strong><code>ok</code></strong> —— 布尔值，如果 HTTP 状态码为 200-299，则为 <code>true</code>。</li></ul></blockquote></li><li><pre><code class="js">let response = await fetch(url);if (response.ok) &#123; // 如果 HTTP 状态码为 200-299  // 获取 response body（此方法会在下面解释）  let json = await response.json();&#125; else &#123;  alert(&quot;HTTP-Error: &quot; + response.status);&#125;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> &gt; **第二阶段**，为了获取 **<span class="hljs-selector-tag">response</span> <span class="hljs-selector-tag">body</span>**，我们需要使用一个其他的方法调用。`<span class="hljs-selector-tag">Response</span>` 提供了多种基于 <span class="hljs-selector-tag">promise</span> 的方法，来以不同的格式访问 <span class="hljs-selector-tag">body</span>：<br>  &gt;<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.text</span>() ——读取 <span class="hljs-selector-tag">response</span>，并以文本形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.json</span>() —— 将 <span class="hljs-selector-tag">response</span> 解析为 <span class="hljs-selector-tag">JSON</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.formData</span>() —— 以 <span class="hljs-selector-tag">FormData</span> 对象（在 下一章 有解释）的形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.blob</span>() —— 以 <span class="hljs-selector-tag">Blob</span>（具有类型的二进制数据）形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt; <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.arrayBuffer</span>() —— 以 <span class="hljs-selector-tag">ArrayBuffer</span>（低级别的二进制数据）形式返回 <span class="hljs-selector-tag">response</span>，<br>  &gt;<br>  &gt; <br>  &gt;<br>  &gt; 我们只能选择一种读取 <span class="hljs-selector-tag">body</span> 的方法。 多种后面的会失效<br><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">js</span><br>  <span class="hljs-comment">//使用纯promise语法演示</span><br>  <br>  <span class="hljs-selector-tag">fetch</span>(<span class="hljs-string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#x27;</span>)<br>    <span class="hljs-selector-class">.then</span>(response =&gt; response.json())<br>    <span class="hljs-selector-class">.then</span>(commits =&gt; alert(commits[<span class="hljs-number">0</span>].author.login));<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li>如果 fetch 无法建立一个 HTTP 请求，例如网络问题，亦或是请求的网址不存在，那么 promise 就会 reject。异常的 HTTP 状态，例如 404 或 500，不会导致出现 error。 导致try catch 无法处理</li></ul><h5 id="Response-request-header"><a href="#Response-request-header" class="headerlink" title="Response/request header:"></a>Response/request header:</h5><ul><li><p><strong>Response header</strong> :</p></li><li><p>response.headers 返回一个类似于 Map 的 header 对象,可以使用Map类似的方法,headers相当于response  class的属性</p></li><li><pre><code class="js">let response = await fetch(&#39;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#39;);// 获取一个 header　alert(response.headers.get(&#39;Content-Type&#39;)); <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- **request <span class="hljs-keyword">header</span>:**<br><br>- 使用<span class="hljs-keyword">fetch</span>方法中<span class="hljs-keyword">option</span>参数 中 headers 选项设置请求头<br><br>- ```js<br>  let response = <span class="hljs-keyword">fetch</span>(protectedUrl, &#123;<br>    headers: &#123;<br>      Authentication: <span class="hljs-string">&#x27;secret&#x27;</span><br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>但是有一些我们无法设置的headers , 它们仅由浏览器控制, 详见 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name">forbidden HTTP headers</a></p></blockquote></li></ul><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求:"></a><strong>POST请求:</strong></h5><ul><li><pre><code class="js">let response = await fetch(&#39;/article/fetch/post/user&#39;, &#123;  method: &#39;POST&#39;,  headers: &#123;    &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;  &#125;,  body: JSON.stringify(user)&#125;);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 请注意，如果请求的 `body` 是字符串，则 `Content-Type` 会默认设置为 `text/plain<span class="hljs-comment">;charset=UTF-8`。 所以我们发送数据时要显式的设置  `Content-Type`.</span><br><br>- &gt; **body** —— request body，其中之一：<br>  &gt;<br>  &gt; 字符串（例如 JSON 编码的），<br>  &gt;<br>  &gt; FormData` 对象，以 `form/multipart` 形式发送数据，<br>  &gt;<br>  &gt; Blob`/`BufferSource` 发送二进制数据，<br>  &gt;<br><span class="hljs-title">  &gt; URLSearchParams](https:</span>//zh.javascript.info/url)，以 `x-www-form-urlencoded` 编码形式发送数据，很少使用<br><br><br><br><span class="hljs-title">#### **Fetch：下载进度:</span>**<br><br>- fetch 方法允许去跟踪下载进度,  到目前为止，fetch 方法无法跟踪 上传 进度。对于这个目的，请使用 XMLHttpRequest<br><br>- &gt; 要跟踪下载进度，我们可以使用 response.body 属性。它返回一个 ReadableStream 特殊的对象，它可以逐块（chunk）提供 body <br><br>- `response.body.getReader()`返回读取器,具备两个属性<br><br>- &gt; - **`done`** —— 当读取完成时为 `true`，否则为 `false`。<br>  &gt;<br>  &gt; - **`value`** —— 字节的类型化数组：`Uint8Array`。<br>  &gt;<br>  &gt;   我们在循环中接收响应块（response chunk），直到加载完成，也就是：直到 `done` 为 `true`。<br>- ```<br>  // 获得总长度（length）<br>const contentLength = +response.headers.get(&#x27;Content-Length&#x27;)<span class="hljs-comment">;</span><br>  // 通过计算读取器的属性 value.length    两者的比例就是下载的进度<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="fetch-终止"><a href="#fetch-终止" class="headerlink" title="fetch 终止:"></a><strong>fetch 终止:</strong></h4><ul><li><p><code>fetch</code> 返回一个 promise。JavaScript 通常并没有“中止” promise 的概念。使用<code>AbortController</code>。它不仅可以中止 <code>fetch</code>，还可以中止其他异步任务</p></li><li><p>创建控制器 (作用于普通的异步任务):</p></li><li><pre><code class="js">let controller = new AbortController();// controller 它具有单个方法 abort()，和单个属性 signal。// 当 abort() 被调用时：abort 事件就会在 controller.signal 上触发,  controller.signal.aborted 属性变为 true。// 在promise中注册事件 controller.signal.addEventListener(&#39;abort&#39;, ...);//调用 controller.abort() ,终止promise<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs">  <br><br>  <br>- 控制器和fetch一起使用:<br><br>- ```js<br>  let controller = new AbortController();<br>  fetch(url, &#123;<br>    signal: controller.signal<br>  &#125;);<br>  controller.abort();<br>  // 调用 controller.abort() 来中止fetch 请求<br>  //当一个 fetch 被中止，它的 promise 就会以一个 error AbortError reject<br></code></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>AbortController 是可扩展的，它允许一次取消多个 fetch。使用promise.all 并行请求url,将 signal 属性传递给 fetch 选项, 调用abort()函数可以终止请求</p></li><li><p>如果我们有自己的与 fetch 不同的异步任务(自己新建一个promise任务)，我们可以使用单个 AbortController 中止这些任务以及 fetch。</p></li></ul><h4 id="Fetch-API选项"><a href="#Fetch-API选项" class="headerlink" title="Fetch API选项"></a>Fetch API选项</h4><ul><li><p>这些选项 (option) 大多都很少使用。即使跳过本章，你也可以很好地使用 fetch。</p></li><li><p>这是所有可能的 fetch 选项及其默认值（注释中标注了可选值）的完整列表：</p></li><li><pre><code class="javascript">let promise = fetch(url, &#123;  method: &quot;GET&quot;, // POST，PUT，DELETE，等。  headers: &#123;    // 内容类型 header 值通常是自动设置的    // 取决于 request body    &quot;Content-Type&quot;: &quot;text/plain;charset=UTF-8&quot;  &#125;,  body: undefined // string，FormData，Blob，BufferSource，或 URLSearchParams  referrer: &quot;about:client&quot;, // 或 &quot;&quot; 以不发送 Referer header，  // 或者是当前源的 url  referrerPolicy: &quot;no-referrer-when-downgrade&quot;, // no-referrer，origin，same-origin...  mode: &quot;cors&quot;, // same-origin，no-cors  credentials: &quot;same-origin&quot;, // omit，include  cache: &quot;default&quot;, // no-store，reload，no-cache，force-cache，或 only-if-cached  redirect: &quot;follow&quot;, // manual，error  integrity: &quot;&quot;, // 一个 hash，像 &quot;sha256-abcdef1234567890&quot;  keepalive: false, // true  signal: undefined, // AbortController 来中止请求  window: window // null&#125;);<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br>- referrer，referrerPolicy , 这些选项决定了 fetch 如何设置 HTTP 的 Referer header。<br><br>- mode 选项是一种安全措施，可以防止偶发的跨源请求：<br><br>- credentials 选项指定 fetch 是否应该随请求发送 cookie 和 HTTP-Authorization header<br><br>- 使用 cache 选项可以忽略 HTTP 缓存或者对其用法进行微调<br><br>- 通常来说，fetch 透明地遵循 HTTP 重定向，例如 301，302 等。redirect 选项允许对此进行更改<br><br>- integrity 选项允许检查响应是否与已知的预先校验和相匹配<br><br>- keepalive   当访问者离开我们的网页时 —— 我们希望能够将数据保存到我们的服务器上。keepalive 选项告诉浏览器，即使在离开页面后，也要在后台执行请求。所以，此选项对于我们的请求成功至关重要。<br><br><br><br>####  跨源请求 和 CORS(跨源资源共享)<br><br>- **跨源请求** —— 那些发送到其他域（即使是子域）、协议或端口的请求<br><br>- 跨源域资源共享（ [CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行<br><br><br><br>- **跨源请求方法 :**<br><br>- `“JSONP (JSON with padding)”`协议:<br><br>- 原理: **script可以具有任何域的 src**, 使用jsonp必须需要服务器端支持,后端接口要改变返回的数据格式才行,数据格式不能是`applicition/ json` 应该为`text/javascript` , 格式设置错误显示`MIME 类型（“application/json”）不是有效的 JavaScript MIME 类型`<br><br>  <br><br>- 方法:<br><br>- &gt; 1.我们先声明一个全局函数gotWeather(...)来接收数据<br>  &gt;<br>  &gt; 2.我们动态创建一个`&lt;script&gt;` 标签 ,属性`src=&quot;http://another.com/weather.json?callback=gotWeather&quot;` 的，使用我们的函数名作为它的 `callback` URL-参数<br>  &gt;<br>  &gt; 3.**服务器端**处理请求,传递`callback(...)`的**字符串**，实际上传给客户端的是gotWeather字符串, 参数里写我们服务器端想要传递的数据,把字符串传递给客户端<br>  &gt;<br>  &gt; 4.当远程脚本加载并执行时，客户端找到`gotWeather` 函数运行，我们也获得了需要的数据。<br><br>- 现在仍然有提供这种访问的服务，因为即使是非常旧的浏览器它依然适用<br><br><br><br>- `CORS`跨源资源共享:<br><br>- **有两种类型的跨源请求**：<br><br>- &gt; 1. 简单的请求。 <br>  &gt; 2.  所有其他请求。<br><br>-  `简单的请求`:   简单的方法：GET，POST 或 HEAD,  简单的 header —— 仅允许自定义下列 header：<br>  <br>- &gt; ​    Accept，<br>  &gt; ​    Accept-Language，<br>  &gt; ​    Content-Language，<br>  &gt; ​    Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。<br><br>- &gt; **本质区别在于，可以使用 `&lt;form&gt;` 或 `&lt;script&gt;` 进行“简单请求”，而无需任何其他特殊方法。**因此，即使是非常旧的服务器也能很好地接收简单请求。<br><br>  <br><br>- `所有其他请求`: 任何其他请求都被认为是“非简单请求”。例如，具有 PUT 方法或 API-Key HTTP-header 的请求就不是简单请求。<br><br>- &gt; 当我们尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器 —— 询问服务器，你接受此类跨源请求吗？并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送。<br><br>  <br><br>- **简单请求的CORS:**<br><br>- 如果一个请求是跨源的，浏览器始终会向其添加 `Origin` header。`Origin` 包含了确切的源（domain/protocol/port）, 服务器可以检查 `Origin`，如果同意接受这样的请求，就会在响应中添加一个特殊的 header `Access-Control-Allow-Origin`。该 header 包含了允许的源,或者一个星号 `*`。然后响应成功，否则报错。<br><br>- 浏览器扮演受信任的中间人的角色:<br><br>- &gt; 1.确保发送的跨源请求带有正确的orgin,<br>  &gt;<br>  &gt;  2.它检查响应中的许可 Access-Control-Allow-Origin(包含一个源,或者*)，如果存在，则允许 JavaScript 访问响应，否则将失败并报错。<br><br><br>- 对于跨源请求，默认情况下，JavaScript 只能访问“简单” response header：<br>  <br>- &gt; Cache-Control<br>    &gt; Content-Language<br>    &gt; Content-Type<br>    &gt; Expires<br>    &gt; Last-Modified<br>    &gt; Pragma<br>    &gt; 访问任何其他 response header 都将导致 error<br><br>    <br>  <br>- 要授予 JavaScript 对任何其他 response header 的访问权限，服务器必须发送 Access-Control-Expose-Headers  header。<br><br><br><br><br>- **非简单的跨源请求:**<br><br>- 我们可以使用任何 HTTP 方法：不仅仅是 GET/POST，也可以是 PATCH，DELETE 及其他。可能仍然存在有些 Web 服务将非标准方法视为一个信号,为了避免误解，任何“非标准”请求 —— 浏览器不会立即发出,即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可。<br><br>- 预检请求 :使用 OPTIONS 方法，它没有 body，但是有两个 header：<br><br>- &gt; Access-Control-Request-Method header 带有非简单请求的方法。<br>  &gt; Access-Control-Request-Headers header 提供一个以逗号分隔的非简单 HTTP-header 列表。<br><br>- 预检响应 :如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：<br><br>- &gt; Access-Control-Allow-Methods 必须具有允许的方法。<br>  &gt; Access-Control-Allow-Headers 必须具有一个允许的 header 列表。<br><br>- 预检成功后，浏览器现在发出主请求, 然后才是实际响应<br><br>- &gt; 预检响应会缓存一段时间，该时间由 `Access-Control-Max-Age` header 指定,因此，后续请求将不会导致预检<br><br>- 实际响应中也要添加`Access-Control-Allow-Origin`。成功的预检并不能免除此要求<br><br>- &gt; 预检请求发生在“幕后”，它对 JavaScript 不可见。<br><br>  <br><br>**带有凭据(cookie https的请求):**<br><br>- 默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。<br><br>- &gt; 要在 fetch 中发送凭据，我们需要添加 credentials: &quot;include&quot; 选项, <br>  &gt;<br>  &gt; 如果服务器同意接受 带有凭据 的请求，则除了 Access-Control-Allow-Origin 外，服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true。<br>- &gt; 对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 *。它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁<br><br>  <br><br>- 拓展: 服务器方法绕过同源检测<br><br>- &gt;  同源策略只存在于ajax,不存在与服务器端开发:<br>  &gt;<br>  &gt; 1号网站客户端访问1号网站服务端, 1号服务器端访问2号服务端, 1号服务端把数据响应给1号客户端,此方法可以绕过同源策略<br><br>#### FormData<br><br>- 表示 HTML 表单数据的对象 ,传递表单中的数据, 带文件或不带文件<br><br>- ```js<br>  let formData = new FormData([form]);<br>  // 如果提供了 HTML form 元素，它会自动捕获 form 元素字段。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>FormData 的特殊之处在于网络方法（network methods），例如 fetch 可以接受一个 FormData 对象作为 body。它会被编码并发送出去，带有 Content-Type: multipart/form-data。从服务器角度来看，它就像是一个普通的表单提交。</p></blockquote></li></ul><ul><li><p>如果内容不是表单,我们也可以new FormData() , 然后通过append()添加,  然后发送,向一个普通表单一样发送</p></li><li><p>使用以下方法修改 FormData 中的字段：</p></li><li><blockquote><p>formData.append(name, value) —— 添加具有给定 name 和 value 的表单字段，<br>formData.append(name, blob, fileName) —— 添加一个字段，就像它是 <input type="file">，第三个参数 fileName 设置文件名（而不是表单字段名），因为它是用户文件系统中文件的名称，<br>formData.delete(name) —— 移除带有给定 name 的字段，<br>formData.get(name) —— 获取带有给定 name 的字段值，<br>formData.has(name) —— 如果存在带有给定 name 的字段，则返回 true，否则返回 false。</p></blockquote></li><li><blockquote><p>一个表单可以包含多个具有相同 name 的字段，因此，多次调用 append 将会添加多个具有相同名称的字段。</p></blockquote></li></ul><ul><li><p> set 方法，语法与 append 相同。不同之处在于 .set 移除所有具有给定 name 的字段，然后附加一个新字段,它确保了只有一个具有这种 <code>name</code> 的字段</p></li><li><blockquote><p>formData.set(name, value)，</p><p>formData.set(name, blob, fileName);</p></blockquote></li></ul><ul><li><p>我们也可以使用 for..of 循环迭代 formData 字段：</p></li><li><blockquote><p>for(let [name, value] of formData) </p><p>{  alert(<code>$&#123;name&#125; = $&#123;value&#125;</code> ); // key1=value1，然后是 key2=value2 }</p></blockquote></li></ul><h4 id="URL-对象"><a href="#URL-对象" class="headerlink" title="URL 对象"></a>URL 对象</h4><ul><li><p>内建的 URL 类提供了用于创建和解析 URL 的便捷接口。没有任何一个网络方法一定需要使用 URL 对象，字符串就足够了。</p></li><li><blockquote><p>new URL(url, [base])</p><p> base —— 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL。</p></blockquote></li><li><p>URL 对象立即允许我们访问其结构组成，因此这是一个解析 url 的好方法 :</p></li><li><blockquote><p>通过属性访问URL结构: </p><p>href 是完整的 URL，与 url.toString() 相同<br>host : hostname + port   域名加端口号<br>protocol 以冒号字符 : 结尾      协议(http…)<br>host+potocol  : origin<br>pathname : 路径名字, 端口后面的<br>search —— 以问号 ? 开头的一串参数  (请求传递的参数)<br>hash 以哈希字符 # 开头<br>如果存在 HTTP 身份验证，则这里可能还会有 user 和 password 属性：<a href="http://login:password@site.com/">http://login:password@site.com</a></p></blockquote></li><li><p>URL 对象可以替代字符串传递给任何方法，因为大多数方法都会执行字符串转换</p></li></ul><ul><li><p><strong>SearchParams “?…”</strong></p></li><li><p>我们想要创建一个具有给定搜索参数的 url，: new URL(‘<a href="https://google.com/search?query=JavaScript&#39;">https://google.com/search?query=JavaScript&#39;</a>) , 如果参数中包含空格，非拉丁字母等，<strong>参数就需要被编码。url.searchParams</strong> 属性解决问题, </p></li><li><blockquote><p>append(name, value) —— 按照 name 添加参数，<br>delete(name) —— 按照 name 移除参数，<br>get(name) —— 按照 name 获取参数，<br>getAll(name) —— 获取相同 name 的所有参数（这是可行的，例如 ?user=John&amp;user=Pete），<br>has(name) —— 按照 name 检查参数是否存在，<br>set(name, value) —— set/replace 参数，<br>sort() —— 按 name 对参数进行排序，很少使用，<br>……并且它是可迭代的，类似于 Map。</p></blockquote></li><li><pre><code class="javascript">let url = new URL(&#39;https://google.com/search&#39;);url.searchParams.set(&#39;tbs&#39;, &#39;qdr:y&#39;); // 添加带有一个冒号 : 的参数// 参数会被自动编码alert(url); // https://google.com/search?q=test+me%21&amp;tbs=qdr%3Ay</code></pre></li></ul><ul><li><p>如果我们不使用URL对象, 而是字符串就要手动对特殊字符进行编码 : </p><blockquote><p>下面是用于编码/解码 URL 的内建函数：</p></blockquote><p>  encodeURI —— 编码整个 URL。<br>  decodeURI —— 解码为编码前的状态。<br>  encodeURIComponent —— 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname。<br>  decodeURIComponent —— 解码为编码前的状态。</p></li></ul><h4 id="长轮询-websocket-Server-Sent-Events"><a href="#长轮询-websocket-Server-Sent-Events" class="headerlink" title="长轮询 websocket  Server Sent Events"></a>长轮询 websocket  Server Sent Events</h4><ul><li><p>常规轮询 : 从服务器获取新信息的最简单的方式是定期轮询。每个周期发送请求,看看服务器有没有信息<br>缺点:两个请求之间延迟是一个周期,不管有没有消息, 在一定时间服务器都会被请求轰炸</p></li><li><p>所谓“长轮询”是轮询服务器的一种更好的方式。它也很容易实现，并且可以无延迟地传递消息它不使用任何特定的协议，例如 WebSocket 或者 Server Sent Event。</p></li><li><p>其流程为：</p></li><li><blockquote><p>请求发送到服务器。<br>服务器在有消息之前不会关闭连接。<br>当消息出现时 —— 服务器将对其请求作出响应。<br>浏览器立即发出一个新的请求。</p><blockquote><p>对于此方法，浏览器发出一个请求并与服务器之间建立起一个挂起的（pending）连接的情况是标准的。仅在有消息被传递时，才会重新建立连接。</p></blockquote></blockquote></li><li><blockquote><p>如果连接丢失，可能是因为网络错误，浏览器会立即发送一个新请求。</p></blockquote></li></ul><p><strong>WebSocket:</strong> </p><ul><li><p> WebSocket 协议提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法。数据可以作为“数据包”在两个方向上传递，而不会断开连接和其他 HTTP 请求。</p></li><li><blockquote><p>对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，WebSocket 尤其有用。</p></blockquote></li></ul><ul><li><p> 语法: </p></li><li><blockquote><p>let socket = new WebSocket(“<em>ws</em>://javascript.info”);   // 同样也有一个加密的 <code>wss://</code> 协议。类似于 WebSocket 中的 HTTPS。 <code>wss://</code> 协议不仅是被加密的，而且更可靠</p></blockquote></li><li><p>一旦 socket 被建立，我们就应该监听 socket 上的事件。一共有 4 个事件：</p></li><li><blockquote><ul><li><strong><code>open</code></strong> —— 连接已建立，</li><li><strong><code>message</code></strong> —— 接收到数据，</li><li><strong><code>error</code></strong> —— WebSocket 错误，</li><li><strong><code>close</code></strong> —— 连接已关闭。</li></ul><p>想发送一些东西，那么可以使用 <code>socket.send(data)</code>。data:字符串或二进制格式无需设置直接发送, </p></blockquote></li><li><p>WebSocket 对象是原生支持跨源的。没有特殊的 header 或其他限制。旧的服务器无法处理 WebSocket，因此不存在兼容性问题。</p></li><li><p>WebSocket 通信由 “frames”（即数据片段）组成，可以从任何一方发送:</p></li><li><blockquote><p>有以下几种类型：</p><p>文本或二进制 frames……,浏览器中只是用二进制和文本类型</p></blockquote></li><li><p><strong>当我们收到数据时，文本总是以字符串形式呈现。而对于二进制数据，我们可以在 <code>Blob</code> 和 <code>ArrayBuffer</code> 格式之间进行选择。它是由 <code>socket.bufferType</code> 属性设置的，默认为 <code>&quot;blob&quot;</code>，</strong></p></li></ul><ul><li><p><strong>关闭连接:</strong></p></li><li><blockquote><p>当一方想要关闭连接时（浏览器和服务器都具有相同的权限），它们会发送一个带有数字码（numeric code）和文本形式的原因的 “connection close frame”。</p><p>socket.close([code], [reason]);</p><ul><li><code>code</code> 是一个特殊的 WebSocket 关闭码（可选）</li><li><code>reason</code> 是一个描述关闭原因的字符串（可选）</li></ul></blockquote></li><li><p><strong>连接状态:</strong></p></li><li><p>要获取连接状态，可以通过带有值的 <code>socket.readyState</code> 属性：</p></li><li><blockquote><ul><li><strong><code>0</code></strong> —— “CONNECTING”：连接还未建立，</li><li><strong><code>1</code></strong> —— “OPEN”：通信中，</li><li><strong><code>2</code></strong> —— “CLOSING”：连接关闭中，</li><li><strong><code>3</code></strong> —— “CLOSED”：连接已关闭。</li></ul></blockquote></li></ul><ul><li>在使用时,服务器端也有处理websocket的方法,要查看服务端的算法</li></ul><p><strong>Server-Sent Events:</strong></p><ul><li><p><a href="https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface">Server-Sent Events</a> 规范描述了一个内建的类 <code>EventSource</code>，它能保持与服务器的连接，并允许从中接收事件。与 <code>WebSocket</code> 类似，其连接是持久的。</p></li><li><p>和websocket区别:</p></li><li><blockquote><p>单向：仅服务端能发送消息</p><p>仅传输文本数据</p><p>使用常规的http协议</p></blockquote></li></ul><ul><li><p>我们为什么要使用它？主要原因：简单。在很多应用中，<code>WebSocket</code> 有点大材小用。</p></li><li><p>我们需要从服务器接收一个数据流：可能是聊天消息或者市场价格等。这正是 <code>EventSource</code> 所擅长的。它还支持自动重新连接，而在 <code>WebSocket</code> 中这个功能需要我们手动实现。此外，它是一个普通的旧的 HTTP，不是一个新协议</p></li><li><p><strong>链接过程</strong>:</p></li><li><blockquote><p>创建 <code>let eventSource = new EventSource(&quot;/events/subscribe&quot;);</code>, 开始接收消息,浏览器将会连接到 <code>url</code> 并保持连接打开，等待事件。</p><p>服务器响应状态码应该为 200，header 为 <code>Content-Type: text/event-stream</code>，然后保持此连接并以一种特殊的格式写入消息，对于每个这样的消息，传递时都会生成 <code>message</code> 事件:</p><p>eventSource.onmessage = function(event) </p></blockquote></li><li><p><code>EventSource</code> 支持跨源请求,就像 <code>fetch</code> 任何其他网络方法,应该设置附加选项 <code>withCredentials</code>,远程服务器将会获取到 <code>Origin</code> header，并且必须以 <code>Access-Control-Allow-Origin</code> 响应</p></li><li><p>创建之后，<code>new EventSource</code> 连接到服务器，如果连接断开 —— 则<strong>重新连接</strong>。这非常方便，我们不用去关心重新连接的事情。</p></li><li><blockquote><p>服务器可以使用 <code>retry:</code> 来设置需要的延迟响应时间（以毫秒为单位）</p></blockquote></li><li><p><strong>链接断开</strong>:</p></li><li><blockquote><ul><li><p>如果服务器想要浏览器停止重新连接，那么它应该使用 HTTP 状态码 204 进行响应。</p></li><li><p>如果浏览器想要关闭连接，则应该调用 <code>eventSource.close()</code>：</p></li></ul><p>  如果响应具有不正确的 <code>Content-Type</code> 或者其 HTTP 状态码不是 301，307，200 和 204，则不会进行重新连接。在这种情况下，将会发出 <code>&quot;error&quot;</code> 事件，并且浏览器不会重新连接</p></blockquote></li></ul><ul><li><p>当一个连接由于网络问题而中断时，客户端和服务器都无法确定哪些消息已经收到哪些没有收到。为了正确地恢复连接，每条消息都应该有一个 <code>id</code> 字段</p></li><li><blockquote><p>当收到具有 <code>id</code> 的消息时，浏览器会：</p><ul><li>将属性 <code>eventSource.lastEventId</code> 设置为其值。</li><li>重新连接后，发送带有 <code>id</code> 的 header <code>Last-Event-ID</code>，以便服务器可以重新发送后面的消息。</li></ul></blockquote></li><li><p><strong>连接状态：readyState</strong></p></li><li><p><code>EventSource</code> 对象有 <code>readyState</code> 属性，该属性具有下列值之一：</p></li><li><blockquote><p>EventSource.CONNECTING = 0; // 连接中或者重连中</p><p> EventSource.OPEN = 1;       // 已连接</p><p> EventSource.CLOSED = 2;     // 连接已关闭</p></blockquote></li><li><p>默认情况下 <code>EventSource</code> 对象生成三个事件：</p></li><li><blockquote><ul><li><code>message</code> —— 收到消息，可以用 <code>event.data</code> 访问。</li><li><code>open</code> —— 连接已打开。</li><li><code>error</code> —— 无法建立连接，例如，服务器返回 HTTP 500 状态码。</li></ul></blockquote></li><li></li></ul><h4 id="RESTful-风格API"><a href="#RESTful-风格API" class="headerlink" title="RESTful 风格API"></a>RESTful 风格API</h4><ul><li>如何设计请求地址的规范格式</li></ul><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><ul><li>把获得的数据拼接在html上进行展示</li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8B/"/>
    <url>/2020/12/14/Js-dom/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h4><h5 id="Rest参数-Spread语法"><a href="#Rest参数-Spread语法" class="headerlink" title="Rest参数  Spread语法"></a>Rest参数  Spread语法</h5><ul><li><p>在 JavaScript 中，很多内建函数都支持传入任意数量的参数</p></li><li><blockquote><p>如何实现 : 使用Rest 参数 <code>...</code></p><p>Rest 参数<code>...</code> : 在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数。不会因为传入“过多”的参数而报错,只会取得前几个参数匹配             </p></blockquote></li><li><p><strong>Rest 参数语法</strong>:</p></li><li><pre><code class="javascript">function showName(firstName, lastName, ...titles) &#123;&#125;//Rest 参数必须放到参数列表的末尾, 收集 参数放到titles数组中<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- **arguments 变量**:<br><br>- &gt;  有一个名为 arguments 的特殊的**类数组对象**，该对象包含所有参数,使用索引访问参数<br>  &gt;<br>  &gt; ```javascript<br>  &gt; function showName() &#123;<br>  &gt;   alert( arguments.length );<br>  &gt;   alert( arguments[0] );<br>  &gt;   alert( arguments[1] );<br>  &gt;   alert(arguments) //代表所有参数<br>  &gt;   // 它是可遍历的<br>  &gt;   // for(let arg of arguments) alert(arg);<br>  &gt; &#125;<br>  &gt; <br>  &gt; // 依次显示：2，Julius，Caesar<br>  &gt; showName(&quot;Julius&quot;, &quot;Caesar&quot;);<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>在过去，JavaScript 中没有 rest 参数，而使用 arguments 是获取函数所有参数的唯一方法,两者区别:arguments 是一个类数组，也是可迭代对象，但它终究不是数组,不支持数组方法</p></blockquote></li><li><blockquote><p>箭头函数是没有 “arguments”, 箭头函数内访问到的是属于外部’普通函数’的</p></blockquote></li></ul><ul><li><p><strong>Spread</strong> :</p></li><li><blockquote><p>把可迭代对象 spread 开, 分给每个函数参数, 和Rest参数相反</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>];<br><br>alert( <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,...arr) ); <span class="hljs-comment">// 5（spread 语法把数组转换为参数列表）</span><br><br>spread 参数是在调用时 使用...     Rest参数是在函数声明时 使用...<br></code></pre></td></tr></table></figure></blockquote></li><li><blockquote><p> 对于可迭代对象都可以展开, 甚至可以用它来合并数组, 转化数组,复制数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> merged = [<span class="hljs-number">0</span>, ...arr, <span class="hljs-number">2</span>, ...arr2];  <span class="hljs-comment">//返回一个数组</span><br><br>alert( [...str] ); <span class="hljs-comment">// [..str] 把字符串转化为数组    </span><br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-keyword">let</span> arrCopy = [...arr] <span class="hljs-comment">//复制一个数组, arr是对象也成立</span><br><br></code></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>和<code> Array.from(obj)</code>的结果相同,</p><p>区别在于<code>Array.from </code><strong>适用于类数组对象也适用于可迭代对象</strong>, Spread 语法<strong>只适用于可迭代对象</strong>。</p></blockquote></li><li><p>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。</p></li><li><p>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。</p></li></ul><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><ul><li><p>词法环境 : </p><ol><li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li><li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联</li></ol></li><li><p>一个“变量”只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p></li></ul><blockquote><p>“词法环境”是一个规范对象（specification object）：它仅仅是存在于 <a href="https://tc39.es/ecma262/#sec-lexical-environments">编程语言规范</a> 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。</p></blockquote><ul><li><p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。</p></li><li><blockquote><p>在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <a href="https://zh.javascript.info/new-function">“new Function” 语法</a> 中讲到） </p><p>原因 : 所有的函数在“诞生”时都会记住创建它们的词法环境。所有函数都有名为 <code>[[Environment]]</code> 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。</p></blockquote></li><li><p>垃圾收集 : 通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p></li><li><p> 嵌套函数 =  null时, 才能完成真正的垃圾收集</p></li><li><p>理论上当函数可达时，它外部的所有变量也都将存在。</p><p>但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。</p><blockquote><p>在 V8（Chrome，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。</p></blockquote></li></ul><h5 id="let-和-var-区别"><a href="#let-和-var-区别" class="headerlink" title="let 和 var 区别:"></a>let 和 var 区别:</h5><ul><li><p>变量提升和函数提升</p></li><li><blockquote><p>函数表达式不存在提升 , let有提升但是有暂时锁区</p></blockquote></li><li><p>let 在创建时变量提升, 初始化时正常初始化, 有暂时锁区</p></li><li><p>var 的变量提升,导致在声明之前都可以使用</p></li></ul><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">案例一: <br><span class="hljs-keyword">let</span> x=<span class="hljs-string">&quot;fef&quot;</span>;<br> &#123;<br>   <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//x 显示错误</span><br>   <span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;eew&quot;</span>;<br>   <span class="hljs-comment">//在代码块中, x创建时变量提升, 所以log() 使用的是代码块中的x值.但是初始化并没有被提升, 所以初始化之前不能使用的x 报错</span><br> &#125;<br>案例二:<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br> element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(i)  <span class="hljs-comment">// 结果都会是 5 ,因为var不存在块作用域,循环中的i值 一直只有一个, 所以结果都是I的最终值</span><br> <br> &#125;<br> <span class="hljs-comment">//var 改为 let  可以解决,他会在每次循环重新声明初始化,保证每次循环只用当前的一个值</span><br>&#125;<br> <br></code></pre></td></tr></table></figure></blockquote><ul><li>“var” 没有块级作用域,不是函数作用域就是全局作用域,例如if块中定义的变量,在外面还是能访问到</li><li>  使用 var，我们可以重复声明一个变量，不管多少次都行</li><li>“var” 声明的变量，可以在其声明语句前被使用,当函数开始的时候，就会处理 var 声明</li></ul><ul><li>IIFE 函数书写   存在意义: 创建一个块级作用域进行使用,不会污染全局变量</li><li><blockquote><p>jq 中开发插件也使用了IIFE ,为了继续使用$ 和 创建一个作用域</p></blockquote></li></ul><h5 id="全局对象-不是全局变量搞清楚"><a href="#全局对象-不是全局变量搞清楚" class="headerlink" title="全局对象(不是全局变量搞清楚)"></a>全局对象(不是全局变量搞清楚)</h5><ul><li>全局对象提供可在任何地方使用的变量和函数,默认情况下，这些全局变量内置于语言或环境中,全局对象的所有属性都可以被直接访问</li><li><blockquote><p>在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”</p></blockquote></li><li>在浏览器中，使用 var（而不是 let/const！）声明的全局函数和变量会成为全局对象的<strong>属性</strong>。使用 let，就不会发生这种情况.</li><li><blockquote><p>如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：</p><p>window.currentUser = {<br> name: “John”<br>};</p></blockquote></li><li><blockquote><p> 我们使用全局对象来测试对现代语言功能的支持。</p><p> if (!window.Promise){…}   测试是否存在promise对象</p></blockquote></li></ul><h5 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h5><blockquote><p>在 JavaScript 中，函数就是值。类型是一个对象, 我们可以把它当成一个对象使用, </p><ul><li>函数名字通过属性name 访问获得  length返回函数需要参数的个数(rest 参数不参与计数)。</li><li> 我们也可以在函数内添加自定义属性,在函数外可以调用,改变它. 通过函数名.属性名添加, 创建只属于函数的属性</li></ul></blockquote><ul><li>命名函数表达式 (NFE): 指带有函数名字的函数表达式 (函数声明没有这个东西)</li><li><blockquote><p>let sayHi = function func(who) ,通过func可以在函数内调用自己 而且在函数外不可见你, </p></blockquote></li><li><blockquote><p>为什么不使用嵌套调用的原因:为了避免在函数内嵌套调用时, 函数表达式在外部已被修改(引用其他函数..)</p><p>比如: let sayhi =null 那么使用sayhi的嵌套调用就无效了</p></blockquote></li></ul><h5 id="new-Function-语法"><a href="#new-Function-语法" class="headerlink" title="new Function 语法"></a>new Function 语法</h5><ul><li>创建函数体, 参数内接受函数参数 和函数体 ,应用在从服务器获取代码 ..复杂场景才会使用 , 创建的函数只能访问全局变量</li></ul><h5 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h5><ul><li><p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”</p></li><li><p>两种方法事件 : setTimeout 和 setInterval</p></li><li><pre><code class="javascript">let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)func|code : 想要执行的函数或代码字符串。 一般传入的都是函数。 由于某些历史原因，支持传入代码字符串，但是不建议这样做。尽量使用箭头函数代替它们,(JavaScript 会自动为字符代码块其创建一个函数) arg1 ..要传入被执行函数（或代码字符串）的参数列表// 实例 : setTimeout(sayHi, 1000, &quot;Hello&quot;, &quot;John&quot;);<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> setInterval 方法 setTimeout 的语法相同<br><span class="hljs-bullet">-</span> 使用clearTimeout() , clearInterval()  取消调度,在浏览器中，定时器标识符是一个数字。在其他环境中，可能是其他的东西。<br><br><span class="hljs-quote">&gt; alert 弹窗显示的时候计时器依然在进行计时, 在大多数浏览器中，包括 Chrome 和 Firefox，在显示 `alert/confirm/prompt` 弹窗时，内部的定时器仍旧会继续“嘀嗒”。</span><br><br><br><br><span class="hljs-bullet">-</span> 周期性调度有两种方式 ： 一种是使用 setInterval，另外一种就是嵌套的 setTimeout <br><br><span class="hljs-bullet">-</span> &gt; 嵌套的 <span class="hljs-code">`setTimeout`</span> 要比 <span class="hljs-code">`setInterval`</span> 灵活得多,采用这种方式可以根据当前执行结果来调整下次调用的时间间隔<br><br><span class="hljs-bullet">-</span> &gt; 使用 setInterval 时，func 函数的实际调用间隔要比代码中设定的时间间隔要短！ 因为其中设置的间隔时间包括函数执行的时间, 所以实际间隔要小<br>  &gt;<br>  &gt; 嵌套的 setTimeout 就能确保延时的固定（这里是 100 毫秒）。这是因为下一次调用是在前一次调用完成时再调度的。  嵌套调用时 函数名字不能再是 匿名函数..<br><br><span class="hljs-bullet">-</span> 垃圾回收 和 计时函数 : 对于 setInterval，传入的函数也是一直存在于内存中，直到 clearInterval 被调用。 如果函数还引用了一些外部变量,那么函数存在,变量也会随之存在(闭包), 会占用内存<br><br>  <br><br><span class="hljs-bullet">-</span> 这儿有一种特殊的用法：<span class="hljs-code">`setTimeout(func, 0)`</span>，或者仅仅是 <span class="hljs-code">`setTimeout(func)`</span>。这样调度可以让 <span class="hljs-code">`func`</span> 尽快执行。但是首先执行的仍然是脚本中的其他表达式. 因为是异步操作<br><br>  &gt; 在浏览器环境下，嵌套定时器的运行频率是受限制的。必须经过 4 毫秒以上的强制延时<br><span class="hljs-section">##### 装饰者模式和转发，call/apply</span><br><span class="hljs-bullet">-</span> 装饰者模式 : 一个特殊的函数 :  它接受另一个函数并改变它的行为(参数是一个函数)。返回一个函数引用,用来覆盖被改变的函数<br><br><span class="hljs-bullet">-</span> &gt; 用函数来装饰另一个函数<br>  &gt;<br>  &gt; 装饰者不适用于对象方法, 原因在于传递函数时,因为是对象方法,和对象分离之后,丢失this , 使用call() 解决,设定上下文<br><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```javascript</span><br><span class="hljs-code">  func.call(context, arg1, arg2, ...)</span><br><span class="hljs-code">  提供的第一个参数作为 this，后面的作为参数.</span><br><span class="hljs-code">  例如: </span><br><span class="hljs-code">   </span><br><span class="hljs-code">  func(1, 2, 3);</span><br><span class="hljs-code">  func.call(obj, 1, 2, 3)</span><br><span class="hljs-code">  </span><br><span class="hljs-code">  call 返回调用该函数的返回值  , bind 返回this绑定的函数</span><br><span class="hljs-code">  call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。</span><br><span class="hljs-code">  </span><br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="javascript">func.apply(context, args)context: this指向, args: 参数数组</code></pre></li></ul><p>  func.call(context, …args); // 使用 spread 语法将数组作为列表传递<br>  func.apply(context, args);   // 与使用 call 相同<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>- 将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。<br><br>  <br><br>- 方法借用 :  [].join.call(arguments)  借用原始方法,给与上下文,它为什么有效？那是因为原生方法 `arr.join(glue)` 的内部算法非常简单。类数组就可以<br><br><br><span class="hljs-meta">&gt;</span><span class="bash"> 通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 func.calledCount 或其他，则装饰后的函数将不再提供这些属性.</span><br><span class="hljs-meta">&gt;</span><br><span class="bash">&gt; 函数本质上是一个对象, 可以添加属于函数的属性</span><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#### 函数绑定</span></span> <br><br>- 丢失&quot;this&quot; : 一旦方法被传递到与对象分开的某个地方 —— `this` 就丢失。<br><br>- &gt; 当对象方法不是直接调用,就会丢失this<br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 例如:  setTimeout(user.func,1000); 直接调用user,func() 就不会发生丢失;</span> <br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 本质上第一种的调用方法是和对象分开的,当传递对象方法时,会直接传递该函数地址, 不会连同对象一起传输,this又是运行时才被计算出来,所以就会丢失</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 第一种写法相当于    <span class="hljs-built_in">let</span> f  = user.func;  setTimeout(f,1000);</span><br><br>- ##### 解决方法 :<br><br>- 包装器 ,使用匿名函数/箭头函数, 在内部写调用对象方法<br><br>- &gt; 传递时传递包装器,调用时对象方法会直接调用,就不会丢失<br><br>- &gt; 包装器的缺点:<br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 当对象方法在**包装器之前**更新,包装器中的对象方法就会更新,</span>  <br><span class="hljs-meta">&gt;</span><br><span class="bash">  &gt; 如果利用<span class="hljs-built_in">bind</span>进行绑定, 只要**在<span class="hljs-built_in">bind</span>之后**再更改对象方法,那么都不会影响(已经绑定不会影响) ,调用的还是原来的对象方法.</span><br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; 本质区别在于 :  <span class="hljs-built_in">bind</span>绑定后可以和调用分开. 包装器不能可以和调用分开</span><br><br>- bind 方法,用来绑定this<br><br>- &gt; func.bind(对象),  返回一个类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用<br><span class="hljs-meta">  &gt;</span><br><span class="bash">  &gt; ```javascript</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> <span class="hljs-built_in">let</span> user = &#123;</span><br><span class="hljs-meta">  &gt;</span><span class="bash">   firstName: <span class="hljs-string">&quot;John&quot;</span>,</span><br><span class="hljs-meta">  &gt;</span><span class="bash">   <span class="hljs-function"><span class="hljs-title">sayHi</span></span>() &#123;</span><br><span class="hljs-meta">  &gt;</span><span class="bash">     alert(`Hello, <span class="hljs-variable">$&#123;this.firstName&#125;</span>!`);</span><br><span class="hljs-meta">  &gt;</span><span class="bash">   &#125;</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> &#125;;</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> <span class="hljs-built_in">let</span> sayhi = user.sayhi.bind(user); //绑定user对象到this</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> sayhi() // 可以直接调用,不需要对象也可以</span><br><span class="hljs-meta">  &gt;</span><span class="bash"> </span><br></code></pre></td></tr></table></figure></p><ul><li><blockquote><p>func.bind()方法 返回的”类函数” ,参数列表和func一样,一样传递参数调用,只是this被绑定了</p><p>bindAll : 对象有很多方法都需要绑定, 可以在一个循环中完成所有方法绑定</p></blockquote></li></ul><ul><li><p>偏函数 :  不仅可以绑定this ,还可以绑定参数</p></li><li><blockquote><pre><code class="javascript">let bound = func.bind(context, [arg1], [arg2], ...);当this 不需要绑定时 传递 null给conttext<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> &gt; 通过绑定一个函数的一些参数来创建一个新函数</span><br><br><span class="ruby">当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用</span><br><br><span class="ruby">- 想直接绑定参数, 忽略this 绑定参数, 原生bind方法不支持, 使用js 编写partial(偏函数)</span><br><br><span class="ruby">- &gt; <span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="ruby">partial(func[, arg1, arg2...])<span class="hljs-string">` 调用的结果是一个包装器 </span></span><br><br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><h4 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h4><h5 id="属性标志和属性描述符"><a href="#属性标志和属性描述符" class="headerlink" title="属性标志和属性描述符"></a>属性标志和属性描述符</h5><ul><li>对象可以存储属性。到目前为止，属性对我们来说只是一个简单的“键值”对。但对象属性实际上是更灵活且更强大的东西。</li></ul><ul><li><p>对象属性（properties），除 value 外还有特殊的特性 </p></li><li><blockquote><p>属性标志 : </p><p>writable  修改权限   如果为 <code>true</code>，则值可以被修改</p><p> enumerable 循环是否列出  如果为 <code>true</code>，则会被在循环中列出</p><p> configurable   如果为 <code>true</code>,此特性可以被删除，这些属性也可以被修改  否则不行</p></blockquote></li><li><blockquote><p>它们通常不会出现。当我们用“常用的方式”创建一个属性时，它们都为 true。但我们也可以随时更改它们。</p></blockquote><h5 id="设置-访问标志"><a href="#设置-访问标志" class="headerlink" title="设置/访问标志"></a>设置/访问标志</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptor(<span class="hljs-params">obj</span>, <span class="hljs-string">&quot;propertyName&quot;</span>)</span>;  <br>方法允许查询有关属性的完整信息。<br>obj 查询的对象   properName 属性名称<br>返回值是一个所谓的“属性描述符”对象：它包含值和所有的标志<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">obj</span>, <span class="hljs-params">propertyName</span>, <span class="hljs-params">descriptor</span>)</span><br> descriptor : 要应用的属性描述符对象。<br> <br>如果该属性(propertyName)存在，defineProperty 会更新其标志。其余标志不变<br>属性不存在时,创建该属性使用提供标志更新, 未提供的标志默认为<span class="hljs-literal">false</span><br><br>方法都可以在类/ 构造函数中使用, 对象名改为this<br></code></pre></td></tr></table></figure></li><li><blockquote><p>writable : false;  值不可改变, 在非严格模式下不会出现Error</p><p>如果还想要修改值, 只能使用defineproperty() 设置value属性覆盖,进行更改</p></blockquote></li><li><blockquote><p> enumberable   :false  使其不可枚举</p><p> 在console.log(obj) , 不会显示该属性, for..in 中不会枚举出来;</p><p> 例如: 对象的toString()函数, 不会显示出来  </p></blockquote></li></ul><ul><li><blockquote><p>configurable:false  不可配置,</p><p> 我们无法使用 <code>defineProperty</code> 把它改回去</p><p>定义过其他属性值后, 就无法更改属性标志或删除属性标志</p></blockquote></li></ul><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties(obj, descriptors)</a>，允许一次定义多个属性</li></ul><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors(obj)</a>  方法。一次获取所有属性描述符，</li></ul><ul><li><blockquote><p>for..in 会忽略 symbol 类型的属性，但是 Object.getOwnPropertyDescriptors 返回包含 symbol 类型的属性在内的所有属性描述符。</p></blockquote></li><li><blockquote><p>复制属性标志:  let clone = Object.defineProperties({},Object.getOwnPropertyDescriptors(obj)); </p><p>拷贝对象 一般我们使用赋值的方式复制属性,但是我们不能复制标志,而上式解决了这个问题</p></blockquote><ul><li>还有一些限制访问 <strong>整个</strong> 对象的方法</li></ul></li></ul><h5 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 getter 和 setter</h5><ul><li><p>有两种类型的对象属性 : 1. 数据属性 2.  访问器属性</p></li><li><blockquote><p>访问器属性 : 本质上是用于获取和设置值的函数</p></blockquote></li><li><pre><code></code></pre></li></ul><p>  第一种设置方式 (对象内使用, 类中constructor 外使用):<br>  let user = {<br>    name: “John”,<br>    surname: “Smith”,</p><pre><code>get fullName() &#123;  return `$&#123;this.name&#125; $&#123;this.surname&#125;`;&#125;</code></pre><p>  };</p><p>  第二种设置方式(对象外, 构造函数内, 类中constructor使用):<br>  在构造函数 / 类中constructor使用,对象名改为this,</p><p>  Object.defineProperty(user, ‘fullName’, {<br>  get() {<br>  return <code>$&#123;this.name&#125; $&#123;this.surname&#125;</code>;<br>  },<br>  set(value) {<br>  [this.name, this.surname] = value.split(“ “);<br>  }<br>  });</p><p>  一个属性要么是访问器（具有 get/set 方法），要么是数据属性（具有 value），但不能两者都是<br>  Object.defineProperty({}, ‘prop’, {<br>    get() {<br>      return 1<br>    },</p><pre><code>value: 2</code></pre><p>  });<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs markdown">  <br><span class="hljs-bullet">-</span> &gt;访问器属性的设计思想 : 我们不以函数的方式调用 user.fullName，我们正常读取它： getter 在幕后运行<br>  &gt;<br>  &gt;相当于我们有了一个虚拟的属性<br>  <br><span class="hljs-bullet">-</span> &gt; 访问器属性名字 不能和对象数据属性名字一样,否则会被覆盖<br><br>  <br><br><span class="hljs-bullet">-</span> 访问器属性的描述符与数据属性的不同,   对于访问器属性,没有value 和 writable，<span class="hljs-strong">**enumerable  configurable**</span> 与数据属性的相同 <br><br>  <br><br><span class="hljs-bullet">-</span> Getter/setter用途 : <br><br><span class="hljs-bullet">-</span> 1. 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。例如限制属性值的长度 <br><br><span class="hljs-bullet">-</span>    2. 它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性<br><br><span class="hljs-code">        &gt; 通过设置getter和 &quot;旧的&quot;数据属性相同的名字 , 来替换旧的属性</span><br><span class="hljs-code"></span><br><span class="hljs-code">#### 原型,继承</span><br><span class="hljs-code"></span><br><span class="hljs-code">##### 原型继承</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 原型继承解决,在原来的对象基础上**扩展构建**新的对象</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt; 因为构造函数只能是重复创建类似功能的对象,无法通过其进行扩展</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 在 JavaScript 中，对象有一个特殊的隐藏属性 `[[Prototype]]`，它要么为 `null`，要么就是对另一个对象的引用。被引用的对象被称为“原型”</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 属性 `[[Prototype]]` 是内部的而且是隐藏的,设置它的方式 :</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt; 使用特殊的名字 `__proto__` .   可以获取和设置 ,每边是两个下划线</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; `__proto__` 的存在是历史的原因。在现代编程语言中，将其替换为函数 `Object.getPrototypeOf/Object.setPrototypeOf` 也能 get/set 原型</span><br><span class="hljs-code"></span><br><span class="hljs-code">  </span><br><span class="hljs-code"></span><br><span class="hljs-code">  </span><br><span class="hljs-code"></span><br><span class="hljs-code">- 原型链中引用不能形成闭环, --proto-- 的值可以是对象，也可以是 null,其他类型被忽略, 只能有一个 `[[Prototype]]`。一个对象不能从其他两个对象获得继承。( 单继承)</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt;  --proto-- 是 [[Prototype]] 的因历史原因而留下来的 getter/setter</span><br><span class="hljs-code"></span><br><span class="hljs-code">  </span><br><span class="hljs-code"></span><br><span class="hljs-code">- this 不受原型的影响,在一个对象还是在原型中。在一个方法调用中，this 始终是点符号 . 前面的对象</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">- for..in 循环也会迭代继承的属性。想要排除继承的属性  obj.hasOwnProperty(key) 如果本身存在(不是继承的属性)key则返回true  如果是继承来的 返回false</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt; hasOwnProperty()  很严格 , 对于对象的构造函数prototype中的属性,都算是继承属性</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; 还有 ....OwnProperty() 等函数 ,返回非继承的属性</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt; `for..in` 只会列出可枚举的属性, `enumerable:false` 标志导致不可枚举</span><br><span class="hljs-code"></span><br><span class="hljs-code">  &gt; 几乎所有其他键/值获取方法，例如 `Object.keys` 和 `Object.values` 等，都会忽略继承的属性。</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; 它们只会对对象自身进行操作。**不考虑** 继承自原型的属性。</span><br><span class="hljs-code"></span><br><span class="hljs-code">- </span><br><span class="hljs-code"></span><br><span class="hljs-code">##### Func.prototype </span><br><span class="hljs-code"></span><br><span class="hljs-code">- JavaScript 从一开始就有了原型继承,但是在过去，没有直接对其进行访问的方式。唯一可靠的方法是构造函数的 `&quot;prototype&quot;` 属性。目前仍有许多脚本仍在使用它。</span><br><span class="hljs-code"></span><br><span class="hljs-code">- &gt;  `F.prototype` 指的是 `F` 的一个名为 `&quot;prototype&quot;` 的常规属性</span><br><span class="hljs-code">  &gt;</span><br><span class="hljs-code">  &gt; 不要和原型的 prototype 混淆, 原型的是引用</span><br><span class="hljs-code"></span><br><span class="hljs-code">&gt; F.prototype 属性**仅在** new F 被调用时使用，它为新对象的 [[Prototype]] 值。</span><br><span class="hljs-code">&gt;</span><br><span class="hljs-code">&gt; 如果在创建之后，F.prototype 属性赋了其他值, 那么通过 new F 创建的新对象也将改变 [[Prototype]]，但已经存在的对象将保持旧有的值。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">- 每个函数都有 &quot;prototype&quot; 属性，即使我们没有提供它。 默认的 &quot;prototype&quot; 是一个**只有属性 constructor 的对象**，属性 constructor 指向函数自身。</span><br><span class="hljs-code"></span><br><span class="hljs-code">- ```javascript</span><br><span class="hljs-code">  function Rabbit() &#123;&#125;</span><br><span class="hljs-code">  </span><br><span class="hljs-code">  /* default prototype</span><br><span class="hljs-code">  Rabbit.prototype = &#123; constructor: Rabbit &#125;;</span><br><span class="hljs-code">  */</span><br><span class="hljs-code">  如果我们什么都不做 , constructor 属性可以通过 [[Prototype]] 给所有 rabbits 使用 , rabbits的[[Prototype]] 引用默认的对象</span><br></code></pre></td></tr></table></figure></p><blockquote><p>有一点需要注意,对象不存在prototype属性,只有构造函数 类 存在prototype属性,  对象只有[[prototype]];</p></blockquote><ul><li><blockquote><p>我们可以使用 <code>constructor</code> 属性来创建一个新对象，该对象使用与现有对象相同的构造器:</p><p>new rabbit.constructor(“Black Rabbit”);    // 两者相等</p><p> new Rabbit(“White Rabbit”);</p><p>当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</p></blockquote></li></ul><ul><li><p>JavaScript 自身并不能确保正确的 “constructor” 函数值。 它存在于函数的默认 <code>&quot;prototype&quot;</code> 中,它存在于函数的默认 <code>&quot;prototype&quot;</code> 中</p></li><li><p>为了确保正确的 “constructor”，我们可以选择添加/删除属性到默认 “prototype”，而不是将其整个覆盖. 也可以手动重新创建 <code>constructor</code> 属性</p></li><li><blockquote><pre><code class="javascript">function Rabbit() &#123;&#125;Rabbit.prototype.jumps = true<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><br>- &gt; <span class="hljs-type">F</span>.proto<span class="hljs-keyword">type</span> =的值要么是一个对象，要么就是 null：其他值都不起作用。 <br><br>注意一点:  更改proto<span class="hljs-keyword">type</span>中的属性,和对prototype赋值的区别<br><br></code></pre></td></tr></table></figure>Rabbit.prototype.jumps = true  这种是改变prototype属性指向对象中的属性Rabbit.prototype = &#123;&#125; 或者对象名, 这是改变构造函数创建对象后[[prototype]]指向的对象两者要分清楚区别, 一个是改变[[prototype]]  指向,一个仅仅改变其中的属性还要清楚一点: Rabbit.prototype = animal;   是指向animal对象 Rabbit.prototype = Animal .prototype; 是指向  animal构造函数的prototype (类似于原生的原型 ,内建对象都是指向自己构造函数的prototype, 而大部分的构造函数 prototype都指向Object()的prototype)<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs http"><br><br><br>##### 原生的原型<br><br>-  `&quot;prototype&quot;` 属性在 JavaScript 中所有的内置构造函数都用到了它.<br><br>- &gt; 通过对内建对象的构造函数 的prototype属性, 进行添加功能<br><br>-  通过构造函数new对象时, 对象的[[prototype]]默认指向构造函数的Prototype<br><br>- 内建对象，像 Array、Date、Function 及其他，都在 prototype 上挂载了方法<br><br>- 数据类型对象 也有相应的prototype,但是null undefined没有对象包装器所以不存在 prototype<br><br>- &gt; 这里的 prototype  都是指Array() ...构造函数的属性, 属性指向一个大对象,对象内有很多方法   <br><br>Array.prototype = &#123; ...//方法&#125;;<br><br>- &gt;按照规范，所有的内建原型顶端都是 `Object.prototype`。这就是为什么有人说“一切都从对象继承而来”。<br><br> &gt;即使是函数 —— 它们是内建构造器 `Function` 的对象，并且它们的方法（`call`/`apply` 及其他）都取自 `Function.prototype`。函数也有自己的 `toString` 方法。<br><br>原生的原型是可以被修改的,通常是一个很不好的想法。原型是全局的,如果两个库都添加了相同的方法, 所以很容易造成冲突。<br><br>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling:<br><br>- &gt; **polyfilling**: 表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。<br><br>- ##### 原型方法借用:<br><br>- &gt; 从原型中借用方法 ,例如创建类数组,我们向其复制Array的原型方法,<br><br>```javascript<br>1. obj.join = Array.prototype.join;   通过赋值进行借用<br><br>2. obj.__proto__  = Array.prototype ; 通过设置__proto__ , 来进行借用方法, 但是js不支持多继承,如果obj已经继承了其他对象, 该方法不可用<br><br></code></pre></td></tr></table></figure></code></pre></blockquote><blockquote><p>call /apply 方法借用指的是 从一个对象获取一个方法，并将其复制到另一个对象</p></blockquote></li></ul><blockquote><p>所有的内建对象都遵循相同的模式（pattern）：</p><ul><li>方法都存储在 prototype 中（<code>Array.prototype</code>、<code>Object.prototype</code>、<code>Date.prototype</code> 等）。</li><li>对象本身只存储数据（数组元素、对象属性、日期）。</li></ul></blockquote><h5 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h5><ul><li> <strong>proto</strong> 被认为是过时且不推荐使用的，这里的不推荐使用是指 JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持。(实际上服务器端也支持)</li></ul><blockquote><ul><li> 现代的方法 : Object.getPrototypeOf(obj)  返回对象 obj 的 [[Prototype]]。</li><li> Object.create(proto, [descriptors]) ,创建一个空的新对象, 新对象的[[Prototype]指向proto对象  ,[descriptors] : 可选的属性描述  ,可以使用属性描述给新对象提供额外的属性,描述器的格式与 <a href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章中所讲的一样</li><li> Object.setPrototypeOf(obj, proto)  将对象 obj 的 [[Prototype]] 设置为 proto</li></ul></blockquote><blockquote><p>我们可以使用 <code>Object.create</code> 来实现比复制 <code>for..in</code> 循环中的属性更强大的对象克隆方式: 包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> clone = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptors(<span class="hljs-params">obj</span>)</span>);<br>实现一个对象的完全复制 , 完成深度拷贝<br></code></pre></td></tr></table></figure><h5 id="原型简史"><a href="#原型简史" class="headerlink" title="原型简史"></a>原型简史</h5><blockquote><p>如果速度很重要，就请不要修改已存在的对象的 [[Prototype]] , 通常我们只在创建对象的时候设置它一次，自那之后不再修改, JavaScript 引擎对此进行了高度优化。用 Object.setPrototypeOf 或 obj.<strong>proto</strong>= “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。</p></blockquote><ul><li><p>对象可以用作关联数组（associative arrays）来存储键/值对。,当用户存储—prototype– ,不会存储值,他只能是null  对象</p></li><li><p><code>__proto__</code> 不是一个对象的属性，只是 <code>Object.prototype</code> 的访问器属性,</p></li><li><blockquote><p><code>__proto__</code> 是一种访问 <code>[[Prototype]]</code> 的方式，而不是 <code>[[prototype]]</code> 本身。</p><p>如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调用，它会 set/get <code>[[Prototype]]</code>。</p></blockquote></li><li><p>当一个对象不继承 Object 对象时, –Prototype– 就不会当成访问器了,我们可以把这样的对象称为 “very plain” 或 “pure dictionary” 对象,缺点是没有内建对象的函数</p></li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-comment">// class 方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;...&#125;  <span class="hljs-comment">//new来新建对象时会自动调用该函数,初始化对象</span><br>  <span class="hljs-function"><span class="hljs-title">method1</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;<br>  <span class="hljs-function"><span class="hljs-title">method2</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>类的方法之间没有逗号</p></blockquote><ul><li><p>在 JavaScript 中，类是一种函数。<code>class User &#123;...&#125;</code> 构造实际上做了如下的事儿：</p></li><li><pre><code class="javascript">class User &#123;  constructor(name) &#123; this.name = name; &#125;  sayHi() &#123; alert(this.name); &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>- &gt; 创建一个名为 `User` 的函数，该函数成为类声明的结果。该函数的代码来自于 `<span class="hljs-keyword">constructor</span>` 方法<br>  &gt;<br>  &gt; 存储类中的方法给 `User.prototype` ,  `<span class="hljs-keyword">constructor</span>` 中的方法不会存储在prototype中,而是在每个对象中<br><br><br><br><br>- 使用构造函数,构造函数本身只存储数据,方法则放在函数的prototype 中, <span class="hljs-class"><span class="hljs-keyword">class</span>则省略了这个过程</span><br>  <br>  &gt; 人们常说 `<span class="hljs-class"><span class="hljs-keyword">class</span>` 是一个语法糖（旨在使内容更易阅读，但不引入任何新内容的语法）,<span class="hljs-type">就是来源此</span></span><br>  &gt;<br>  &gt; 但是<span class="hljs-class"><span class="hljs-keyword">class</span> 不仅仅是语法糖 :<span class="hljs-type"></span></span><br>  &gt;<br>  &gt; <span class="hljs-number">1.</span>使用<span class="hljs-class"><span class="hljs-keyword">class</span> 创建的函数具有特殊的内部属性标记,<span class="hljs-type">[[FunctionKind]]:&quot;classConstructor&quot;</span>,  <span class="hljs-type">会检查该属性</span>,<span class="hljs-type">与普通函数不同，必须使用 `new` 来调用它：</span></span><br>  &gt;<br>  &gt; <span class="hljs-number">2.</span>类方法不可枚举  ,类定义将 `<span class="hljs-string">&quot;prototype&quot;</span>` 中的所有方法的 `enumerable` 标志设置为 `<span class="hljs-literal">false</span>`<br>  &gt;<br>  &gt; <span class="hljs-number">3.</span>类总是使用 `use strict`。 在类构造中的所有代码都将自动进入严格模式。<br><br>  <br><br>- 类表达式 : 就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。<br><br>- &gt;let User = <span class="hljs-class"><span class="hljs-keyword">class</span></span>&#123;&#125;   类似于命名函数表达式（NamedFunctionExpressions）<br>  &gt;<br>  &gt;类表达式可能也应该有一个名字。<br>  &gt;<br>  &gt;let User = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;&#125;  这个类名只在类内可见<br><br>  <br><br>- 类中可以也存在 getter setter  计算属性等<br><br>- &gt; 也可以通过在 F.prototype中创建getter和setter来起作用。<br><br>- 类字段 : 是一种允许直接在类中添加任何属性的语法,不再通过<span class="hljs-keyword">constructor</span>()<br><br>- &gt; 效果和在<span class="hljs-keyword">constructor</span>()中声明一样<br>  &gt;<br>  &gt; <span class="hljs-class"><span class="hljs-keyword">class</span>字段 :<span class="hljs-type">旧的浏览器可能需要 polyfill </span>, <span class="hljs-type">类字段（field）是最近才添加到语言中的。之前，我们的类仅具有方法</span></span><br><br>  <br><br>- 传递对象方法时,会出现丢失<span class="hljs-keyword">this</span>的现象, 类字段提供了另一种非常优雅的语法：<br><br>- &gt; 普通字段解决方法: <br>  &gt;<br>  &gt; <span class="hljs-number">1.</span>在类中 <span class="hljs-keyword">constructor</span> 中可以使用包装器<br>  &gt;<br>  &gt; <span class="hljs-number">2.</span>在类中 <span class="hljs-keyword">constructor</span> 中绑定 bind<br>  &gt;<br>  &gt; ```javascript<br>  &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  &gt; <span class="hljs-keyword">constructor</span>() &#123;<br>  &gt; <span class="hljs-keyword">this</span>.printName = <span class="hljs-keyword">this</span>.printName.bind(<span class="hljs-keyword">this</span>);<br>  &gt; <span class="hljs-keyword">this</span>.getThis = () =&gt; &#123; 内容&#125;;<br>  &gt; &#125;<br>  &gt; <span class="hljs-comment">//..定义printName(); </span><br></code></pre></td></tr></table></figure>&gt; &#125;&gt;&gt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>&gt; 类字段解决方法 :<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>  &#125;<br>  click = <span class="hljs-function">() =&gt;</span> &#123;<br>    alert(<span class="hljs-built_in">this</span>.value);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//每一个对象都有独立的click方法,内部都有指向该对象的this,  传递到哪里都不会丢失this</span><br><br></code></pre></td></tr></table></figure></code></pre></li></ul><h5 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h5><ul><li><p>类继承是一个类扩展另一个类的一种方式。因此，我们可以在现有功能之上创建新功能。</p></li><li><p>关键字 extends 使用了很好的旧的原型机制进行工作,通过设置[[prototype]] 来进行继承操作 :</p></li><li><blockquote><p><code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 引用：</p><ol><li><p><code>Rabbit</code> 函数原型继承自 <code>Animal</code> 函数。 解释了静态属性为什么会被继承</p></li><li><p><code>Rabbit.prototype</code> 原型继承自 <code>Animal.prototype</code>。</p><p>—–来源于 (静态属性章节)</p></li></ol></blockquote></li></ul><blockquote><p>类中继承时, constructor()也会被继承,其中定义的变量 ,派生类和基类都会各自维护一份</p><p>对于类字段 来说 ,相当于在constructor( ) 中定义变量一样,会被复制</p></blockquote><blockquote><p>prototype属性里面一般只维护函数</p><p>类语法不仅允许指定一个类，在 extends 后可以指定任意表达式。</p></blockquote><h5 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h5><ul><li><p>不希望完全替换父类方法，希望在父类方法的基础上进行调整或扩展其功能,Class 为此提供了 “super” 关键字。 </p></li><li><blockquote><ol><li>执行super.method(…) 来调用一个父类方法 </li><li>执行 super(…) 来调用一个父类 constructor（只能在我们的 constructor 中）</li></ol></blockquote></li><li><blockquote><p>箭头函数没有 super,在类中如果被访问，它会从外部函数获取,但是如果是普通函数调用, 将会抛出错误</p></blockquote><h5 id="重写constructor"><a href="#重写constructor" class="headerlink" title="重写constructor"></a>重写constructor</h5></li><li><p>未提供constructor 时,默认生成:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(...args)</span> </span><br><span class="hljs-function"><span class="hljs-comment">&#123; super(...args); &#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>继承类提供constructor()必须调用 super(…),<strong>并且 (!) 一定要在使用 <code>this</code> 之前调用。</strong></p></li><li><blockquote><p>继承类的构造函数:派生构造器具有特殊的内部属性 <code>[[ConstructorKind]]:&quot;derived&quot;</code>。该标签会影响它的 <code>new</code> 行为:</p><p>当通过 <code>new</code> 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 <code>this</code>。</p><p>当继承的 constructor 执行时，<strong>它不会执行新建空对象并把this传给他的操作</strong>。它期望父类的 constructor 来完成这项工作。</p></blockquote></li><li><p>当我们在构造器(constructor)中访问一个被重写的class字段时, <strong>父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong> </p></li><li><blockquote><p>如果是函数,则是重写这个</p></blockquote><blockquote><p>原因 : 在于类字段初始化的顺序: </p><p>1.对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</p><p>2.对于派生类，在 <code>super()</code> 后立刻初始化</p><p>如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题</p></blockquote></li></ul><h5 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h5><ul><li><p>我们可以把一个方法赋值给类的函数本身，而不是赋给它的 “prototype”。这样的方法被称为 静态的（static） 以 static 关键字开头</p></li><li><pre><code>class User &#123;  static staticMethod() &#123;    alert(this === User); //this是类构造器 User 自身  &#125;&#125;User.staticMethod = function() &#123;  alert(this === User);&#125;;   //在外面作为类的属性赋值作用相同<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br>- &gt; 从技术上讲，静态声明与直接给类本身赋值相同<br>  &gt;<br>  &gt; 静态属性可能不被支持,最新语法<br><br>- 静态属性和方法是可被继承的。详见继承过程<br><br>- &gt; 类的构造函数 也会通过[[prototype]] 链接起来,所以调用静态属性也会通过链进行查找     静态方法也可以<br><br>##### 私有 保护属性<br><br>- 在 JavaScript 中, 有两种类型的对象字段（属性和方法） : 公共 私有 <span class="hljs-comment">(**js语言实际实现的**)</span><br><br>- 受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中**模拟的类定义语法**。<br><br>- &gt;受保护的属性通常以下划线 _ 作为前缀。这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。<br>  &gt;<br>  &gt;受保护的字段是可以被继承的<br><br>- 只读属性 : 只需要设置 getter，而不设置 setter：<br><br>- 私有属性和方法应该以 # 开头。它们只在类的内部可被访问。我们无法从外部或从继承的类中访问它。<br><br>- &gt; getter/setter 访问器 可以让外部访问到私有属性<br><br>- &gt;  JavaScript引擎不支持或部分支持，需要进行填充。<br><br>- 私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 #waterAmount 和公共的 waterAmount 字段。<br><br>- &gt;私有字段不能通过 this[<span class="hljs-string">&#x27;#name&#x27;</span>] 访问<br><br>##### 扩展内建类<br>- 内建的类，例如 <span class="hljs-keyword">Array</span>，Map 等也都是可以扩展的<span class="hljs-comment">(**可被继承**)</span><br><br>- &gt; 继承自原生 `<span class="hljs-keyword">Array</span>` 的类 `PowerArray`<br>  &gt;<br></code></pre></td></tr></table></figure>&gt; class PowerArray extends Array &#123;&gt; isEmpty() &#123;&gt;  return this.length === 0;&gt; &#125;&gt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#125;<br><br><br></code></pre></td></tr></table></figure>&gt; &gt; 内建的方法例如 `filter`，`map` 等 — 返回的正是子类 `PowerArray` 的新对象,原因: 内部使用了对象的 `constructor` 属性来实现这一功能&gt; &gt; &gt; &gt; 优点: 返回结果可以继续调用`PowerArray` 的方法&gt; &gt; 我们也可以使用特殊的静态 getter `Symbol.species`使结果放回一个Array&gt; <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>- 通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承,但内建类却是一个例外。它们相互间不继承静态方法。<br><br>- &gt; 原因 :  构造函数不会<span class="hljs-literal">[[<span class="hljs-identifier">prototype</span>]</span>]指向另一个构造函数<br><br>##### 类检查<br><br>- **instanceof 操作符** 用于检查一个对象是否属于某个特定的 <span class="hljs-keyword">class</span>。同时，它还考虑了继承。<br><br>- &gt;  还可以检查是否对象是或属于特定的构造函数<br><br> 算法的执行过程大致如下 :<br><br> <span class="hljs-number">1.</span> 如果这儿有静态方法 `<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>hasInstance`，那就直接调用这个方法<br> <span class="hljs-number">2.</span> 大多数 <span class="hljs-keyword">class</span> 没有 `<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>hasInstance`,使用 `obj instanceOf Class` 检查 `<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>prototype` 是否等于 `obj` 的原型链中的原型之一<br><br> &gt; ```javascript<br> &gt; obj.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>prototype<br></code></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p><strong>prototypeObj.isPrototypeOf(object)</strong> 方法 , 在该对象object的原型链上搜寻,有的话返回true</p><blockquote><p>例子 : Foo.prototype.isPrototypeOf(baz);</p></blockquote></blockquote><ul><li><p>使用 Object.prototype.toString 方法来揭示类型 ,内建的 toString 方法可以被从对象中提取出来，并在任何其他值的上下文中执行</p></li><li><p>可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的 toString 方法的行为。</p></li><li><p>如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof</p></li></ul><h5 id="Mixin-模式"><a href="#Mixin-模式" class="headerlink" title="Mixin 模式"></a>Mixin 模式</h5><ul><li><p>在 JavaScript 中，我们只能继承单个对象。每个对象只能有一个 [[Prototype]]。并且每个类只可以扩展另外一个类。但是有些时候这种设定（译注：单继承）会让人感到受限制。</p></li><li><p>mixin 是一个包含其他类的方法的类,不需要继承</p></li><li><blockquote><p>方法一 : 构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象,通过拷贝对象完成</p></blockquote></li></ul><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try..catch"></a>try..catch</h5><ul><li><p>try..catch，它使我们可以“捕获（catch）”错误，因此脚本可以执行更合理的操作，而不是死掉</p></li><li><blockquote><p>要使得 try..catch 能工作，代码必须是可执行的。对于代码中的语法错误等导致无法正常工作,</p><p>try..catch 只能处理有效代码中出现的错误。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。</p></blockquote></li><li><p>为了捕获到计划的（scheduled）函数中的异常，那么 try..catch 必须在这个函数内 例如:setTimeout()</p></li><li><blockquote><p>原因在于计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了 try..catch 结构</p></blockquote></li><li><p>发生错误时，JavaScript 生成一个包含有关其详细信息的error 对象。然后将该对象作为参数传递给 catch, </p></li><li><blockquote><p>error 对象具有两个主要属性： </p><p>name :  Error名称    </p><p>message   : 关于 error 的详细文字描述。 人类可读的 error 信息  </p><p> stack : 当前的调用栈</p></blockquote></li><li><p>如果我们不需要 error 的详细信息，catch 也可以忽略它：(新属性 可能有兼容性)  catch不加括号即可</p></li></ul><ul><li><p><code>throw</code> 操作符 :</p></li><li><blockquote><p>为了统一进行 error 处理，我们将使用 <code>throw</code> 操作符。</p><p>通过 throw 关键字 , 可以抛出自定义错误 error对象</p></blockquote></li></ul><ul><li><p><strong>自定义 error</strong>   : 技术上讲，我们可以将任何东西用作 error 对象。  但最好使用对象，最好使用具有 name 和 message 属性的对象, </p></li><li><blockquote><p>JavaScript 中有很多内建的标准 error 的构造器：Error，SyntaxError，ReferenceError，TypeError 等</p><p>对于内建的 error,<code>name</code> 属性刚好就是构造器的名字。<code>message</code> 则来自于参数（argument）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(message);<br><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(message); <span class="hljs-comment">// 通过内建构造器自定义error对象</span><br><br><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Things happen o_O&quot;</span>);<br><br>alert(error.name); <span class="hljs-comment">// Error</span><br>alert(error.message); <span class="hljs-comment">// Things happen o_O</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>为什么<strong>重新抛出 error</strong></p></li><li><blockquote><p>当我们使用<code>try..catch</code> 旨在捕获“数据不正确”的 error, 出现了编程错误意外,这时依然会被catch捕捉, 并显示数据不正确的错误</p><p>这是不正确的, 为了避免这类问题, 我们采用重新”抛出”, <strong><code>catch</code> 应该只处理它知道的 error，并“抛出”所有其他 error。</strong>留给其他catch处理,  </p><p>具体解释:</p><ol><li>Catch 捕获所有 error。</li><li>在 <code>catch(err) &#123;...&#125;</code> 块中，我们对 error 对象 <code>err</code> 进行分析。我们可以使用 <code>instanceof</code> 操作符判断错误类型,还可以使用err.name 获取错误的类名</li><li>如果我们不知道如何处理它，那我们就 <code>throw err</code>。</li></ol><p>使用err.name类名 还是 instanceof 分析error对象, 尽量使用instanceof,<code>instanceof</code> 检查对于新的继承类也适用。所以这是面向未来的做法。</p></blockquote></li></ul><ul><li><p><strong>try…catch…finally 语句</strong>:</p></li><li><blockquote><p> finally 子句（clause）通常用在：当我们开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。  try存在显式的return   throw 也还是会执行finally </p></blockquote><p><strong>全局错误处理</strong></p><blockquote><p>设想一下，在 <code>try..catch</code> 结构外有一个致命的 error，然后脚本死亡了。这个 error 就像编程错误或其他可怕的事儿那样。我们可能想要记录这个 error，并向用户显示某些内容</p><p>这时需要全局错误处理程序,</p><p>全局错误处理程序 window.onerror 的作用通常不是恢复脚本的执行 — 如果发生编程错误，那这几乎是不可能的，它的作用是将错误信息发送给开发者。也有针对这种情况提供错误日志的 Web 服务</p></blockquote></li></ul><h5 id="自定义-Error，扩展-Error"><a href="#自定义-Error，扩展-Error" class="headerlink" title="自定义 Error，扩展 Error"></a>自定义 Error，扩展 Error</h5><ul><li><p>当我们在开发某些东西时，经常会需要我们自己的 error 类来反映在我们的任务中可能出错的特定任务.,这些类需要支持基本的error基本属性 : name,message ,还可能有属于它们自己的属性, 所以我们需要扩展ERROR</p></li><li><blockquote><p>JavaScript 允许将 <code>throw</code> 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 <code>Error</code> 中继承。但是，如果我们继承，那么就可以使用 <code>obj instanceof Error</code> 来识别 error 对象。因此，最好继承它。</p></blockquote></li><li><p>包装异常 : 多种error 会发生,但是没必要检查所有的error类型,新建一个抽象的erroer类型,用来表示一类的error , 如果需要更多 error 细节，那么可以检查 抽象异常类的 cause 属性</p></li></ul><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><ul><li><p>所以回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景</p></li><li><blockquote><p>异步行为: 我们现在开始执行的行为,  但它们会在稍后完成。</p></blockquote></li><li><p>“基于回调”的异步编程风格。异步执行某项功能的函数应该提供一个 callback 参数用于在相应事件完成时调用。</p></li><li><p>厄运金字塔 :“基于回调”的异步编程如果有过度的嵌套和回调使得结构混乱, 所以是用 <strong>promisde</strong> 解决.</p></li></ul><h5 id="promise操作"><a href="#promise操作" class="headerlink" title="promise操作"></a>promise操作</h5><ul><li><p>promise 构造语法 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//executor</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>当 new Promise 被创建，executor 会自动运行(我们的代码仅在 executor 的内部),它的参数 resolve 和 reject 是由 JavaScript 自身提供的回调</p><p>运行结束后，如果成功则调用 resolve(value)，如果出现 error 则调用 reject。 reject(error);</p><p>executor 中只能调用一个 resolve <strong>或</strong>一个 reject。任何状态的更改都是最终的。所有其他的再对 resolve 和 reject 的调用都会被忽略</p><p>并且，<code>resolve/reject</code> 只需要一个参数（或不包含任何参数），并且将忽略额外的参数</p></blockquote></li><li><blockquote><p>executor 通常是异步执行某些操作  ,但是Resolve/reject 是可以立即进行的</p></blockquote></li></ul><ul><li><p>由 new Promise 构造器返回的 promise 对象具有以下内部属性：</p><pre><code>state — 最初是 &quot;pending&quot;，然后在 resolve 被调用时变为 &quot;fulfilled&quot;，或者在 reject 被调用时变为 &quot;rejected&quot;。result —最初是 undefined，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。(待考证..)一个 resolved 或 rejected 的 promise 都会被称为 “settled”。</code></pre></li><li><p>Promise 对象的 state 和 result 属性都是内部的。我们无法直接访问它们。但我们可以对它们使用 .then/.catch/.finally 方法</p></li></ul><ul><li><p>then 语法 :  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">  promise.then(<br>  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> </span>&#123; <span class="hljs-comment">/* handle a successful result */</span> &#125;,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123; <span class="hljs-comment">/* handle an error */</span> &#125;<br>);<br>如果我们只对成功完成的情况感兴趣，那么我们可以只为 .then 提供一个函数参数,如果我们只对 error 感兴趣，那么我们可以使用 <span class="hljs-literal">null</span> 作为第一个参数<br></code></pre></td></tr></table></figure></li><li><blockquote><p>.catch(f)  语法  :    是.then(null, f) 的完全的模拟，它只是一个简写形式。 只捕获错误情况,</p></blockquote></li><li><blockquote><p>.finally(f)  ，f 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject。</p><p>在 finally 中，我们不知道 promise 是否成功,finally 处理程序将结果和 error 传递给下一个处理程序。 f:处理程序没有参数</p></blockquote></li><li><p>如果 promise 为 pending 状态，**.then/catch/finally 处理程序（handler）将等待它**。否则，如果 promise 已经是 settled 状态，它们就会立即执行：</p></li></ul><h5 id="promise链-用来连续的处理回调函数"><a href="#promise链-用来连续的处理回调函数" class="headerlink" title="promise链 :用来连续的处理回调函数,"></a>promise链 :用来连续的处理回调函数,</h5><ul><li><p><strong>将多个 <code>.then</code> 添加到一个 promise 上。但这并不是 promise 链</strong>,这是promise  的几个处理程序</p></li><li><p>.then中所使用的处理程序创建并返回一个 promise。在这种情况下，其他的处理程序（handler）将等待它 settled 后再获得其结果,这样可以构建一条promise链</p></li><li><blockquote><p>当then() 函数中<strong>不创建并返回</strong>一个promise时, 而是return 一个值,会直接进行下一轮then()的调用,不会等待其中的异步调用</p><p>then() 函数处理完后,默认返回一个成功处理的promise,</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 =<span class="hljs-keyword">new</span>  <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span> &#123;<br>       reject(<span class="hljs-string">&quot;rejiec&quot;</span>);<br>   &#125;);<br>   p1.then(<br>       value =&gt;&#123;<span class="hljs-built_in">console</span>.log(value); &#125;,<br>       reason =&gt; &#123;<span class="hljs-built_in">console</span>.log(reason)&#125;<br>        <br>    <br>   ).then(<br>       a =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;asdf&quot;</span>), <span class="hljs-comment">// 第一个then 不管进行那个处理,都会进行这一行操作</span><br>       b =&gt; <span class="hljs-built_in">console</span>.log(b)<br>   );<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>确切地说，处理程序（handler）返回的不完全是一个 promise，而是返回的被称为 “thenable” 对象 — 一个具有方法 .then 的任意对象。它会被当做一个 promise 来对待。这个特性允许我们将自定义的对象与 promise 链集成在一起，而不必继承自 Promise。</p></blockquote></li><li><p>promise链是向下增长 , 嵌套式的promise调用是向右增长</p></li><li><p>then()  函数的功能在于,等promise处理完后完成回调函数的功能</p></li></ul><h5 id="promise-处理错误"><a href="#promise-处理错误" class="headerlink" title="promise 处理错误"></a>promise 处理错误</h5><ul><li><blockquote><p> 捕获所有 error 的最简单的方法是，将 .catch 附加到链的末尾</p></blockquote></li><li><p>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 try..catch”。如果发生异常，它就会被捕获，并被视为 rejection 进行处理。使用catch就可以捕获上述的异常</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>));  <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>); 效果是一样的<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在常规的 try..catch 中，如果我们无法处理它，可以将其再次抛出。对于 promise 来说，这也是可以的。如果我们在 .catch 中 throw error，那么它会忽略其他的处理程序跳转到下一个catch。如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 .then 处理程序（handler）。</p></li><li><p>当一个 error 没有被处理会发生什么？例如，我们忘了在链的尾端附加 .catch, 如果出现 error，promise 的状态将变为 “rejected”,   然后执行应该跳转至最近的 rejection 处理程序, 如果没有, JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error </p></li><li><blockquote><p>在浏览器中，我们可以使用 unhandledrejection 事件来捕获这类 error, 这个事件对象有两个特殊的属性</p><p>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  alert(event.promise); <span class="hljs-comment">// [object Promise] - 生成该全局 error 的 promise</span><br>  alert(event.reason); <span class="hljs-comment">// Error: Whoops! - 未处理的 error 对象</span><br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h5><ul><li><p>在 Promise 类中，有 5 种静态方法。</p></li><li><blockquote><p> all allSettled  race  resolve/reject </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> <span class="hljs-built_in">Promise</span>.all([<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">3000</span>)), <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">2000</span>)), <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">3</span>), <span class="hljs-number">1000</span>))  <span class="hljs-comment">// 3</span><br>]).then(alert); <span class="hljs-comment">// 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素</span><br><br>如果任意一个 promise 被 reject，由 <span class="hljs-built_in">Promise</span>.all 返回的 promise 就会立即 reject，并且带有的就是这个 error。<br>完全忽略列表中其他的 promise。它们的结果也被忽略。<br><br><br><span class="hljs-number">2.</span>我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。<br>让我们使用 <span class="hljs-built_in">Promise</span>.allSettled：<br><br><span class="hljs-number">3.</span> 与 <span class="hljs-built_in">Promise</span>.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）<br>第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。<br><br><span class="hljs-number">4.</span><span class="hljs-built_in">Promise</span>.resolve(value) 用结果 value 创建一个 resolved 的 promise。 <span class="hljs-built_in">Promise</span>.reject(error) 用 error 创建一个 rejected 的 promise。 当一个函数被期望返回一个 promise 时，这个方法用于兼容性 ,<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span> 语法已经替代<br><br><br></code></pre></td></tr></table></figure><h5 id="Promisification"><a href="#Promisification" class="headerlink" title="Promisification"></a>Promisification</h5></li><li><p>“Promisification”   它指将一个接受回调的函数转换为一个返回 promise 的函数。</p></li><li><p>(有待扩充)</p><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5></li><li><p>Promise 的处理程序（handlers）.then、.catch 和 .finally 都是异步的。</p></li><li><blockquote><p>即便一个 promise 立即被 resolve，</p><p>.then、.catch 和 .finally  函数,还是会在别的语句执行完之后 执行 ,原因在于微任务队列的规定</p><p>如果想要改变这种顺序,把语句加入then() 函数中</p></blockquote></li><li><blockquote><p>异步任务需要适当的管理。为此，ECMA 标准规定了一个内部队列 PromiseJobs，通常被称为“微任务队列（microtask queue）”（ES8 术语）。</p><p>队列规范:</p><p>队列（queue）是先进先出的：首先进入队列的任务会首先运行。<br>只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务</p></blockquote></li><li><p>未处理的 rejection : 如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”。如果我们忘记添加 .catch，那么，微任务队列清空后，JavaScript 引擎会触发unhandledrejection 事件, </p></li></ul><h5 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h5><ul><li><p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法</p></li><li><p>async function()  这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p></li><li><p>await 它只在 async 函数内工作, 字面的意思就是让 JavaScript 引擎等待直到 promise settle，(async 函数会在暂停在哪一行, 直到得到promise settle)然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p></li><li><blockquote><p>相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，用它来代替.then获得promise 的结果</p></blockquote></li><li><p>await 接受 “thenables”, await 允许我们使用 thenable 对象（那些具有可调用的 then 方法的对象)</p></li><li><p>如果一个 promise 正常 resolve，await promise 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 throw 语句那样。</p></li><li><blockquote><p>try ..catch 语法去捕获这个错误 ,或者使用 async函数().catch() ,一般我们使用await就不再使用then等方法. </p></blockquote></li><li><blockquote><p>async/await 可以和 Promise.all 一起使用 等待多个promise的结果</p></blockquote></li></ul><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><blockquote><p>Generator 可以按需一个接一个地返回（“yield”）多个值。它们可与 iterable 完美配合使用，从而可以轻松地创建数据流。</p></blockquote><ul><li><p>创建一个 generator，我们需要一个特殊的语法结构：function* ,在此类函数被调用时，它不会运行其代码。而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。</p></li><li><p>一个 generator 的主要方法就是 next(),next() 的结果始终是一个具有两个属性的对象： </p></li><li><p> value: 产出的（yielded）的值。done: 如果 generator 函数已执行完成则为 true，否则为 false。</p></li><li><p> generator 是 可迭代（iterable）的,因为当 done: true 时，for..of 循环会忽略最后一个 value(return返回的值)</p></li><li><p>我们可以通过提供一个 generator 函数作为 Symbol.iterator，来使用 generator 进行迭代：</p></li><li><p>Generator 组合 我们可以使用 yield* 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中：</p></li></ul><h4 id="模块-moudule"><a href="#模块-moudule" class="headerlink" title="模块 (moudule)"></a>模块 (moudule)</h4><ul><li><p>模块的核心功能:</p></li><li><blockquote><p>模块始终默认使用 use strict。</p><p>每个模块都有自己的块作用域</p><p>模块代码仅在第一次导入时被执行,然后将导出的内容提供给所有的导入。当改变其中的对象时其他模块随之改变</p></blockquote></li><li><blockquote><p><code>import.meta</code> 对象包含关于当前模块的信息,   它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。</p></blockquote></li><li><p>在浏览器中使用模块 , 必须有 type=”module”</p></li><li><blockquote><p>下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code></p></blockquote></li></ul><ul><li><p>模块脚本总是被延迟的 :</p></li><li><blockquote><p>下载外部模块脚本不会阻塞 HTML 的处理，它们会与其他资源并行加载。</p><p>模块脚本会等到 HTML 文档完全准备就绪,然后执行。而常规脚本则会立即运行，</p></blockquote></li></ul><ul><li><p>对于非模块脚本，async 特性（attribute）仅适用于外部脚本。异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档。 对于模块脚本，它也适用于内联脚本</p></li><li><p>使用打包工具的一个好处是 —— 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能，例如 CSS/HTML 模块等。</p><blockquote><p>import export 写在开头结尾都可以</p></blockquote></li></ul><h4 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h4><ul><li><blockquote><p>导出</p><ol><li><p>在声明前导出</p></li><li><p>导出与声明分开    <strong>export {sayHi, sayBye};</strong> // 导出变量列表*</p></li></ol><p>导入</p><ol start="3"><li>使用 <code>import * as &lt;obj&gt;</code> 将所有内容导入为一个对象    <strong>import * as say from ‘./say.js’;</strong>  导出say对象,或者使用import { } from ‘say.js’  导入所有</li><li><strong>import {sayHi} from ‘./say.js’;</strong>  明确导入那个</li></ol></blockquote></li></ul><blockquote><p>大部分 JavaScript 样式指南都不建议在函数和类声明后使用分号。</p></blockquote><ul><li><blockquote><p> 使用 <code>as</code> 让导入具有不同的名字 , </p><p><strong><em>import {sayHi as hi, sayBye as bye} from ‘./say.js’;</em></strong></p><p><strong>export {sayHi as hi, sayBye as bye};</strong></p></blockquote></li></ul><ul><li><p>主要有两种模块: </p></li><li><blockquote><p>1.包含库或函数包的模块  </p><p>2.声明单个实体的模块(更倾向 以便每个“东西”都存在于它自己的模块中)</p><p>export default 语法，以使“一个模块只做一件事”的方式看起来更好,在单个实体模块中添加 export default</p><p><strong>import <em>User</em> from ‘./user.js’;</strong>  将其导入而不需要花括号：  每个文件最多只能有一个默认的导出</p></blockquote></li></ul><ul><li><p>重新导出（Re-export）”</p></li><li><blockquote><p>语法:   <strong>export {login, logout} from ‘./helpers.js’;</strong>  相当于 = &gt; </p><p>import {login, logout} from ‘./helpers.js’; </p><p>export {login, logout};</p></blockquote></li><li><blockquote><p> 重新导出只导出了命名的导出，但是忽略了默认的导出，</p><p> 默认导出需要单独处理 , 要重新导出默认导出，我们必须明确写出 export {default as User} </p><blockquote><p> 重新导出默认的导出的这种奇怪现象是某些开发者不喜欢它们的原因之一。</p></blockquote></blockquote></li><li><p><strong>请注意在 <code>&#123;...&#125;</code> 中的 import/export 语句无效。</strong> </p></li></ul><ul><li><p>动态导入 : 根据条件或者在运行时导入</p></li><li><blockquote><p>import(module) 表达式加载模块并返回一个 promise，</p><p>该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。</p><p><strong>let {hi, bye} = await import(‘./say.js’);</strong></p></blockquote></li><li><blockquote><p>动态导入在常规脚本中工作时，它们不需要 script type=”module”. </p><p>尽管 import() 看起来像一个函数调用，但它只是一种特殊语法,不是真正的函数</p></blockquote></li><li></li></ul><h4 id="Generator，高级-iteration-杂项有待扩展…"><a href="#Generator，高级-iteration-杂项有待扩展…" class="headerlink" title="Generator，高级 iteration  杂项有待扩展…."></a>Generator，高级 iteration  杂项有待扩展….</h4><ul><li><p>常规函数只会返回一个单一值（或者不返回任何值）。</p><p>而 Generator 可以按需一个接一个地返回（“yield”）多个值。它们可与 <a href="https://zh.javascript.info/iterable">iterable</a> 完美配合使用，从而可以轻松地创建数据流。</p></li><li><p>异步迭代器（iterator）允许我们对按需通过异步请求而得到的数据进行迭代。例如，我们通过网络分段（chunk-by-chunk）下载数据时。异步生成器（generator）使这一步骤更加方便。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8A/"/>
    <url>/2020/12/14/Js-dom/js%20%E5%86%8D%E5%87%BA%E5%8F%91%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="JS-入门精通"><a href="#JS-入门精通" class="headerlink" title="JS 入门精通"></a>JS 入门精通</h2><h4 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h4><ul><li>JS在任意搭载了 JavaScript 引擎 的设备中都可以执行<blockquote><p>V8 —— Chrome 和 Opera 中的 JavaScript 引擎。<br>SpiderMonkey —— Firefox 中的 JavaScript 引擎。</p></blockquote></li><li>现代的 JavaScript 是一种“安全”语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能</li><li>“use strict” 严格模式 原因:最初的js代码语法太过松散,但是为了兼容旧版本所以需要手动开启严格模式</li></ul><h4 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h4><ul><li>let var   变量</li><li>常量 : const   初始赋值之后就不会改变。</li><li><blockquote><p>大写命名的常量仅用作“硬编码（hard-coded）”值的别名。常规命名用作执行中被计算出的值<br>变量代码规范:  变量的名要尽量具体,远离a b这种,或者data value这种,相当于没说明这变量的用处,变量是重用还是新建: 额外声明一个变量绝对是利大于弊的</p></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4></li><li>在 JavaScript 中有 8 种基本的数据类型(7 种原始类型和 1 种引用类型)<blockquote><p>在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0(得到infinity)，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。</p></blockquote></li></ul><ol><li><p>number 类型代表整数和浮点数。</p></li><li><p>BigInt 类型，用于表示任意长度的整数(有些大数据超出了number表示范围)。可以通过将n附加到整数字段的末尾来创建 BigInt 值。</p></li><li><p>String 类型, JavaScript 中的字符串必须被括在引号里。有三种包含字符串的方式:单/双引号,反引号</p><blockquote><p>反引号是功能扩展引号。它们允许我们通过将变量和表达式包装在 ${…}中<br>可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。仅仅在反引号内有效</p></blockquote></li><li><p>boolean 类型仅包含两个值：true 和 false。</p></li><li><p>undefined 的含义是未被赋值。如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.</p></li><li><p>symbol 类型,(在ECMAScript 6 中新添加的类型)。一种实例是唯一且不可改变的数据类型。</p></li><li><p>null null类型值只有一个(null), (JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。) 例如 : let a = null;</p></li><li><p>Object类型(引用类型)</p></li></ol><ul><li><p>typeof 运算符返回参数的类型 支持两种方式  作为运算符：typeof x。 函数形式：typeof(x)。</p><blockquote><p>NaN 即 Not a Number 它是用来表示是否属于number类型的一种状态,不属于类型/值</p></blockquote><h4 id="交互函数"><a href="#交互函数" class="headerlink" title="交互函数"></a>交互函数</h4></li><li><p>alert、prompt 和 confirm</p></li><li><p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4></li><li><p>隐式类型转换</p><ul><li>大多数情况下，运算符和函数会自动将赋予他们的值转换为正确的类型。</li><li><blockquote><p>例如: alert 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字</p></blockquote></li></ul></li><li><p>显示类型转换</p><ul><li>我们也可以显式地调用 String(value) 来将 value 转换为字符串类型</li><li>使用 Number(value) 显式地将这个 value 转换为 number 类型,如果该字符串不是一个有效的数字，转换的结果会是 NaN .</li><li><blockquote><p>例如:alert( Number(“123z”) );// NaN （从字符串“读取”数字，读到 “z” 时出现错误）</p></blockquote></li></ul></li><li><p>number 类型转换规则： </p><pre><code> undefined       NaN   null            0    true和false  1 and 0</code></pre></li><li><p>布尔型转换 转换规则如下：</p><pre><code>  直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。  其他值变成 true。  字符串 &quot;0&quot; 是 true 例如;alert(Boolean(&quot;0&quot;));// true</code></pre></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>“ ** “ 运算符  =&gt;   2**3 等于 2^3</p></li><li><p>“+” 运算符中(二元运算符), 只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</p></li><li><blockquote><p>alert( ‘1’ + 2 ); // “12”</p></blockquote></li><li><p>“+” 运算符中(一元运算符),会将其转化为数字。</p></li><li><blockquote><p>一元运算符+ ,可以转换成数字  alert( +true ); // 1</p></blockquote></li><li><p>对于其他算术运算符,仅使用数字，并且始终将其操作数转换为数字。</p><blockquote><p>alert( 6 - ‘2’ ); // 4</p></blockquote></li><li><p>逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。</p><blockquote><p>例子 : for (a = 1, b = 3, c = a * b; a &lt; 10; a++)</p></blockquote></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><p> “||” 运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</p></li><li><p> “&amp;&amp;” 运算的链中,返回第一个假值，如果没有假值就返回最后一个值。</p></li><li><p>! 表示布尔非运算 , 首先转换为布尔值,再给出相反值 </p></li><li><blockquote><p>!! 有时候用来将某个值转化为布尔类型：</p></blockquote></li></ul><h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><ul><li><p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p></li><li><p>普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false,因为两侧的值会先被转化为数字,如果想在进行比较时不会做任何的类型转换。使用 === 符号</p></li><li><p>null 和 undefined 进行比较,当使用严格相等 === 比较二者时,它们不相等，因为它们属于不同的类型。</p></li><li><p>当使用非严格相等 == 比较二者时,JavaScript 存在一个特殊的规则，会判定它们相等。</p></li><li><blockquote><p>undefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值</p></blockquote></li><li><p>“!=”  “!==” 之间的差别 : “!=” 会进行数据转换比较,” !== “不会,数据类型不同就不存在相等</p><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4></li><li><p>if判断 , 循环语句,  : ?语句</p></li><li><p>跳出嵌套循环  标签 + break/continue </p><blockquote><p>outer: for (let i = 0; i &lt; 3; i++) 标签后加循环语句<br>只有在循环内部才能调用 break/continue，并且标签必须位于指令上方的某个位置。</p></blockquote></li><li><p>switch case中不会进行类型转换,如果类型不相等就不匹配</p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h4 id="函数参数return值"><a href="#函数参数return值" class="headerlink" title="函数参数return值"></a>函数参数return值</h4><ul><li><p>函数参数</p></li><li><blockquote><p>函数修改的是复制的变量值副本,对原来的值并没有影响(浅拷贝)</p></blockquote></li><li><p>函数参数–默认值 </p></li><li><blockquote><p>如果调用带参数的函数,未提供参数，也没有给默认值, 这时参数默认 为undefined</p></blockquote></li><li><blockquote><p>function showMessage(from, text = “no text given”)  在等号后给与默认参数</p></blockquote></li><li><p>空值的 return 或没有 return 的函数返回值为 undefined</p></li></ul><h4 id="函数表达式-函数声明"><a href="#函数表达式-函数声明" class="headerlink" title="函数表达式 函数声明"></a>函数表达式 函数声明</h4><ul><li><p>函数声明和函数表达式的区别</p><ul><li><p>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</p></li><li><p>函数声明,调用时不在乎函数声明的位置(这是内部算法的原故,当 JavaScript 准备 运行脚本时，首先会在脚本中寻找全局函数声明)</p></li></ul></li></ul><blockquote><p>函数表达式结尾有一个分号 ;，而函数声明没有,因为它不是代码块而是一个赋值语句</p></blockquote><ul><li>在其他编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待 </li><li><blockquote><p>例如 alert(sayHi) 会输出函数的源码而不会被调用,想要调用需要有括号</p></blockquote></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li><p>回调函数 : 函数参数是另一个函数名字(不带括号), </p></li><li><p>函数参数可以是匿名函数,但是函数外无法调用,</p></li><li><blockquote><p>  例如:   ask( function() { alert(“You agreed.”); },)</p></blockquote><blockquote><p>函数命名 :一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为 例如 show cacl create</p></blockquote></li></ul><h4 id="箭头函数-深入理解箭头函数式"><a href="#箭头函数-深入理解箭头函数式" class="headerlink" title="箭头函数 + 深入理解箭头函数式"></a>箭头函数 + 深入理解箭头函数式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 花括号表示开始一个多行函数</span><br>  <span class="hljs-keyword">let</span> result = a + b;<br>  <span class="hljs-keyword">return</span> result;       <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的“return”</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>箭头后是返回值  如果没有参数，括号将是空的（但括号应该保留）</p><p>参数只有一个,不需要括号</p></blockquote><ul><li><p>箭头函数可以像函数表达式一样使用</p></li><li><p>箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的</p><hr></li><li><p>箭头函数没有 “this” , 如果访问 this，则会从外部获取。</p></li><li><blockquote><p>不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 new 调用它们。</p></blockquote></li><li><p>箭头函数没有 “arguments”</p></li><li><p>箭头函数和 bind函数的区别 :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">bind(<span class="hljs-keyword">this</span>)创建了一个该函数的“绑定版本”。<br>箭头函数=&gt; 没有创建任何绑定。箭头函数只是没有<span class="hljs-keyword">this</span>。<br><span class="hljs-keyword">this</span> 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。 <br></code></pre></td></tr></table></figure></li></ul><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h4><blockquote><p>let user = new Object(); // “构造函数” 的语法   创建空对象<br>let user = {};  // “字面量” 的语法</p></blockquote><h4 id="定义-操作对象属性"><a href="#定义-操作对象属性" class="headerlink" title="定义/操作对象属性"></a>定义/操作对象属性</h4><ul><li>我们可以随时添加、删除和读取文件。通过 .运算符    delete关键字 </li><li>对于多词属性，点操作就不能用了</li><li><blockquote><p>user.likes birds = true  // 报错 用方括号 user[“likes birds”] = true;</p><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方法</p><p>当属性名是已知且简单的时候，就是用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p></blockquote></li></ul><blockquote><p>带有cosnt的对象内容仍然可以被更改, 但是以对象为整体无法改变<br>例如: constn user = { ame: “John”};  user=…  会出现报错,但是更改name的值是允许的</p></blockquote><ul><li>计算属性  : 当创建一个对象时，我们可以在对象字面量中使用方括号</li><li><blockquote><p>let fruit = prompt(“Which fruit to buy?”, “apple”);</p><p>let bag = {</p><p>[ fruit]: 5, // 属性名是 fruit 计算得到的</p><p>};</p></blockquote></li></ul><p>属性的其他操作</p><ul><li><p> 属性值缩写 :</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">function</span></span> makeUser(<span class="hljs-keyword">name</span>, age) &#123;  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-keyword">name</span>, // 与 <span class="hljs-keyword">name</span>: <span class="hljs-keyword">name</span> 相同<br>    age,  // 与 age: age 相同<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>属性名称限制 :</p></li><li><blockquote><p>不能是保留字,其他类型会自动转换为字符串类型   , 如果是复杂的标识名,加上引号声明</p><p>例如: {0:test  “ee er”:22}  0转换为字符串  </p></blockquote></li><li><p>检查属性是否存在 :</p></li><li><blockquote><p>使用操作符 “in”  例如: “key” in objectname</p><p>为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：for..in</p></blockquote></li><li><blockquote><p>js可以访问任何对象的属性,就算该属性不存在也不会发生错误,返回一个undefined类型</p></blockquote></li><li><p>对象属性顺序 : 整数属性会被进行排序，其他属性则按照创建的顺序显示(保证在遍历对象时,它的顺序可预知)</p></li><li><blockquote><p>这里的“整数属性”指的是一个可以在不作任何更改的情况下转换为整数的字符串</p><p>“49” 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样。但是 “+49” 和 “1.2” 就不行了</p></blockquote></li></ul><h4 id="对象拷贝-引用"><a href="#对象拷贝-引用" class="headerlink" title="对象拷贝 引用"></a>对象拷贝 引用</h4><blockquote><p>对象与原始类型其中一个基本的区别是：对象“通过引用的形式”被存储和拷贝,所以对象只有一份</p></blockquote><ul><li>变量存储的不是对象自身，而是该对象的“内存地址”，换句话说就是一个对该对象的“引用”</li><li><blockquote><p>对于对象来说，普通相等 == 和严格相等 === 是两个作用结果完全一样的运算符</p></blockquote></li></ul><ul><li><p>对象拷贝  :</p></li><li><p>通过 for…in进行对象属性的复制, 如果对象中嵌套对象,在循环中进行判断,通过复制嵌套对象的结构完成拷贝(深拷贝)</p></li><li><blockquote><p>也可以使用其他js库中的方法,  这些拷贝方法都不能拷贝到不能列举的属性</p></blockquote></li><li><p>通过 Object.assign() 进行浅拷贝 =&gt; 对象中有另一个对象时,Object.assign()只会拷贝引用 (浅拷贝)</p></li><li><blockquote><p>Object.assign(dest, [src1, src2, src3..])</p><p>src : 对象, 可以是多个对象合并到dest</p></blockquote></li></ul><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><blockquote><p>作为对象属性的函数被称为 方法。</p></blockquote><pre><code>通过属性名添加函数:   user.sayHi = function() &#123;alert(&quot;Hello!&quot;);&#125;;在对象中简写方法      user = &#123;  sayHi: function() &#123; alert(&quot;Hello&quot;);&#125;&#125;; 更简单的书写          user = &#123;  sayHi()&#123;alert(&quot;fog);&#125; &#125;通过属性名添加函数名  function sayHi() &#123; alert(&quot;Hello!&quot;);&#125;;  user.sayHi = sayHi;</code></pre><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li>可达性</li><li><blockquote><p>对于不可达的对象 数据,进行垃圾处理</p></blockquote></li><li>垃圾回收算法: 垃圾收集器找到所有的根，并“标记”（记住）它们。然后它遍历并“标记”来自它们的所有引用用,没有被标记的就被删除。 算法还有很多优化这里不再提及</li></ul><h4 id="方法中的”this”"><a href="#方法中的”this”" class="headerlink" title="方法中的”this”"></a>方法中的”this”</h4><ul><li><p>作为对象属性的函数被称为 <strong>方法</strong>。</p></li><li><blockquote><p>为了访问该对象，方法中可以使用 <code>this</code> 关键字。<code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p></blockquote></li><li><p>为什么在方法中使用this?</p></li><li><blockquote><p>使用变量名访问数据不太可靠,当我们换了一个对象访问该方法,以前的数据还是旧数据</p></blockquote></li><li><p>在没有对象的情况下(全局函数)调用：</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> == undefined  严格模式下的 <span class="hljs-keyword">this</span> 值为 undefined <br>在非严格模式的情况下，<span class="hljs-keyword">this</span> 将会是全局对象<br><br></code></pre></td></tr></table></figure><ul><li><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数。<code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p></li><li><blockquote><p>当函数分配给对象时,运行方法,this的值才会计算出来</p><p>它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p></blockquote><ul><li>this 功能主要使用在 方法上, 用在函数中this表示</li></ul></li></ul><h4 id="构造函数-new"><a href="#构造函数-new" class="headerlink" title="构造函数  new"></a>构造函数  new</h4><ul><li>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要<strong>创建许多类似</strong>的对象,例如多个用户. 这时需要构造函数, 构造器的主要目的 —— 实现可重用的对象创建代码</li><li>构造函数在技术上是常规函数。不过有两个约定：</li></ul><p> 1.它们的命名以大写字母开头。<br> 2.它们只能由 “new” 操作符来执行。</p><ul><li>new通过构造函数创建对象的过程<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let user= <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(<span class="hljs-string">&quot;john&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span></span>(name) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;（隐式创建）</span><br><br>  <span class="hljs-comment">// 添加属性到 this</span><br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.isAdmin = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// return this;（隐式返回）</span><br>&#125;<br>构造函数只能使用 `<span class="hljs-keyword">new</span><span class="hljs-type"></span>` 来调用。这样的调用意味着在开始时创建了空的 `<span class="hljs-built_in">this</span>`，并在最后返回填充了值的 `<span class="hljs-built_in">this</span>`。<br></code></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行</p></blockquote><blockquote><p>在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。true 被new调用</p></blockquote></li><li><p>如果我们有许多行用于创建<strong>单个复杂对象</strong>的代码，我们可以将它们封装在构造函数中: </p></li><li><pre><code class="javascript">let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码&#125;;<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">  <br>- 通常，构造器没有 <span class="hljs-keyword">return</span> 语句。它们的任务是将所有必要的东西写入 <span class="hljs-built_in">this</span>，并自动转换为结果<br><br>- &gt; 带有对象的 <span class="hljs-keyword">return</span> 返回该对象，在所有其他情况下返回 <span class="hljs-built_in">this</span>。<br><br><br><br><br><br><span class="hljs-comment">#### 可选链运算</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- 可选链 `?.` 是一种访问**嵌套对象属性**的防错误方法。即使中间的属性不存在，也不会出现错误。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      可选链 ?. 语法有三种形式：</span><br><span class="hljs-comment">      obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。</span><br><span class="hljs-comment">      obj?.[ prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。</span><br><span class="hljs-comment">      obj?.method() —— 如果 obj 存在则调用 obj.method()，否则返回 undefined。</span><br><span class="hljs-comment">      ?. 检查左边部分是否为 null/undefined，如果不是则继续运算。?. 链使我们能够安全地访问嵌套属性。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&gt; 但是，我们应该谨慎地使用 ?.，仅在当左边部分不存在也没问题的情况下使用为宜。以保证在代码中有编程上的 error 出现时，也不会对我们隐藏</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment"># Symbol 类型</span><br>- “<span class="hljs-built_in">Symbol</span>” 值表示**唯一的标识符**,即使我们创建了许多具有相同描述的 <span class="hljs-built_in">Symbol</span>，它们的值也是不同。<br><br>- &gt; let id = <span class="hljs-built_in">Symbol</span>();  <br>  &gt;<br>  &gt; 添加描述 let id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>  <br><br>- &gt; <span class="hljs-built_in">Symbol</span> 不会被自动转换为字符串,为了防止字符串和<span class="hljs-built_in">Symbol</span>类型混淆<br>  &gt;<br>  &gt; 可以通过函数 Tostring()转换为字符串显示 <br>  &gt;<br>  &gt; 通过symbol.description 属性，只显示描述.<br><br>  <br><br>- <span class="hljs-built_in">Symbol</span> 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能**意外访问**或重写这些属性。<br><br>- &gt; <span class="hljs-string">&quot;隐藏&quot;</span> 指的是<span class="hljs-built_in">Symbol</span> 类型的属性,不会被`<span class="javascript"><span class="hljs-keyword">for</span>..in </span>`列举出来 `<span class="javascript"><span class="hljs-built_in">Object</span>.keys(user)</span>` 也会忽略它们。<br>  &gt;<br>  &gt; 使用enumberable属性标志也不会被枚举, 但是<span class="hljs-built_in">console</span>.log还是会显示<br>  &gt;<br>  &gt; `<span class="javascript">[<span class="hljs-built_in">Object</span>.assign]</span>`会同时复制字符串和 symbol 属性, 但不会复制enumberable : <span class="hljs-literal">false</span>的属性<br>&gt; 如果我们使用的是属于第三方代码的 user 对象，我们想要给它们添加一些属性。<br>&gt;<br>&gt; 如果使用 字符串添加, 很容易引起冲突, 但是使用<span class="hljs-built_in">Symbol</span> 创建,就算描述一样,返回的也是不同的值,不会引起冲突<br><br>- 创建<span class="hljs-built_in">Symbol</span>返回值名字 和 属性名一样, 也不会有问题, 但是调用<span class="hljs-built_in">Symbol</span>属性必须加上[], 如果有点符号调用则是普通的属性名<br><br>&gt; ```<span class="javascript">javascript</span><br><span class="javascript">&gt; <span class="hljs-keyword">let</span> vip =&#123;</span><br><span class="javascript">&gt;  id:<span class="hljs-number">3</span>,</span><br><span class="javascript">&gt;  name:<span class="hljs-string">&quot;vip&quot;</span>,</span><br><span class="javascript">&gt; &#125;</span><br><span class="javascript">&gt; <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);</span><br><span class="javascript">&gt; vip[id] = <span class="hljs-string">&quot;er&quot;</span>;</span><br><span class="javascript">&gt; </span><br><span class="javascript">&gt; <span class="hljs-built_in">console</span>.log(vip[id]) <span class="hljs-comment">//   er   用点符号进行调用显示3</span></span><br></code></pre></td></tr></table></figure>&gt;&gt; </code></pre></li></ul><ul><li><p>全局 symbol使用  : </p></li><li><blockquote><p>有时我们想要名字相同的 Symbol 具有相同的实体。</p><p>例如，应用程序的不同部分想要访问的 Symbol “id” 指的是完全相同的属性。 注册表内的 Symbol 被称为 全局 Symbol。</p><p>Symbol.for(key)。  key:描述   通过描述返回symbol  (在注册表中查找,不存在则创建) </p><p>Symbol.keyFor(sym) 通过全局 Symbol返回一个描述。 sym: 一个symbol</p></blockquote></li><li><blockquote><p>Symbol.keyFor 内部使用全局 Symbol 注册表来查找 Symbol 的键, 如果 Symbol 不是全局的，它将无法找到它并返回 undefined。</p></blockquote></li></ul><blockquote><p>symbol(“”)  和 Symbol.for(key)  使用相同的描述 创建的symbol 依然不相等</p><p>局部的Symbol  和全局的Symbol仍然不相等</p></blockquote><ul><li>JavaScript 使用了许多系统 Symbol. 可以用来改变一些内置行为</li></ul><blockquote><p>Symbol 主要运用 : </p><p>1.“隐藏” 对象属性 : 向对象添加 属性</p><p>2.系统Symbol :改变内置行为</p></blockquote><h4 id="对象-原始值转换"><a href="#对象-原始值转换" class="headerlink" title="对象 原始值转换"></a>对象 原始值转换</h4><ul><li><p>所有的对象在布尔上下文（context）中均为 true。所以对于对象，不存在 to-boolean 转换，只有字符串和数值转换。</p></li><li><p>数值转换发生在对象相减或应用数学函数时。至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。</p></li><li><blockquote><p>三个类型转换的变体，被称为 “hint” :  “String” “number” “default”</p><p>根据对象的使用情况向这三种类型转换</p></blockquote></li><li><p>对象 在上下文 需要转换时,会根据转换类型尝试调用内置函数进行转换</p></li><li><blockquote><ol><li><p>调用 <code>obj[Symbol.toPrimitive](hint)</code> 内置函数 (如果存在的话) ,我们可以进行自定义该属性</p><blockquote><p>[Symbol.toPrimitive] = function(hint){…..}</p></blockquote></li><li><p>根据 hint 类型 , 调用 tostring / valueOf() …</p></li></ol></blockquote></li></ul><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><ul><li><p>人们想操作原始数据类型 string number…,像操作方法一样,这时候需要对象支持,但是对象有需要额外的资源支持,因为需要原始数据尽量小,所以提出解决方法:</p></li><li><p>创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</p></li><li><blockquote><p>特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。</p></blockquote></li><li><p>“对象包装器”对于每种原始类型都是不同的，它们被称为 String、Number、Boolean 和 Symbol。因此，它们提供了不同的方法。</p></li><li><blockquote><pre><code class="javascript">let str = &quot;Hello&quot;;alert( str.toUpperCase() ); // HELLO<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>访问其属性时，会创建一个包含字符串字面值的特殊对象, 进行调用函数, 调用结束后销毁对象,留下字符串原始值<br><br><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Boolean(<span class="hljs-params">false</span>)</span> 等语法，明确地为原始类型创建“对象包装器”。但是极其不推荐,因为他返回一个对象,而不是返回转换过的值, 对象在判断语句中一直 <span class="hljs-literal">true</span><br>另一方面，调用不带 <span class="hljs-keyword">new</span>（关键字）的 String/Number/Boolean 函数是完全理智和有用的,这进行显式转换数据类型  <span class="hljs-keyword">let</span> num = <span class="hljs-constructor">Number(<span class="hljs-string">&quot;123&quot;</span>)</span>; <span class="hljs-comment">// 将字符串转成数字</span><br><br>#### 数字类型<br><br>- 在 JavaScript 中，我们通过在数字后附加字母 “e”，并指定零的数量来缩短数字：<br><br>- &gt; <span class="hljs-keyword">let</span> billion = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">//数字 1后面9个0  (相当于1乘10的9次方)  1e-6; // 1 的左边有 6个0</span><br><br>- <span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">base</span>)</span> 方法  base: 给定base 进制 返回一个字符串形式的base进制数,默认值为<span class="hljs-number">10</span><br><br>- &gt;数字也可以直接调用该方法 ,使用两个点   <span class="hljs-number">1234.</span>.tostring(base)<br><br>- Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。<br><br>- &gt; 值 “NaN” 是独一无二的，它不等于任何东西，包括它自身：不能使用===<br><br>- 它们属于 number 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数：<br><br>- is<span class="hljs-constructor">NaN(<span class="hljs-params">value</span>)</span> 将其参数转换为数字，然后测试它是否为 NaN：<br><br>- is<span class="hljs-constructor">Finite(<span class="hljs-params">value</span>)</span> 将其参数转换为数字，如果是常规数字，则返回 <span class="hljs-literal">true</span><br><br> ##### 舍入（rounding）   计算精度缺失: <br><br>- <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor  向下(小)舍入  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil 向上(大)舍入 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round 向最近的整数舍入  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入  都是向整数舍入<br><br>- <span class="hljs-keyword">to</span><span class="hljs-constructor">Fixed(<span class="hljs-params">n</span>)</span> 将数字舍入到小数点后 n 位，**返回字符串**。如果小数部分比所需要的短，则在结尾添加零：舍入时根据数字判断向上 向下进行舍入<br><br>``` <br><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.34</span>;<br>alert( num.<span class="hljs-keyword">to</span><span class="hljs-constructor">Fixed(5)</span> ); <span class="hljs-comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后5位</span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><blockquote><p>alert( 0.1 + 0.2 == 0.3 ); // false</p></blockquote></li><li><p>原因 : 一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。</p></li><li><blockquote><p>最可靠的方法是借助方法 toFixed(n) 对结果进行舍入：使用一元加号将其强制转换为一个数字 </p><p>let sum = 0.1 + 0.2; alert( +sum.toFixed(2) ); // 0.30</p></blockquote></li><li><p>alert( 6.35.toFixed(1) ); // 6.3 而不是6.4 </p></li><li><blockquote><p>原因: 在内部，6.35 的小数部分是一个无限的二进制</p><p>如果我们希望以正确的方式进行舍入，在进行舍入前，我们应该使其更接近整数</p></blockquote></li><li><blockquote><p>alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000  63.5 完全没有精度损失。这是因为小数部分 0.5 实际上是 1/2。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，</p></blockquote></li><li><p>在处理小数时避免相等性检查 精度缺失导致小数计算时发生意外</p><h6 id="praseInt-praseFloat"><a href="#praseInt-praseFloat" class="headerlink" title="praseInt/praseFloat"></a>praseInt/praseFloat</h6></li><li><p>使用加号 + 或 Number() 的数字转换是严格的。如果一个值不完全是一个数字，就会失败</p></li><li><blockquote><p>alert( +”100px” ); // NaN</p></blockquote></li><li><p>这就是 parseInt 和 parseFloat 的作用 :<br>它们可以<strong>从字符串中“读取”数字</strong>，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数：</p></li><li><blockquote><p>parseInt/parseFloat 当没有数字可读时会返回  NaN。</p><p>例如 :  alert( parseInt(‘a123’) ); // NaN，第一个符号停止了读取</p></blockquote></li></ul><blockquote><p>parseInt(str, radix) 的第二个参数 它指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串</p><p>如果 parseInt() 的参数是数字的话,它的效果类似Math.trunc() ,移除小数点之后的数只取整数 </p></blockquote><ul><li>其他数学函数 —-参考Math对象</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>反引号它们允许字符串跨行(单/双引号不行),在输入时也会是换行效果,反引号允许我们通过 <code>$&#123;…&#125;</code> 将任何表达式嵌入</p><blockquote><p> 反引号可以用来指定一个模板函数 </p></blockquote></li></ul><ul><li><p><strong>字符串基本操作</strong>:</p></li><li><p>访问字符 :使用方括号[ pos] 或者调用 <code>str.charAt(pos)</code> 方法。pos从零开始 </p></li><li><blockquote><p>它们之间的唯一区别是，如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</p></blockquote></li></ul><ul><li><p>length 属性表示字符串长度, 特殊字符,如\n 则算一个单独的字符</p></li><li><p>使用<code>for..of</code>遍历字符串和<code>for..in</code>区别在于,for in得到的是索引,根据索引得到内容, for of 直接得到内容</p></li><li><p>在 JavaScript中，<strong>字符串不可更改</strong>,通常解决创建一个新字符串.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=<span class="hljs-string">&quot;jsonp&quot;</span>;<br>a[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;h&quot;</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// jsonp</span><br><br><span class="hljs-comment">// 就算改变字符, 也不会有什么影响</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>字符串方法:</strong></p><pre><code>toLowerCase() 和 toUpperCase() 方法可以改变大小写：查找子字符串 :  substr =&gt; 字符串str.indexOf(substr, [pos])。没有找到返回 -1，否则返回匹配成功的位置。str.lastIndexOf(substr, [position])，默认它从字符串的末尾开始搜索到开头。或者从postition往前str.includes(substr, [pos]) 返回 true/false。如果我们只需要检测匹配时使用获取子字符串 : str.slice(start [, end] 返回字符串从 start（但不包括）end 的部分。如果没有第二个参数，slice 会一直运行到字符串末尾, start/end 是负值。起始位置从字符串结尾计算str.substring(start [, end])返回字符串在 start 和 end 之间 的部分。它允许start大于end。str.substr(start [, length])返回字符串从 start 开始的给定 length 的部分.匹配字符串 :  startsWith() endsWith() </code></pre></li><li><p>所有常用的字符都是一个 2 字节(16byte)的代码,所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。</p></li><li><blockquote><p><code>String.fromCodePoint</code> 和 <code>str.codePointAt</code> 是几种处理代理对的少数方法, 处理特殊符号</p></blockquote></li></ul><h4 id="数组-数组方法"><a href="#数组-数组方法" class="headerlink" title="数组 数组方法"></a>数组 数组方法</h4><ul><li><h5 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明 :"></a>数组声明 :</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [ ]<br><span class="hljs-keyword">let</span> arr =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() 用单个参数可以指定一个长度固定,没有任何项的数组<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>数组可以存储任何类型的元素,以逗号结尾.</p><p>length属性的值是数组中元素的总个数, </p><p>可以用 alert 来显示整个数组</p></blockquote><ul><li><h5 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用 :"></a>数组使用 :</h5></li><li><p>队列(queue)是最常见的使用数组的方法之一。</p><blockquote><p>push  :末端添加</p><p> shift : 取出首端  </p></blockquote></li><li><p>数组作为栈使用:</p><blockquote><p>push 末端添加</p><p>pop 末端取出</p></blockquote></li><li><p>数组可以同时当做队列 栈使用, 允许在首段末段/添加删除元素, 我们叫这样的数据结构成为双端队列</p></li><li><blockquote><p>unshift : 首端添加元素</p><p><code>push</code> 和 <code>unshift</code> 方法都可以一次添加多个元素：</p><p><code>shift</code> 和<code>pop</code>方法,都没有参数</p></blockquote></li><li><h5 id="数组内部"><a href="#数组内部" class="headerlink" title="数组内部:"></a>数组内部:</h5></li><li><p><strong>数组是一种特殊的对象</strong>。使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法. 它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象.</p></li><li><blockquote><p>数组的行为很像一个对象,  比如可以直接使用  “=” , 进行引用复制,两个变量引用一个数组</p></blockquote><blockquote><p>我们可以像常规对象一样使用数组, 添加属性等等, 但是js针对数组有优化,如果像常规对象使用, 这种优化就不再使用</p></blockquote></li><li><h5 id="数组-length-toString"><a href="#数组-length-toString" class="headerlink" title="数组 length   toString"></a>数组 length   toString</h5></li><li><blockquote><p>当我们修改数组的时候，length属性会自动更新.</p><p>length可写,如果我们减少它，数组就会被截断.清空数组 :  arr.length = 0;</p><p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p></blockquote></li></ul><ul><li><h5 id="数组循环-for-in-for-of-for"><a href="#数组循环-for-in-for-of-for" class="headerlink" title="数组循环 : for..in  for..of  for()"></a>数组循环 : for..in  for..of  for()</h5></li><li><blockquote><p>建议使用for ..of  ,   for()</p><p> for..in 有很多潜在问题 : 会遍历所有属性(对于类数组不好) ,遍历数组比遍历普通对象要慢</p></blockquote></li><li><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5></li><li><blockquote><pre><code class="javascript">let matrix = [[1, 2, 3],[4, 5, 6],[7, 8, 9]];<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs clean">- ##### 数组方法<br><br>- ##### 从数组中添加,删除,插入元素:<br><br>- &gt;  arr.splice(index[, deleteCount, elem1, ..., elemN])   <span class="hljs-comment">//既可以单独删除 也可以删除插入</span><br><br>返回已删除的元素数组, 插入是插入到索引之前<br><br>使用delete 可以删除数组中的值,但不会自动释放占据的空间 <br><br>- ##### 数组部分拷贝: <br><br>- arr.slice([ start], [ end]) 返回一个新数组，新数组的索引是 start 到 end（不包括 end）   <br><br>- &gt; arr.slice()  不带参数,会创建一个arr数组副本<br><br>- arr.concat(arg1, arg2...) 创建一个新数组，其中包含来自于其他数组和其他项的值。arg 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身, <br><br>- &gt;concat() 方法返回的数组结果, 不会进行排序<br><br> &gt;如果类似数组的对象具有 `Symbol.isConcatSpreadable` =true 属性，那么它就会被 `concat` 当作一个数组来处理<br><br><br>slice  concat 方法的拷贝注意事项: <br><br>数组里是 对象引用 , `concat`将对象引用复制到新数组中, 原始数组和新数组都引用相同的对象<br><br>数组里是 数据类型如字符串，数字和布尔（不是String，Number 和 Boolean 对象）,会复制一份给新数组<br><br>&gt; 当用来拷贝二维数组时注意,不要直接进行拷贝,因为多维数组里的数组,被当成了对象引用<br><br>- ##### 数组遍历<br><br>- arr.forEach 方法允许为数组的每个元素都运行一个函数。不会改变数组的值,也没有返回值<br><br>```javascript<br>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])<br>&#123;<br><span class="hljs-comment">//  index : 正在处理元素的索引, array 正在处理的数组</span><br>&#125;<br><span class="hljs-comment">//该函数的结果（如果它有返回）会被抛弃和忽略。</span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><ul><li><h5 id="数组搜索"><a href="#数组搜索" class="headerlink" title="数组搜索"></a>数组搜索</h5><blockquote><p>arr.indexOf、arr.lastIndexOf 和 arr.includes 方法 检查内容返回索引 ,没有返回-1</p><p>与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同</p></blockquote></li><li><p>arr.find 方法, 找到特定条件的对象: find 方法搜索的是使函数返回 true 的第一个（单个）元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br><br>item 是元素。index 是它的索引。 array 是数组本身。<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>arr.findIndex 方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。</p></li><li><p>arr.filter(fn) 方法   : 返回匹配元素组成的数组</p></li><li><pre><code class="javascript"> arr.filter(function(item, index, array)&#123;&#125; <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br>- ##### 数组转换(分割 联结 倒置) 排序<br><br>&gt;  `arr.map` 方法,它对数组的每个元素都调用函数，callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组, 并返回这个新数组。<br>&gt;<br>&gt;  ```javascript<br>&gt;  let result = arr.map(function(item, index, array)<br>&gt;   &#123;<br>&gt;      // 返回新值而不是当前元素, arr也不会被改变<br>&gt;  &#125;<br>&gt;    //如果函数没有返回值,则新数组默认都是undefined<br></code></pre></td></tr></table></figure>&gt;&gt;  `arr.sort(fn)` 方法对数组进行排序，更改元素的顺序,不会生成一个新数组.它还返回排序后的数组&gt;  排序方法默认按照**字符串**进行排序。需要使用自定义排序顺序,提供一个fn函数作为参数&gt;&gt;  `arr.reverse( )`方法  返回arr颠倒过的数组</code></pre></li><li><p>字符串转换为数组: </p></li></ul><blockquote><p> str.split(delim) 方法。它通过给定的分隔符 delim 将<strong>字符串</strong>分割成一个数组。</p><p> 有一个可选的第二个数字参数 —— 对数组长度的限制</p></blockquote><blockquote><p>调用带有空格的 <code>split(&#39; &#39;)</code>，方法, 会将字符串拆分为字母数组</p></blockquote><ul><li><p>数组转化为字符串:</p><blockquote><p>arr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。</p></blockquote></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 方法</p></li><li><blockquote><p>遍历数组, 然后计算单个值,并把结果传递给下一次计算</p><p>arr.reduce(function(accumulator, item, index, array) {  // … }, [initial]);</p><p><code>accumulator</code> —— 是上一个函数调用的结果, 本质上是一个累加器</p></blockquote></li></ul><ul><li><p><strong>判断是否为数组</strong> : 数组是基于对象的，不构成单独的语言类型。所以 typeof 不能帮助从数组中区分出普通对象：</p></li><li><blockquote><p>Array.isArray(value)。如果 value 是一个数组，则返回 true；否则返回 false。</p></blockquote></li></ul><blockquote><p>几乎所有调用函数的数组方法(需要函数作为参数) ,都接受一个可选的附加参数 thisArg, </p><p>传递对象方法,往往会丢失this,  这个参数在func 中时对象名, 绑定了this指针</p><p>往往这个附加参数,可以被箭头函数/ 匿名函数替代</p></blockquote><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><ul><li><p>任何对象都可以被定制为可迭代的,换句话说,都可以被定制为在for..of循环中使用</p><blockquote><p>内置的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。</p></blockquote></li><li><p>通过设置<strong>obj[ Symbol.iterator]</strong> 属性, 来进行定制对象可迭代的迭代过程</p></li><li><blockquote><p>obj[Symbol.iterator] =func方法 , 会被 for..of 自动调用, 它必须返回一个 <strong>迭代器（iterator）</strong> —— 一个有 <code>next</code> 方法的对象。</p><p>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。</p><p>next()<code>方法返回的结果的格式必须是</code>{done: Boolean, value: any}<code>，当 </code>done=true<code>时，表示迭代结束，否则</code>value` 是下一个值。</p></blockquote></li></ul><blockquote><p>在对象内部写 <a href="">Symbol.iterator</a>, next() 函数时, 当同一个对象运行两个for..of 会共享迭代状态</p><p>我们还可以显式调用迭代器, 对象名[Symbol.iterator] ()会返回一个迭代器对象</p></blockquote><ul><li><h5 id="可迭代（iterable）和类数组（array-like）"><a href="#可迭代（iterable）和类数组（array-like）" class="headerlink" title="可迭代（iterable）和类数组（array-like）"></a>可迭代（iterable）和类数组（array-like）</h5></li><li><blockquote><ul><li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li><li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组</li></ul><blockquote><p>一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代</p></blockquote></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">类数组 : 有索引和 length 属性<br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;World&quot;</span>,<br>  length: <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>转化可迭代对象, 类数组 为数组:</strong></p></li><li><blockquote><p>全局方法 Array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组</p><p>**Array.from(obj[, mapFn, thisArg])**可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素</p></blockquote></li></ul><h4 id="Map-Set-映射和集合"><a href="#Map-Set-映射和集合" class="headerlink" title="Map Set (映射和集合)"></a>Map Set (映射和集合)</h4><ul><li><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map <strong>允许任何类型</strong>的键（key）</p></li><li><blockquote><p>Objct 的键只允许 是字符串 或者 Symbol 类型, 如果是其他的也会转化为字符串类型</p></blockquote></li><li><p><strong>定义 使用map</strong> : </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(key, value);  —— 根据键存储值<br>map.get(key) ;       —— 根据键来返回值如果 map 中不存在对应的 key，则返回 <span class="hljs-literal">undefined</span>。<br>map.has(key) —— 如果 key 存在则返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。<br>map.delete(key) —— 删除指定键的值。<br>map.clear() —— 清空 map。<br>map.size —— 返回当前元素个数。<br></code></pre></td></tr></table></figure></li><li><blockquote><p>map[ key] 不是使用 Map 的正确方式 , 因为map的键值可以存储任何类型,包括对象, </p><p>所以当用[ object] 调用时会发生错误, 不存在对象键.</p><p>每一次 map.set 调用都会返回 map 本身，所以我们可以进行<strong>“链式”调用</strong></p></blockquote></li></ul><ul><li><p><strong>Map 迭代</strong> :(使用for..of 结合以下函数进行遍历)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.keys() —— 返回含有所有的键 的 map iterable  <br>map.values() —— 返回含有所有的值 的 map iterable  <br>map.entries() —— 遍历并返回所有的实体 [key, value], <span class="hljs-keyword">for</span>..of 在默认情况下使用的就是这个。<br><br>map.forEach( (value, key, map)&#123;&#125;  <span class="hljs-comment">//与 Array 类似</span><br></code></pre></td></tr></table></figure></li><li><blockquote><p>迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。</p></blockquote></li></ul><ul><li><p><strong>通过可迭代对象 数组创建map</strong></p></li><li><pre><code class="javascript">传入一个带有键值对的数组初始化let map = new Map([ [&#39;1&#39;,  &#39;str1&#39;], [1,    &#39;num1&#39;], [true, &#39;bool1&#39;] ]); <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>- &gt; 使用内建方法 <span class="hljs-built_in">Object</span>.entries(obj)，将对象转换为键/值对数组，该数组格式完全按照 <span class="hljs-built_in">Map</span> 所需的格式。<br>  &gt;<br>  &gt; *let map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));*<br><br>- **从<span class="hljs-built_in">Map</span> 创建对象**:<br><br>- `<span class="hljs-built_in">Object</span>.fromEntries()` ：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象<br><br>- &gt; 从 <span class="hljs-built_in">Map</span> 创建对象 : let obj = <span class="hljs-built_in">Object</span>.fromEntries(map.entries()); <span class="hljs-comment">// 创建一个普通对象;</span><br>  &gt;<br>  &gt; 简化为:  let obj = <span class="hljs-built_in">Object</span>.fromEntries(map);   <br>  &gt;<br>  &gt; 原因 :  <span class="hljs-built_in">Object</span>.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组<br><br>  ##### <span class="hljs-keyword">set</span><br><br><br>- <span class="hljs-keyword">set</span> : <span class="hljs-built_in">Set</span> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。<br><br>- **<span class="hljs-keyword">set</span>方法** : <br><br>  - `<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(iterable)` —— 创建一个 `<span class="hljs-keyword">set</span>`，如果提供了一个 `iterable` 对象（通常是数组），将会从数组里面复制值到 `<span class="hljs-keyword">set</span>` 中。<br>  - `<span class="hljs-keyword">set</span>.add(value)` —— 添加一个值，返回 <span class="hljs-keyword">set</span> 本身<br>  - `<span class="hljs-keyword">set</span>.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `<span class="hljs-keyword">true</span>` ，否则返回 `<span class="hljs-keyword">false</span>`。<br>  - `<span class="hljs-keyword">set</span>.has(value)` —— 如果 `value` 在 <span class="hljs-keyword">set</span> 中，返回 `<span class="hljs-keyword">true</span>`，否则返回 `<span class="hljs-keyword">false</span>`。<br>  - `<span class="hljs-keyword">set</span>.clear()` —— 清空 <span class="hljs-keyword">set</span>。<br>  - `<span class="hljs-keyword">set</span>.size` —— 返回元素个数。<br>  <br>  <br><br><br>- &gt; 重复使用同一个值调用 <span class="hljs-keyword">set</span>.add(value) 并不会发生什么改变,<span class="hljs-keyword">set</span>中每个值还是一个<br><br><br>```javascript<br>我们可以使用 <span class="hljs-keyword">for</span>..of 或 forEach 来遍历 <span class="hljs-built_in">Set</span>：<br><span class="hljs-keyword">set</span>.forEach((value, valueAgain, <span class="hljs-keyword">set</span>) =&gt; &#123;<br>  alert(value);<br>&#125;);<br><br><span class="hljs-keyword">set</span>.keys(); 遍历并返回所有的值<br><span class="hljs-keyword">set</span>.values(); 与 <span class="hljs-keyword">set</span>.keys() 作用相同，这是为了兼容 <span class="hljs-built_in">Map</span><br><span class="hljs-keyword">set</span>.entries();  遍历并返回所有的实体[value, value]，它的存在也是为了兼容 <span class="hljs-built_in">Map</span>。<br></code></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p>forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。  是为了与 Map 兼容。</p></blockquote><h4 id="WeakMap-and-WeakSet"><a href="#WeakMap-and-WeakSet" class="headerlink" title="WeakMap and WeakSet"></a>WeakMap and WeakSet</h4><ul><li><p>如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。类似的，如果我们使用对象作为常规 Map 的键，那么当 Map 存在时，该对象也将存在.</p></li><li><p>WeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。</p></li><li><p>WeakMap 和 Map 的第一个不同点就是<strong>，WeakMap 的键必须是对象</strong>，不能是原始值</p></li><li><p>WeakMap <strong>不支持迭代</strong> 以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。</p></li><li><blockquote><ul><li><code>weakMap.get(key)</code></li><li><code>weakMap.set(key, value)</code></li><li><code>weakMap.delete(key)</code></li><li><code>weakMap.has(key)</code></li></ul><p><code>WeakMap</code> 只有以上的方法  支持size() ???</p></blockquote></li><li><blockquote><p>当需要对象 和它附加的数据共存亡时,可以用到weakmap</p></blockquote></li><li><p>WeakSet <strong>只能存储对象</strong>,<strong>不支持迭代</strong> 无法使用size 和迭代用函数 keys()</p></li><li><blockquote><p><code>WeakSet</code> 支持 <code>add</code>，<code>has</code> 和 <code>delete</code> 方法</p></blockquote></li></ul><ul><li><blockquote><p>WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。</p><p><code>WeakMap</code> 和 <code>WeakSet</code> 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 <code>WeakMap</code> 或 <code>WeakSet</code> 的键，那么它将被自动清除。</p></blockquote></li></ul><h4 id="Object-keys，values，entries"><a href="#Object-keys，values，entries" class="headerlink" title="Object.keys，values，entries"></a>Object.keys，values，entries</h4><ul><li> 这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。</li></ul><blockquote><p> 它们支持： Map  Set Array  </p><p> 普通对象也支持类似的方法，但是语法上有一些不同  :map.keys()    ==&gt;    Object.keys(obj)， </p><p> 为了自己创建的对象方法不会被覆盖,使用Object.keys(obj)更灵活</p></blockquote><ul><li><p>对于普通对象，下列这些方法是可用的 :</p></li><li><blockquote><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> —— 返回一个包含该对象所有的键的数组。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> —— 返回一个包含该对象所有的值的数组。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> —— 返回一个包含该对象所有 [key, value] 键值对的数组。</li></ul><p><strong>Object.keys/values/entries 会忽略 symbol 属性</strong>, 如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>，它会返回一个只包含 Symbol 类型的键的数组</p></blockquote></li><li><p>转换对象,调用数组方法 :</p></li><li><blockquote><p>对象缺少数组存在的许多方法,我们可以转换对象来调用</p><p>1.使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。<br>2.对该数组使用数组方法</p><p>3.对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。</p></blockquote></li></ul><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><blockquote><p>基本语法 : </p><ol><li>let {prop : varName = default, …rest} = object</li><li>let [item1 = default, item2, …rest] = array</li></ol></blockquote><ul><li><p>对象让我们能够创建通过键来存储数据项的单个实体，数组则让我们能够将数据收集到一个有序的集合中。<br>但是，当我们把它们传递给函数时，它可能不需要一个整体的对象/数组，而是需要单个块。</p></li><li><p>解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便</p></li><li><p>“解构”并不意味着“破坏” 因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 数组解构<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Ilya&quot;</span>, <span class="hljs-string">&quot;Kantor&quot;</span>]<br><span class="hljs-keyword">let</span> [firstName, surname] = arr;   =&gt; 相当于 <span class="hljs-keyword">let</span> firstName = arr[<span class="hljs-number">0</span>]; <span class="hljs-keyword">let</span> surname = arr[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">let</span> [firstName, , title] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>];<span class="hljs-comment">///数组中不想要的元素也可以通过添加额外的逗号来把它丢弃</span><br>alert( title ); <span class="hljs-comment">// Consul</span><br><br><span class="hljs-number">2.</span> 可迭代对象解构      <span class="hljs-comment">//等号右侧可以是任何可迭代对象,而不仅限于数组,  等号左侧使用任何“可以被赋值的”东西</span><br><br><span class="hljs-keyword">let</span> [one, two, three] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">let</span> user = &#123;&#125;;<br>[user.name, user.surname] = <span class="hljs-string">&quot;Ilya Kantor&quot;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>);<br><br></code></pre></td></tr></table></figure><ul><li><blockquote><p>使用 .entries() 转换对象为键值对数组,可以进行遍历操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (let [key, value] of Object.entries(user)) &#123;<br><br> alert(`$&#123;key&#125;:$&#123;value&#125;`); <span class="hljs-comment">// name:John, then age:30</span><br><br> &#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>交换变量</p></li><li><blockquote><pre><code class="javascript">let guest = &quot;Jane&quot;; let admin = &quot;Pete&quot;;   // 交换值：让 guest=Pete, admin=Jane [guest, admin] = [admin, guest];<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><br>- 把后面的元素收集成数组,通过 <span class="hljs-string">&#x27;...&#x27;</span><br><br>- &gt; ```javascript<br>let [<span class="hljs-symbol">name1</span>, <span class="hljs-symbol">name2</span>, ...rest] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>]; <br>alert<span class="hljs-comment">(rest[0])</span>; <span class="hljs-comment">// Consul   rest 的值会被组成一个数组</span><br><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p>如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供,如果赋值语句中，变量的数量多于数组中实际元素的数量，赋值不会报错。未赋值的变量被认为是 undefined</p></li><li><blockquote><p>let [name = “Guest”, surname = “Anonymous”] = [ “Julius”];</p></blockquote></li></ul><ul><li><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5></li><li><pre><code class="javascript">let &#123;var1, var2&#125; = &#123;var1:&quot;er&quot;, var2: &quot;fef&quot;&#125;;let &#123;title, width, height&#125; = options; // options 对象名<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><br>- 变量的顺序并不重要,会根据两侧相同的名称赋值, <br><br>- &gt; 如果我们想把一个属性赋值给不同名字的变量:<br>  &gt;<br>  &gt;  <span class="hljs-built_in">let</span> &#123;<span class="hljs-built_in">width</span>: w, <span class="hljs-built_in">height</span>: h, <span class="hljs-built_in">title</span>&#125; = options;   // 把 options.<span class="hljs-built_in">width</span> 属性赋值给变量 w<br><br>- 对象解构 也可以提供默认值 , 可以把剩余元素通过&#x27;...&#x27; 收集成一个对象<br><br>- 不使用<span class="hljs-built_in">let</span> 进行 对象解构时 会出现错误, 原因:  因为&#123;&#125;会被解释成普通代码块 而不是解析语法<br><br>```javascript<br>// 这一行发生了错误<br>&#123;<span class="hljs-built_in">title</span>, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>&#125; = &#123;<span class="hljs-built_in">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">200</span>, <span class="hljs-built_in">height</span>: <span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>解决方法 : 要把整行用括号括住</p></blockquote></li><li><h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5></li><li><blockquote><p>如果一个对象或数组嵌套了其他的对象和数组,我们可以在等号左侧来提取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;<br>  size: &#123; <span class="hljs-comment">// 把 size 赋值到这里</span><br>    width,<br>    height<br>  &#125;,<br>  items: [item1, item2], <span class="hljs-comment">// 把 items 赋值到这里</span><br>  title = <span class="hljs-string">&quot;Menu&quot;</span> <span class="hljs-comment">// 在对象中不存在（使用默认值）</span><br>&#125; = options;<br><br>alert(title);  <span class="hljs-comment">// Menu</span><br>alert(width);  <span class="hljs-comment">// 100</span><br>alert(height); <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>智能函数参数: </p></li><li><blockquote><p>对于拥有很多参数的函数,在调用时我们会传递一个对象,而不是所有参数,</p><p>对象会进行解构,赋值给函数中的参数,  调用函数时,参数直接传一个对象即可</p></blockquote></li></ul><h4 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期 时间"></a>日期 时间</h4><ul><li>创建Date对象:</li></ul><blockquote><p>new Date() </p><p>new Date(datestring)   </p><p>new Date(year, month, date, hours, minutes, seconds, ms) </p></blockquote><ul><li>Date常用方法:</li></ul><blockquote><p>getFullYear()  获取年份（4 位数）</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth">getMonth()</a> 获取月份，<strong>从 0 到 11</strong>。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate">getDate() </a>获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours">getHours()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes">getMinutes()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds">getSeconds()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds">getMilliseconds()</a>获取相应的时间组件。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay">getDay()</a>获取一周中的第几天，从 <code>0</code>（星期日）到 <code>6</code>（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变</p></blockquote><ul><li><p><strong>以上的所有方法返回的组件都是基于当地时区的。</strong> 得到与当地时区的 UTC 对应项只需要在 <code>&quot;get&quot;</code> 之后插入 <code>&quot;UTC&quot;</code> 即可。</p></li><li><p>set..方法和get基本一致,不在赘述</p></li><li><p>自动校准 ,是 Date 对象的一个非常方便的特性,在设置超过范围的值,他会自动调整,比如闰年</p></li><li><p>日期转换为数字 ,当 Date 对象被转化为数字时，得到的是对应的时间戳(从1970到现在的毫秒数), 日期对象前面有+号完成转换</p></li><li><blockquote><p>日期可以相减，相减的结果是以毫秒为单位时间差。</p></blockquote></li><li><p>只想要得到时间间隔使用,  Date.now() 会返回当前的时间戳。两个相减得到时间间隔</p></li><li><p>Date.parse(str) 方法可以从一个字符串中读取日期。返回时间戳(毫秒数);</p></li><li><blockquote><p>let date = new Date( Date.parse(‘2012-01-26T13:51:50.417-07:00’) );</p></blockquote></li></ul><h4 id="JSON-之后在研究"><a href="#JSON-之后在研究" class="headerlink" title="JSON(之后在研究)"></a>JSON(之后在研究)</h4><ul><li><blockquote><p>JSON.stringify(obj) 将对象转换为 JSON。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify(value[, replacer, space])<br><br><span class="hljs-comment">/*replacer :如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化</span><br><span class="hljs-comment">space :指定缩进用的空白字符串，用于美化输出（pretty-print）*/</span><br></code></pre></td></tr></table></figure><p>JSON.parse 将 JSON 转换回对象。 返回一个js对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">JSON</span>.parse(str, [reviver]);<br><span class="hljs-comment">//reviver : 转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过,例如:</p><p>函数属性（方法）。 Symbol 类型的属性。存储 undefined 的属性。</p></li><li><p>JSON 支持嵌套对象转换, 但是不能有循环引用</p></li><li><p>像 <code>toString</code> 进行字符串转换，对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它。</p></li><li><blockquote><p>JSON 支持以下数据类型：</p><ul><li>Objects <code>&#123; ... &#125;</code></li><li>Arrays <code>[ ... ]</code></li><li>Primitives：<ul><li>strings，</li><li>numbers，</li><li>boolean values <code>true/false</code>，</li><li><code>null</code>。</li></ul></li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/DOM%20%E5%86%8D%E5%BC%80/"/>
    <url>/2020/12/14/Js-dom/DOM%20%E5%86%8D%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><ul><li><p>JavaScript 语言已经发展成为一种具有多种用途和平台的语言。平台可以是一个浏览器，一个 Web 服务器，或其他主机（host）, 如果它能运行 JavaScript 的话。它们每个都提供了特定于平台的功能。JavaScript 规范将其称为 <strong>主机环境</strong>。</p></li><li><blockquote><p>主机环境提供了自己的对象和语言核心以外的函数。Web 浏览器提供了一种控制网页的方法。Node.JS 提供了服务器端功能 等</p></blockquote></li><li><p>window 代表一个”根”对象,是 JavaScript 代码的全局对象,又代表“浏览器窗口”，并提供了控制它的方法。(查看窗口高度等)</p></li></ul><h4 id="DOM-BOM"><a href="#DOM-BOM" class="headerlink" title="DOM  BOM"></a>DOM  BOM</h4><ul><li><p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。</p></li><li><blockquote><p>document 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</p></blockquote></li><li><p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。</p></li><li><blockquote><p>location 对象允许我们读取当前 URL , navigator 对象提供了有关浏览器和操作系统的背景信息。</p></blockquote></li><li><blockquote><p>函数 alert/confirm/prompt 也是 BOM 的一部分,它代表了与用户通信的纯浏览器方法。</p></blockquote></li></ul><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><ul><li><p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象(元素节点)</p></li><li><p>文本节点中,空格和换行符都是完全有效的字符，就像字母和数字</p></li><li><blockquote><p>所以在标签之间的空格 换行符可能会被解析成文本节点 </p></blockquote></li><li><blockquote><p>例外 : &lt; head&gt; 之前的空格和换行符均被忽略 , </p></blockquote></li><li><blockquote><p>HTML规范要求所有内容必须位于 &lt; body&gt; 内. 所以 &lt;/ body&gt;之后不能有空格, body之后的内容会被自动移动到body中,并处在最下面</p></blockquote></li><li><p>与 DOM 一起使用的浏览器工具,通常不会在文本的开始/结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。</p></li></ul><ul><li><p>自动修正 : 如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p></li><li><blockquote><p>表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 &lt; tbody&gt;,在形成DOM时,如果没有会给加上</p></blockquote></li><li><p>常用的节点 :  </p><pre><code>  document — DOM 的“入口点”。  元素节点 — HTML 标签，树构建块。  文本节点 — 包含文本。  注释 </code></pre></li></ul><h4 id="遍历DOM"><a href="#遍历DOM" class="headerlink" title="遍历DOM"></a>遍历DOM</h4><ul><li><p>对 DOM 的所有操作都是以 document 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p><pre><code>  &lt;html&gt; = document.documentElement  &lt;body&gt; = document.body  &lt;head&gt; = document.head</code></pre></li><li><blockquote><p>document.body有可能为空,脚本无法访问在运行时不存在的元素。尤其是，如果一个脚本是在 &lt; head&gt; 中，那么脚本是访问不到 document.body 元素的(其他元素也访问不到。获得null值)<br>在 DOM 中，null 值就意味着“不存在”或者“没有这个节点”</p></blockquote></li><li><p>节点之间的关系</p><pre><code>  parentNode  childNodes : childNodes 集合(可迭代对象)列出了所有子节点，包括文本节点。  返回的DOM集合是实时更新的  firstChild   lastChild  nextSibling    previouSibling</code></pre></li></ul><ul><li><blockquote><p>DOM 集合是只读的 ，只能通过函数对节点进行操作，不能直接通过 “=” 赋值进行更改节点</p></blockquote></li><li><blockquote><p>elem.hasChildNodes() 用于检查节点是否有子节点。</p></blockquote></li><li><p>只获取元素节点 ：</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx">     <span class="hljs-attribute">children</span> — 仅那些作为元素节点的子代的节点。 返回实时更新的DOM集合<br>firstElementChild，<span class="hljs-literal">last</span>ElementChild — 第一个和最后一个子元素。<br>     previousElementSibling，nextElementSibling — 兄弟元素。<br>parentElement — 父元素。<br></code></pre></td></tr></table></figure><p>·</p></li><li><blockquote><p>parentElement 属性返回的是“元素类型”的父节点，而 parentNode 返回的是“任何类型”的父节点,这些属性通常来说是一样的 </p><p>唯一的例外就是 document.documentElement  因为document.documentElement.parentNode       //document      parentElement 属性则返回null  因为document不是一个元素节点</p></blockquote></li><li><p>某些类型的 DOM 元素还可能会提供特定于其类型的其他属性。表格（Table）是一个很好的例子  。</p><pre><code>  table.rows — &lt;tr&gt; 元素的集合。  table.caption/tHead/tFoot — 引用元素 &lt;caption&gt;，&lt;thead&gt;，&lt;tfoot&gt;。  table.tBodies — &lt;tbody&gt; 元素的集合  &lt;thead&gt;，&lt;tfoot&gt;，&lt;tbody&gt; 元素提供了 rows 属性  tr.cells — 在给定 &lt;tr&gt; 中的 &lt;td&gt; 和 &lt;th&gt; 单元格的集合。  tr.sectionRowIndex — 给定的 &lt;tr&gt; 在封闭的 &lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt; 中的位置（索引）。  tr.rowIndex — 在整个表格中 &lt;tr&gt; 的编号（包括表格的所有行）。  td.cellIndex — 在封闭的 &lt;tr&gt; 中单元格的编号。</code></pre><blockquote><p>HTML 表单（form）还有其它导航（navigation）属性</p></blockquote></li></ul><h4 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h4><ul><li>节点查找方法</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getElementById</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">getElementsByTagname</span><span class="hljs-params">()</span></span> 返回一个类数组,类数组只能使用下标 和length不具备其他功能<br><span class="hljs-function"><span class="hljs-title">getElementsByClassName</span><span class="hljs-params">()</span></span> 返回一个类数组<br><span class="hljs-function"><span class="hljs-title">getElementsByName</span><span class="hljs-params">()</span></span> 返回在文档范围内具有给定 name 特性的元素,返回类数组<br><span class="hljs-function"><span class="hljs-title">querySelector</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">querySelectorAll</span><span class="hljs-params">()</span></span> 采用了css选择器的格式, 当元素只有一个,使用两个方法效果一样<br></code></pre></td></tr></table></figure><ul><li><p>可以直接使用和元素id相同名字的全局变量 来访问元素</p><blockquote><p>这种容易和相同命名的全局变量冲突,不建议使用</p></blockquote></li><li><p>所有的 “getElementsBy*” 方法都会返回一个 实时的（live）** 集合**。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。  相反，querySelectorAll 返回的是一个 静态的 集合。就像元素的固定数组</p></li><li><p>elem.matches(css) 不会查找任何内容，它只会检查 elem 是否与给定的 CSS 选择器匹配。它返回 true 或 false。</p></li><li><blockquote><p>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</p></blockquote></li><li><p>elem.closest(css) 方法会查找与 CSS 选择器匹配的最近的祖先。elem 自己也会被搜索。与选择器匹配，则停止搜索并返回该祖先。</p></li><li><p>用来检查子级与父级之间关系的方法 : 如果 <code>elemB</code> 在 <code>elemA</code> 内 : elemA.contains(elemB)返回true</p></li></ul><h4 id="节点属性：type，tag-和-content"><a href="#节点属性：type，tag-和-content" class="headerlink" title="节点属性：type，tag 和 content"></a>节点属性：type，tag 和 content</h4><ul><li><p>DOM 节点类 : 不同的 DOM 节点可能有不同的属性 例如文本节点与元素节点不同,但是所有这些标签对应的 DOM节点之间也存在共有的属性和方法，每个 DOM 节点都属于相应的内建类。</p></li><li><p>层次结构（hierarchy）的根节点是 EventTarget，Node 继承自它，其他 DOM 节点继承自 Node。</p><pre><code>  EventTarget-&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTMLBodyElement                  |  \          \               Text  Comment   SVGElement</code></pre></li></ul><ul><li><blockquote><p>EventTarget — 是根的“抽象（abstract）”类。该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”.  为事件（包括事件本身）提供支持，</p></blockquote></li><li><blockquote><p>Node — 也是一个“抽象”类，充当 DOM 节点的基础。它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）。 提供通用 DOM 节点属性，</p></blockquote></li><li><blockquote><p>Element — 是 DOM 元素的基本类。它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法,Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement。   提供通用（generic）元素方法</p></blockquote></li><li><blockquote><p>HTMLElement — 最终是所有 HTML 元素的基本类。各种 HTML 元素均继承自它 ,它提供了通用（common）的 HTML 元素方法（以及 getter 和 setter）</p></blockquote></li><li><p>给定节点的全部属性和方法都是继承的结果。  </p></li><li><p>正如我们所看到的，DOM 节点是常规的 JavaScript 对象。它们使用基于原型的类进行继承</p><h5 id="查看DOM节点"><a href="#查看DOM节点" class="headerlink" title="查看DOM节点"></a>查看DOM节点</h5></li><li><p>我们可以通过回调来查看 DOM 节点类名，因为对象通常都具有 constructor 属性。</p></li><li><blockquote><p>alert( document.body.constructor.name ); // HTMLBodyElement</p></blockquote></li><li><p>或者我们可以对其使用 toString 方法：  我们还可以使用 instanceof 来检查继承</p></li></ul><ul><li><p>console.log(elem) 显示元素的 DOM 树。  </p></li><li><p>console.dir(elem) 将元素显示为 DOM 对象适合探索其属性。</p></li></ul><h5 id="nodetype-nodeName-和-tagName属性-标签操作"><a href="#nodetype-nodeName-和-tagName属性-标签操作" class="headerlink" title="nodetype nodeName 和 tagName属性:标签操作"></a>nodetype nodeName 和 tagName属性:标签操作</h5><ul><li><p>nodeType 属性提供了数值类型, 我们只能读取 nodeType 而不能修改它。</p></li><li><p>给定一个 DOM 节点，我们可以从 nodeName 或者 tagName 属性中读取它的标签名：</p><blockquote><p>tagName 属性仅适用于 Element 节点。nodeName 是为任意 Node 定义的：对于元素，它的意义与 tagName 相同。对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。</p></blockquote><h5 id="inner-outerHTML属性-内容操作"><a href="#inner-outerHTML属性-内容操作" class="headerlink" title="inner/outerHTML属性 :内容操作"></a>inner/outerHTML属性 :内容操作</h5></li><li><p>innerHTML 属性允许将元素中的 HTML 获取为<strong>字符串形式</strong>。我们也可以修改它。(替换原来的元素)</p></li><li><p>“innerHTML+=” 会进行完全重写,移除旧的内容。然后写入新的 innerHTML（新旧结合）。</p></li><li><blockquote><p>移除内容的副作用: 因为内容已“归零”并从头开始重写，因此所有的图片和其他资源都将重写加载</p></blockquote></li><li><p>innerHTML 不包括外围的元素标签,只在元素内中作用</p></li></ul><ul><li><p>outerHTML 属性包含了元素的完整 HTML。就像 innerHTML 加上元素本身一样。</p></li><li><blockquote><p>与 innerHTML 不同，写入 outerHTML 不会改变元素。而是在 DOM 中替换它, 将其从 DOM 中删除并在其位置插入新的 HTML。仅仅在DOM上移除,但并没有删除该元素,通过引用还可以得到旧值,所以我们说outerHTML不会改变元素,使用时我们需要查询DOM获取对新元素的引用</p></blockquote></li></ul><ul><li><p><strong>nodeValue/data</strong>：读取/设置文本节点内容 </p></li><li><blockquote><p><strong>仅对文本节点有效</strong>,返回文本内容 </p></blockquote></li><li><p>innerHTML 属性<strong>仅对元素节点有效。</strong></p></li><li><blockquote><p>其他节点类型，例如文本节点，具有它们的对应项：nodeValue 和 data 属性。这两个属性在实际使用中几乎相同,获取修改节点内容</p></blockquote></li></ul><h5 id="textContent-纯文本"><a href="#textContent-纯文本" class="headerlink" title="textContent: 纯文本"></a>textContent: 纯文本</h5><ul><li><blockquote><p>textContent  对所有节点有效</p></blockquote></li><li><p>textContent 提供了对元素内的 文本 的访问权限：仅文本，去掉所有 &lt; tags&gt;。在实际开发中，用到这样的文本读取的场景非常少。</p></li><li><p>写入 textContent 要有用得多，因为它允许以“安全方式”写入文本。 所有符号（symbol）均按字面意义处理。例如可以写入 &lt; b&gt; 等标签像普通字符一样</p></li></ul><ul><li>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见。我们可以在 HTML 中使用它，或者使用 JavaScript 进行赋值</li><li>innerText 和textContent  区别, textContent 可以输出所有文本内容,innerText只能输出哪些在页面渲染出来的文本, 如果部分文本隐藏,无法显示</li><li>和innerHTML 区别在于,innerHtml会连同标签一起输出</li></ul><h4 id="特性和属性（Attributes-and-properties）"><a href="#特性和属性（Attributes-and-properties）" class="headerlink" title="特性和属性（Attributes and properties）"></a>特性和属性（Attributes and properties）</h4><ul><li><p>特性（attribute）— 写在 HTML 中的内容。</p></li><li><p>属性（property）— DOM 对象中的内容。</p></li><li><p>对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）, </p></li><li><blockquote><p>特性 — 属性映射并不是一一对应的</p></blockquote></li><li><p>DOM 属性 :  DOM 节点是常规的 JavaScript 对象,我们可以创建一个新的属性(属性值 函数…),还可以修改内建属性的原型，例如修改 Element.prototype 为所有元素添加一个新方法</p></li><li><p>HTML特性 :  在HTML中，标签可能拥有特性（attributes）。当浏览器解析HTML文本，并根据标签创建 DOM 对象时，浏览器会辨别 标准的 特性并以此创建 DOM 属性。但是非 标准的 特性则不会。</p></li><li><blockquote><p>如果一个特性不是标准的，那么就没有相对应的 DOM 属性</p></blockquote></li><li><blockquote><p>一个元素的标准的特性对于另一个元素可能是未知的。例如 “type” 是 &lt; input&gt; 的一个标准的特性（HTMLInputElement），但对于 &lt; body&gt;（HTMLBodyElement）来说则不是。</p></blockquote><h5 id="特性操作-所有特性都可以通过使用以下方法进行访问"><a href="#特性操作-所有特性都可以通过使用以下方法进行访问" class="headerlink" title="特性操作 (所有特性都可以通过使用以下方法进行访问):"></a>特性操作 (所有特性都可以通过使用以下方法进行访问):</h5><pre><code>  elem.hasAttribute(name) — 检查特性是否存在。  elem.getAttribute(name) — 获取这个特性值。  elem.setAttribute(name, value) — 设置这个特性值。  elem.removeAttribute(name) — 移除这个特性。</code></pre><blockquote><p>也可以使用 elem.attributes 读取所有特性：属于内建 Attr 类的对象的集合，具有 name 和 value 属性。</p></blockquote></li></ul><ul><li><p>HTML特性有以下几个特征：它们的名字是大小写不敏感的（id 与 ID 相同）。它们的值总是字符串类型的(使用alert输出总是字符串)。</p></li><li><blockquote><p>  使用get…获取时大小写不敏感 ; </p><p>  将任何东西赋值set..给特性，这些东西会变成字符串类型 ;</p><p>   attributes 集合是可迭代对象</p></blockquote></li><li><p>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</p></li><li><blockquote><p>例如 input.value 只能从特性同步到属性，反过来则不行：</p><p>这个“功能”在实际中会派上用场，因为用户行为可能会导致 value 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。</p></blockquote></li></ul><ul><li><p>DOM 属性不总是字符串类型的 :   input.checked 属性（对于 checkbox 的）是布尔型的。 style 属性是一个对象</p></li><li><blockquote><p>尽管大多数 DOM 属性都是字符串类型的。有一种非常少见的情况，即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的。 href 属性 : 一直是一个完整的 URL  href特性 : 标签中的值</p></blockquote><h5 id="自定义-非标准-特性"><a href="#自定义-非标准-特性" class="headerlink" title="自定义(非标准)特性"></a>自定义(非标准)特性</h5></li><li><p>有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。但是自定义的特性也存在问题,名字之间可能会有冲突。</p></li><li><p>如果我们出于我们的目的使用了非标准的特性，之后它被引入到了标准中并有了其自己的用途，该怎么办？ 为了避免冲突，存在 data-* 特性。</p></li><li><blockquote><p>所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。如果一个 elem 有一个名为 “data-about” 的特性，那么可以通过 elem.dataset.about 取到它</p></blockquote></li></ul><ul><li><p>在大多数情况下，最好使用 DOM 属性。仅当 DOM 属性无法满足开发需求，并且我们真的需要特性时，才使用特性</p><blockquote><p>例如：我们需要一个非标准的特性。但是如果它以 data- 开头，那么我们应该使用 dataset。</p><p>我们想要读取 HTML 中“所写的”值。对应的 DOM 属性可能不同，例如 href 属性一直是一个 完整的 URL，但是我们想要的是“原始的”值。</p></blockquote></li><li><p>自定义属性可以和 样式结合起来,  通过css属性选择符,规定特定的属性有特定的样式</p></li></ul><hr><h4 id="修改文档-document"><a href="#修改文档-document" class="headerlink" title="修改文档(document)"></a>修改文档(document)</h4><ul><li><p>创建元素 : document.createElement(tag) //元素节点  document.createTextNode(text) //文本节点</p></li><li><p>插入元素 :</p><pre><code>  node.append(...nodes or strings) — 在 node 末尾 插入节点或字符串，  node.prepend(...nodes or strings) — 在 node 开头 插入节点或字符串，  node.before(...nodes or strings) — 在 node 前面 插入节点或字符串，  node.after(...nodes or strings) — 在 node 后面 插入节点或字符串，  node.replaceWith(...nodes or strings) — 将 node 替换为给定的节点或字符串。</code></pre></li><li><blockquote><p>这些方法可以在单个调用中插入多个节点列表和文本片段。</p><p> div.before(‘<p>Hello</p>‘,document.createElement(‘hr’)); </p><p>字符串被以一种安全的方式插入到页面中,就像 elem.textContent 所做的一样。 &lt; p&gt; 将不会有任何意义,插入后会被转义成 &amp;lt…</p></blockquote></li><li><blockquote><p>这些方法只能用来插入 DOM 节点或文本片段。</p></blockquote></li><li><p>如果我们想要将内容“作为 HTML 代码插入”，像使用 <code>elem.innerHTML</code> 所表现的效果一样,我们可以使用另一个非常通用的方法：elem.insertAdjacentHTML(where, html)。</p></li><li><p>**elem.insertAdjacentHTML(where, html): **</p></li><li><p>第一个参数是代码字（code word），指定相对于 elem 的插入位置。第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;beforebegin&quot;</span> — 将 html 插入到 elem 前插入，<br><span class="hljs-string">&quot;afterend&quot;</span> — 将 html 插入到 elem 后。<br><span class="hljs-string">&quot;afterbegin&quot;</span> — 将 html 插入到 elem 开头，<br><span class="hljs-string">&quot;beforeend&quot;</span> — 将 html 插入到 elem 末尾，<br></code></pre></td></tr></table></figure></li><li><p>elem.insertAdjacentText(where, text) — 语法一样，但是将 text 字符串“作为文本”插入而不是作为 HTML，     elem.insertAdjacentElement(where, elem) — 语法一样，但是插入的是一个元素。  </p><blockquote><p>它们的存在主要是为了使语法“统一”。因为对于元素和文本，我们有 append/prepend/before/after 方法 </p></blockquote></li></ul><ul><li><p>节点移除 </p></li><li><p>想要移除一个节点 :  node.remove()。</p></li><li><blockquote><p>如果我们要将一个元素移动到另一个地方,不需要删除后再添加,插入方法会自动从旧位置删除该节点。在新的位置添加</p></blockquote></li><li><p>克隆节点：</p></li><li><p>cloneNode  调用 elem.cloneNode(true) 来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。        如果我们调用 elem.cloneNode(false)，那克隆就不包括子元素。</p></li></ul><ul><li><p>DocumentFragment 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。</p><h5 id="老式的-insert-remove-方法"><a href="#老式的-insert-remove-方法" class="headerlink" title="老式的 insert/remove 方法"></a>老式的 insert/remove 方法</h5></li><li><p>由于历史原因，还存在“老式”的 DOM 操作方法。我们在这儿列出这些方法的唯一原因是，你可能会在许多就脚本中遇到它们。</p></li><li><p>parentElem.appendChild(node)  将 node 附加为 parentElem 的最后一个子元素。</p></li><li><p>parentElem.insertBefore(node, nextSibling)  在 parentElem 的 nextSibling 前插入 node。</p></li><li><p>parentElem.replaceChild(node, oldChild)  将 parentElem 的后代中的 oldChild 替换为 node。</p></li><li><p>parentElem.removeChild(node) 从 parentElem 中删除 node（假设 node 为 parentElem 的后代）。</p></li><li><blockquote><p>所有这些方法都会返回插入/删除的节点。换句话说，parentElem.appendChild(node) 返回 node。</p></blockquote></li><li><p>还有一个非常古老的向网页添加内容的方法：document.write 调用 document.write(html) 意味着将 html “就地马上”写入页面。document.write`调用只在页面加载时工作,如果我们稍后调用它，则现有文档内容将被擦除。</p></li><li><blockquote><p>调用 <code>document.write</code> 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它。所以它运行起来出奇的快，因为它 <strong>不涉及 DOM 修改</strong>。它直接写入到页面文本中，而此时 DOM 尚未构建。</p></blockquote></li></ul><h4 id="样式和类"><a href="#样式和类" class="headerlink" title="样式和类"></a>样式和类</h4><ul><li><p>JavaScript 既可以修改类，也可以修改 style 属性。相较于将样式写入 style 属性，我们应该首选通过 CSS 类的方式来添加样式。仅当类“无法处理”时，才应选择使用 style 属性的方式。</p></li><li><p>className 和 classList </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">elem.className 对应于 <span class="hljs-string">&quot;class&quot;</span> 特性（attribute）。<br>类似 setAttribute()操作,整体替换<br><br>如果我们对 elem.className 进行赋值，它将替换类中的整个字符串。有时，这正是我们所需要的，但通常我们希望添加/删除单个类。 (某个元素可能有多个类名),我们既可以使用 className 对完整的类字符串进行操作，也可以使用使用 classList 对单个类进行操作<br><br>elem.classList 是一个特殊的对象，它具有 add/remove/toggle 单个类的方法。<br></code></pre></td></tr></table></figure></li><li><blockquote><p>elem.classList.contains(class) — 检查给定类，返回 true/false。</p></blockquote></li><li><p>classList 是可迭代的 可以使用for of 进行输出所有类名</p><h5 id="元素样式"><a href="#元素样式" class="headerlink" title="元素样式"></a>元素样式</h5></li><li><p>elem.style 属性是一个对象，它对应于 “style” 特性（attribute）中所写的内容</p></li><li><blockquote><p>对于多词（multi-word）属性，使用驼峰式 . 前缀属性像 -moz-border-radius 和 -webkit-border-radius 这样的浏览器前缀属性，也遵循同样的规则</p></blockquote></li><li><p><strong>重置样式属性</strong> : </p><ul><li>不应该使用 delete elem.style.display，而应该使用 elem.style.display = “” 将其赋值为空。</li></ul></li><li><p><strong>设置多个样式属性</strong> : </p><ul><li><p>我们不能像这样的 div.style=”color: red; width: 100px” 设置完整的属性，因为 div.style 是一个对象，并且它是只读的</p></li><li><p>想要以字符串的形式设置完整的样式，可以使用特殊属性 style.cssText ,这样的赋值会删除所有现有样式：它不是进行添加样式，而是替换所有样式。</p></li><li><blockquote><p>可以通过设置一个特性（attribute）来实现同样的效果：div.setAttribute(‘style’, ‘color: red…’)。</p></blockquote></li></ul></li></ul><blockquote><p>不要忘记将 CSS 单位添加到值上.</p><p>style 属性仅对 “style” 特性（attribute）值起作用,不能获取在style外应用的 样式,如果想要获得当前应用的css样式使用以下 :</p></blockquote><ul><li><p><strong>计算样式</strong>：getComputedStyle(element, [pseudo])  </p></li><li><blockquote><p>结果是一个具有样式属性的对象 ,通过 . 调用获得当前应用样式</p><p>pseudo : 表示一个伪元素  ::before .. 要添加引号</p></blockquote></li></ul><ul><li><p>计算值和解析值</p><blockquote><p>计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，它看起来像 height:1em 或 font-size:125%。</p></blockquote><blockquote><p>解析 (resolved) 样式值是最终应用于元素的样式值值。浏览器将使用计算（computed）值，并使所有单位均为固定的,且为绝对单位，例如：height:20px 或 font-size:16px</p></blockquote></li><li><blockquote><p>现在 getComputedStyle 实际上返回的是属性的解析值（resolved）。</p></blockquote></li></ul><ul><li><p>getComputedStyle 需要完整的属性名,我们应该总是使用我们想要的确切的属性，例如 paddingLeft、marginTop 或 borderTopWidth。否则，就不能保证正确的结果。</p></li><li><blockquote><p>如果有 paddingLeft/paddingTop 属性，那么对于 getComputedStyle(elem).padding，我们会得到什么？什么都没有，或者是从已知的 padding 中“生成”的值？这里没有标准的规则。</p></blockquote></li><li><p>  getComputedStyle 没有办法是用伪类获取 样式</p></li><li><blockquote><p>JavaScript 看不到 <code>:visited</code> 所应用的样式。此外，CSS 中也有一个限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式</p></blockquote></li></ul><h4 id="元素大小-滚动"><a href="#元素大小-滚动" class="headerlink" title="元素大小 滚动"></a>元素大小 滚动</h4><ul><li>JavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。</li></ul><ul><li><p>一些浏览器（并非全部）通过从内容大小中获取空间来为滚动条保留空间。 如果有padding在padding中出现滚动条  </p></li><li><blockquote><p>google 内容宽度计算会减去滚动条的宽度   火狐则是 内容大小不变(但实际滚动条仍是占据了内容宽度)   不管有无padding都遵循上述内容</p></blockquote></li><li><blockquote><p>如果元素中有很多文本，并且溢出了，那么浏览器会在 padding-bottom 处显示“溢出”文本，这是正常现象。</p></blockquote></li></ul><ul><li><p>如果一个元素（或其任何祖先）具有 display:none 或不在文档中，则所有几何属性均为零（或 offsetParent 为 null）。 我们可以用它来检查一个元素是否被隐藏 :    </p></li><li><pre><code class="javascript">return !elem.offsetWidth &amp;&amp;!elem.offsetHeight;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs"><br>    <br><br>    <br><br>     **offsetParent，offsetLeft/Top ,offsetWidth/Height  :**<br><br>- offsetParent 返回一个最接近的祖先<br><br>    ```html<br>    最近的祖先为下列之一：<br>    CSS 定位的（position 为 absolute，relative 或 fixed），<br>    或 &lt;td&gt;，&lt;th&gt;，&lt;table&gt;，<br>    或 &lt;body&gt;。<br></code></pre></td></tr></table></figure></code></pre></li><li><blockquote><p>属性 offsetLeft/offsetTop 提供相对于 offsetParent 左上角的 x/y 坐标。</p><p>offsetWidth/Height 提供了元素的完整大小（包括边框）。</p></blockquote><p>  <strong>clientTop/Left,clientWidth/Height :</strong></p></li><li><p>clientTop/Left  : 在元素内部，我们有边框（border)。为了测量它们，可以使用 clientTop 和 clientLeft。</p></li><li><blockquote><p>但准确地说 — 这些属性不是边框的 width/height，而是内侧与外侧的相对坐标。当文档从右到左显示（操作系统为阿拉伯语或希伯来语）时，影响就显现出来了。此时滚动条不在右边，而是在左边，此时 clientLeft 则包含了滚动条的宽度。</p></blockquote></li><li><p>clientWidth/Height : 这些属性提供了元素边框内区域的大小。 它们包括了 “content width” 和 “padding”，但不包括滚动条宽度（scrollbar）：</p></li><li><blockquote><p>如果这里没有 padding，那么 clientWidth/Height 代表的就是内容区域，即 border 和 scrollbar（如果有）内的区域。</p></blockquote></li></ul><p><strong>scrollWidth/Height, scrollLeft/scrollTop :</strong></p><ul><li><p>scrollWidth/Height :  这些属性就像 clientWidth/clientHeight，但它们还包括滚动出（隐藏）的部分：</p></li><li><blockquote><p>scrollHeight : 是内容区域的完整内部高度，包括滚动出的部分。  </p><p>scrollWidth  : 是完整的内部宽度，没有水平滚动时，它等于 clientWidth。</p></blockquote></li><li><p>scrollLeft/scrollTop :  是元素的隐藏、滚动部分的 width/height。 换句话说，scrollTop 就是“已经滚动了多少”。</p></li><li><blockquote><p>除了 scrollLeft/scrollTop 外，所有属性都是只读的。如果我们修改 scrollLeft/scrollTop，浏览器会滚动对应的元素。</p></blockquote></li></ul><ul><li>不要从 CSS 中获取 width/height<ol><li>首先，CSS width/height 取决于另一个属性：box-sizing，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 box-sizing 进行的更改可能会破坏此类 JavaScript 操作</li><li>其次，CSS 的 width/height 可能是 auto，例如内联（inline）元素： 在 JavaScript 中，我们需要一个确切的 px 大小，以便我们在计算中使用它。因此，这里的 CSS 宽度没什么用</li><li>滚动条问题:使用 getComputedStyle(elem).width 时，有些返回实际宽度, 有些返回的宽度中包含滚动条</li></ol></li></ul><h4 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h4><ul><li><p><strong>获取窗口（window）的宽度和高度</strong>:，我们可以使用 document.documentElement 的 clientWidth/clientHeight </p></li><li><blockquote><p><strong>clientWidth/clientHeight</strong> 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height</p><p><strong>window.innerWidth/innerHeight</strong> 属性。 则包括了滚动条的宽度高度</p></blockquote></li><li><p><strong>获取文档的 width/height:</strong>, 从理论上讲，由于根文档元素是 document.documentElement，并且它包围了所有内容，因此我们可以通过使用 documentElement.scrollWidth/scrollHeight 来测量文档的完整大小。<br>但是在该元素上，对于整个文档，这些属性均无法正常工作。</p></li></ul><blockquote><p>为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-built_in">Math</span>.max(<br>  <span class="hljs-built_in">document</span>.body.scrollHeight, <span class="hljs-built_in">document</span>.documentElement.scrollHeight,<br>  <span class="hljs-built_in">document</span>.body.offsetHeight, <span class="hljs-built_in">document</span>.documentElement.offsetHeight,<br>  <span class="hljs-built_in">document</span>.body.clientHeight, <span class="hljs-built_in">document</span>.documentElement.clientHeight<br>);<br><br></code></pre></td></tr></table></figure><ul><li><strong>获得当前滚动</strong> :</li><li>DOM 元素的当前滚动状态在 elem.scrollLeft/scrollTop 中。</li><li><blockquote><p>对于文档滚动，在大多数浏览器中，我们可以使用 document.documentElement.scrollLeft/Top，但在较旧的基于 WebKit 的浏览器中则不行</p><p>我们根本不必记住这些特性，因为滚动在 <code>window.pageXOffset/pageYOffset</code> 中可用</p><p>这些属性是只读的</p></blockquote></li></ul><ul><li><strong>更改滚动</strong>：</li><li><blockquote><p>scrollTo，scrollBy，scrollIntoView</p><p>window.scrollBy(x,y),将页面滚动至相对于当前位置(针对窗口)的 (x, y) 位置  </p><p>window.scrollTo(pageX,pageY)。将页面滚动至绝对坐标(针对文档)        这些方法适用于所有浏览器。</p><p>对 elem.scrollIntoView(top) 的调用将滚动页面以使 elem 可见 ,  top=true（默认值） 页面滚动，使 elem 出现在窗口顶部  top=false，页面滚动，使 elem 出现在窗口底部。</p></blockquote></li></ul><ul><li> 禁止滚动 :要使文档不可滚动，只需要设置 document.body.style.overflow = “hidden”。该页面将冻结在其当前滚动上。 document.body.style.overflow = ‘’ 恢复滚动</li><li><blockquote><p>我们还可以使用相同的技术来“冻结”其他元素的滚动，而不仅仅是 document.body。</p></blockquote></li></ul><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><ul><li><p>大多数 JavaScript 方法处理的是以下<strong>两种坐标系</strong>中的一个：</p></li><li><blockquote><p>相对于窗口 — 类似于 position:fixed，从窗口的顶部/左侧边缘计算得出。<br>我们将这些坐标表示为 clientX/clientY<br>相对于文档 — 与文档根（document root）中的 position:absolute 类似，从文档的顶部/左侧边缘计算得出。我们将它们表示为 pageX/pageY。</p></blockquote></li><li><blockquote><p>当页面滚动到最开始时，此时窗口的左上角恰好是文档的左上角，它们的坐标彼此相等。但是，在文档移动之后，元素的窗口相对坐标会发生变化，因为元素在窗口中移动，而元素在文档中的相对坐标保持不变。</p></blockquote></li></ul><ul><li><p><strong>元素坐标</strong>：elem.getBoundingClientRect() </p></li><li><blockquote><p>方法 <code>elem.getBoundingClientRect()</code> 返回最小矩形的窗口坐标，该矩形将 <code>elem</code> 作为内建 <a href="https://www.w3.org/TR/geometry-1/#domrect">DOMRect</a> 类的对象</p><p>返回值是一个 DOMRect 对象</p><p>主要 DOMRect 属性 :</p><p>  x/y — 矩形原点相对于窗口的 X/Y 坐标，<br>  width/height — 矩形的 width/height（可以为负）。<br>  此外，还有派生（derived）属性：</p><p>  top/bottom — 顶部/底部矩形边缘的 Y 坐标，<br>  left/right — 左/右矩形边缘的 X 坐标。    </p><p>​        </p><p>窗口的所有坐标都从左上角开始计数 ,与CSS position top/bottom属性不同</p></blockquote></li></ul><ul><li><p>elementFromPoint(x, y), 会返回在窗口坐标 (x, y) 处嵌套最多（the most nested）的元素。</p></li><li><blockquote><p>方法 document.elementFromPoint(x,y) 只对在可见区域内的坐标 (x,y) 起作用。</p></blockquote></li></ul><ul><li><p><strong>文档坐标:</strong></p></li><li><p>文档相对坐标从文档的左上角开始计算，而不是窗口。</p></li><li><p>这两个坐标系统通过以下公式相连接：</p></li><li><blockquote><p>pageY = clientY + 文档的垂直滚动出的部分的高度。  pageX = clientX + 文档的水平滚动出的部分的宽度。</p></blockquote></li><li><blockquote><p>窗口坐标非常适合和 position:fixed 一起使用，文档坐标非常适合和 position:absolute 一起使用。</p></blockquote></li></ul><h3 id="事件简介"><a href="#事件简介" class="headerlink" title="事件简介"></a>事件简介</h3><h4 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h4><ul><li><p>常用事件:      </p></li><li><p>Document 事件DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</p></li><li><p>CSS 事件：transitionend —— 当一个 CSS 动画完成时。</p><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><ul><li><p>事件处理程序可以设置在 HTML 中名为 on<event> 的特性（attribute）中。</p></li><li><blockquote><p>不要对处理程序使用 setAttribute。 document.body.setAttribute(‘onclick’, function() { alert(1) });  </p><p>//失效</p></blockquote></li><li><blockquote><p>如果一个处理程序是通过 HTML 特性（attribute）分配的，浏览器读取特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）</p><p>onclick=”sayThanks()” —-&gt;创建一个处理程序 :  button.onclick = function() {sayThanks();};</p></blockquote></li><li><blockquote><p>如果在html特性中写处理程序,this表示全局对象 window 在严格模式中为 undefined。 </p></blockquote></li></ul></li></ul><ul><li><p>我们还可以使用 DOM 属性（property）on<event> 来分配处理程序。</p></li><li><blockquote><p>elem.onclick = function() {}  </p><p>要移除一个处理程序 —— 赋值 elem.onclick = null。</p><p>使用上述 方法只能添加一个 onclick 属性,后面的覆盖前面</p></blockquote></li></ul><ul><li><p>addEventListener 和 removeEventListener 来管理处理程序的替代方法,可以为一个事件分配多个处理程序</p></li><li><blockquote><pre><code class="javascript">element.addEventListener(event, handler[, options]);  和removeEventListener语法相同options具有以下属性的附加可选对象：once：如果为 true，那么会在被触发后自动删除监听器。capture：事件处理的阶段，true :捕获阶段处理程序passive：如果为 true，那么处理程序将不会调用 preventDefault()，由于历史原因，options 也可以是 false/true，它与 &#123;capture: false/true&#125; 相同。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">   -</span> 要移除处理程序，我们需要传入与分配的函数完全相同的函数<br><br><span class="hljs-bullet">   -</span> &gt; 直接给于匿名函数(或箭头函数)来移除处理程序无法实现,过程中相当于创建了两个相同内容的不同的函数<br><br>对于某些事件，只能通过 addEventListener 设置处理程序,例如 transtionend 和 DOMContentLoaded<br>   <br>   <br><br><span class="hljs-bullet">-</span> HTML特性中处理函数带括号,而其余的处理方式不带括号,带括号相当于直接函数调用<br><br><span class="hljs-bullet">-</span> 为什么要使用 <span class="hljs-code">`addEventListener`</span>?<br><br><span class="hljs-bullet">-</span> &gt; 它允许给一个事件注册多个监听器<br><br>它提供了一种更精细的手段控制 <span class="hljs-code">`listener`</span> 的触发阶段。（即可以选择捕获或者冒泡）<br><br>它对任何 DOM 元素都是有效的<br><br> ##### 事件对象<br><br><span class="hljs-bullet">-</span> 当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。<br><br><span class="hljs-bullet">-</span> event 对象的一些属性：<br><br><span class="hljs-bullet">-</span> &gt; type  事件类型     <br><br>currentTarget   处理事件的元素  <br><br>.event.clientX / event.clientY  指针事件中指针的窗口相对坐标<br><br><br><br>还有很多属性。其中很多都取决于事件类型：键盘事件具有一组属性，指针事件具有另一组属性<br><br><span class="hljs-bullet">-</span> event 对象在 HTML 特性中处理程序中也可用<br><br> <br><br> ##### 对象处理程序<br><br><span class="hljs-bullet">-</span> 我们不仅可以分配函数，还可以使用 addEventListener 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 handleEvent 方法。 我们还可以为此使用类创建一个对象<br><br><span class="hljs-bullet">-</span> 此类中必须要有一个handleEvent(event) 方法<br><br>handleEvent 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法<br><br>这样会使事件处理程序分离出来,更利于后期维护   : 事件委托章节中的实例诠释了这种写法<br><br><br><span class="hljs-section">#### 冒泡和捕获</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**冒泡**</span>（bubbling）原理很简单。当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。<br><br><br><span class="hljs-bullet">-</span> &gt; event.target —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。  计划运行的元素<br><br>this —— 实际上处理事件的&quot;当前&quot;元素.  ( == event.currentTarget)  <br><span class="hljs-bullet">-</span> 冒泡事件从目标元素开始向上冒泡 ,它们会调用路径上所有的处理程序。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**停止冒泡的方法**</span>是 event.stopPropagation()。 如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行, event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的其他处理程序运行<br><br><span class="hljs-bullet">-</span> &gt; 通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**捕获**</span> : <br><span class="hljs-bullet">-</span> DOM 事件标准描述了事件传播的 3 个阶段：捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。      目标阶段（Target phase）—— 事件到达目标元素。   冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。<br><br><span class="hljs-bullet">-</span> &gt; 为了在捕获阶段捕获事件，我们需要将处理程序的 capture 选项设置为 true 如果为 false（默认值），则在冒泡阶段设置处理程序。<br><br><span class="hljs-bullet">-</span> 要移除处理程序，<span class="hljs-code">`removeEventListener`</span> 需要同一阶段<br><br><br><span class="hljs-bullet">-</span> 如果我们在同一阶段有多个事件处理程序，并通过 <span class="hljs-code">`addEventListener`</span> 分配给了相同的元素，则它们的运行顺序与创建顺序相同<br><br>冒泡 和捕获 的两种方式, 实际上在影响事件的执行顺序, 冒泡是子元素首先执行事件,  捕获 是父元素首先执行事件<br><br><br><br><span class="hljs-section">#### 事件委托</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```javascript</span><br><span class="hljs-code"> event.target.closest(&#x27;td&#x27;)  针对td中有嵌套元素时,用来获取td元素的方法 </span><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p>委托示例：标记中的行为  看看实例的书写 <a href="https://zh.javascript.info/event-delegation">https://zh.javascript.info/event-delegation</a> 通过自定义特性进行标记, 写一个类, 通过获取自定义属性执行相应的函数, 把该类绑定到父元素上事件处理</p></li><li><p>行为模式 :将描述其行为的自定义特性添加到元素。 用文档范围级的处理程序追踪事件(通过事件委托),如果事件发生在具有特定特性的元素上,则执行行为   </p></li><li><blockquote><p>这可能变得非常方便 —— 无需为每个这样的元素编写 JavaScript。只需要添加自定义特性。文档级处理程序使其适用于页面的任意元素。  可能为库 框架提供一个方便的调用</p></blockquote></li></ul><h4 id="浏览器默认行为"><a href="#浏览器默认行为" class="headerlink" title="浏览器默认行为"></a>浏览器默认行为</h4><ul><li><blockquote><p>点击一个链接 —— 触发导航（navigation）到该 URL。</p><p>点击表单的提交按钮 —— 触发提交到服务器的行为。</p><p>在文本上按下鼠标按钮并移动 —— 选中文本。</p></blockquote></li><li><p>某些事件会相互转化。如果我们阻止了第一个事件，那就没有第二个事件了。</p></li></ul><ul><li><p>有两种方式来告诉浏览器我们不希望它执行默认行为：</p></li><li><blockquote><p> 主流的方式是使用 event 对象。有一个 event.preventDefault() 方法。</p><p> 如果处理程序是使用 on<event>（而不是 addEventListener）分配的，那返回 false 也同样有效。从处理程序返回 false 是一个例外, 事件处理程序返回的值通常会被忽略。唯一的例外是从使用 on<event> 分配的处理程序中返回的 return false。</p><p>addEventListener 的可选项 passive: true 向浏览器发出信号，表明处理程序将不会调用 preventDefault()。</p></blockquote></li></ul><ul><li><p>如果默认行为被阻止，那么 event.defaultPrevented 属性为 true，否则为 false。</p></li><li><blockquote><p>有时我们可以使用 event.defaultPrevented 来代替，来通知其他事件处理程序，该事件已经被处理。</p><p>不而再使用event.stopPropagation() , 来阻止冒泡</p><p>例如,同一个右击事件通过冒泡,丛子级到祖先,在祖先处理事件中验证event.defaultPrevented 的值,就可以得到该事件是否已经触发过了。</p></blockquote></li></ul><ul><li>event.stopPropagation() 和 event.preventDefault()是两个不同的东西。它们之间毫无关联。</li></ul><h4 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h4><ul><li><p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 Event 类。</p></li><li><p><strong>创建自定义事件过程</strong> :</p><ul><li>1.let event = new Event(type[, options]); // 创建事件对象</li></ul><blockquote><p>type —— 事件类型，可以是像这样 “click” 的字符串，或者我们自己的像这样 “my-event” 的参数。</p><p>options —— 具有两个可选属性的对象：</p><p>bubbles: true/false —— 如果为 true，那么事件会冒泡</p><p>cancelable: true/false —— 如果为 true，那么“默认行为”就会被阻止。</p><p>默认情况下，以上两者都为 false：必须设置 bubbles:true，否则事件不会向上冒泡。</p></blockquote><ul><li><p>2.事件对象被创建后，我们应该使用 elem.dispatchEvent(event) 调用在元素上’’运行’’它。然后,处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样     event 是新建的事件对象名字</p></li><li><blockquote><p>我们应该对我们的自定义事件使用 addEventListener，因为 on<event> 仅存在于内建事件中，document.onhello 则无法运行。</p></blockquote></li></ul></li></ul><ul><li><p>有一种方法可以区分“真实”用户事件和通过脚本生成的事件。</p></li><li><blockquote><p>对于来自真实用户操作的事件，event.isTrusted 属性为 true，</p><p>对于脚本生成的事件，event.isTrusted 属性为 false</p></blockquote></li></ul><ul><li><p>其他像 MouseEvent 和 KeyboardEvent ,如果我们想要创建这样的事件，我们应该使用它们而不是 <code>new Event</code>。例如，<code>new MouseEvent(&quot;click&quot;)</code>。</p></li><li><blockquote><p>正确的构造器允许为该类型的事件指定标准属性。就像鼠标事件的 <code>clientX/clientY</code> 一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">&quot;click&quot;</span>, <br>        &#123;<br>         bubbles: <span class="hljs-literal">true</span>, <br>         cancelable: <span class="hljs-literal">true</span>,  <br>         clientX: <span class="hljs-number">100</span>,  <br>         clientY: <span class="hljs-number">100</span> <br>        &#125;);<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>对于我们自己的全新事件类型，例如 “hello”，我们应该使用 new CustomEvent()。</p></li><li><blockquote><p>从技术上讲，CustomEvent 和 Event 一样。除了一点不同。 在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 detail。以避免与其他事件属性的冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;h1 id=<span class="hljs-string">&quot;elem&quot;</span>&gt;Hello <span class="hljs-keyword">for</span> John!&lt;/h1&gt;<br><br>&lt;script&gt;<br>  <span class="hljs-comment">// 事件附带给处理程序的其他详细信息</span><br>  elem.addEventListener(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>    alert(event.detail.name);<br>  &#125;);<br><br>  elem.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;hello&quot;</span>, &#123;<br>    detail: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;<br>  &#125;));<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>对于新的，自定义的事件，绝对没有默认的浏览器行为，但是绑定此类事件的代码可能有自己的计划，触发该事件之后应该做什么。</p></li><li><blockquote><p>通过调用 event.preventDefault()，事件处理程序可以发出一个信号，指出这些行为应该被取消。函数结束</p><p>在这种情况下，elem.dispatchEvent(event) 的调用会返回 false</p></blockquote></li></ul><ul><li><p>通常事件是在队列中处理的。也就是说：如果浏览器正在处理 onclick，这时发生了一个新的事件，例如鼠标移动了，那么它会被排入队列，相应的 mousemove 处理程序将在 onclick 事件处理完成后被调用。</p></li><li><blockquote><p>值得注意的例外情况就是，一个事件是在另一个事件中发起的,例如使用 <code>dispatchEvent</code>。这类事件将会被立即处理</p><p>如果不想改变顺序,可以把另一个触发事件的调用包装到零延迟的 setTimeout 中</p></blockquote></li></ul><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><ul><li><p>此类事件不仅可能来自于“鼠标设备”，还可能来自于对此类操作进行了模拟以实现兼容性的其他设备，例如手机和平板电脑。</p></li><li><p>在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 mousedown → mouseup → click 的顺序调用处理程序。</p><h5 id="键位获取属性"><a href="#键位获取属性" class="headerlink" title="键位获取属性"></a>键位获取属性</h5></li><li><p>event.button 属性 获取鼠标按钮键位 ,左中右键,分别返回0 1 2 …</p></li><li><blockquote><p>旧代码可能会使用event.which属性获取鼠标键盘键位，这是获取按钮的一种旧的非标准方式， 现在不推荐使用(考虑兼容性可以使用)</p></blockquote></li><li><p>所有的鼠标事件都包含有关按下的组合键的信息。事件属性：</p><pre><code>  shiftKey：Shift  altKey：Alt（或对于 Mac 是 Opt）  ctrlKey：Ctrl  metaKey：对于 Mac 是 Cmd</code></pre><h5 id="坐标获取属性"><a href="#坐标获取属性" class="headerlink" title="坐标获取属性"></a>坐标获取属性</h5></li><li><p>所有的鼠标事件都提供了两种形式的坐标：</p><pre><code>  相对于窗口(浏览器内)的坐标：clientX 和 clientY。  相对于文档的坐标：pageX 和 pageY。  相对于屏幕的坐标 :ScreenX ScreenY</code></pre></li><li><p>如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：oncopy。</p></li><li><p>如何防止 ,鼠标左键不松情况的文本选择,最合理的方式是防止浏览器对 <code>mousedown</code> 进行操作,mousedown事件返回false</p><h5 id="移动鼠标事件"><a href="#移动鼠标事件" class="headerlink" title="移动鼠标事件"></a>移动鼠标事件</h5></li><li><p>对于 mouseover：</p><pre><code>  event.target —— 是鼠标移过的那个元素。  event.relatedTarget —— 是鼠标来自的那个元素（relatedTarget → target）。</code></pre></li><li><p>mouseout 则与之相反：</p><pre><code>  event.target —— 是鼠标离开的元素。  event.relatedTarget —— 是鼠标移动到的，当前指针位置下的元素（target → relatedTarget）</code></pre></li><li><blockquote><p>relatedTarget 属性可以为 null。这是正常现象，仅仅是意味着鼠标不是来自另一个元素，而是来自窗口之外。或者它离开了窗口。</p></blockquote></li><li><h5 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a><strong>跳过元素</strong></h5></li><li><p>当鼠标移动时，就会触发 mousemove 事件。但这并不意味着每个像素都会导致一个事件。如果访问者非常快地移动鼠标，那么某些 DOM 元素就可能被跳过：</p></li><li><blockquote><p>这对性能很有好处，因为可能有很多中间元素。我们并不真的想要处理每一个移入和离开的过程。另一方面，我们应该记住，鼠标指针并不会“访问”所有元素。它可以“跳过”一些元素。</p><p>但是如果mouseover 被触发了，则必须有 mouseout事件</p></blockquote></li></ul><ul><li><p><strong>当鼠标指针从元素移动到其后代时</strong>触发 ,父元素的mouseout事件，子元素冒泡mouserover事件</p></li><li><blockquote><p>原因: 鼠标转到另一个元素（甚至是一个后代），那么它将离开前一个元素</p></blockquote></li><li><p>如果离开父元素时有一些行为，当鼠标指针深入子元素时，我们并不希望发生这种行为。</p></li><li><blockquote><p>为了避免它，我们可以在mouseout 处理程序中检查 relatedTarget，如果鼠标指针仍在元素内，则忽略此类事件, 在处理程序中return结束处理 。</p><p>另外，我们可以使用其他事件：mouseenter 和 mouseleave，它们没有此类问题</p></blockquote></li><li><p>事件 mouseenter 和 mouseleave</p><pre><code> 元素内部与后代之间的转换不会产生影响。 事件 mouseenter/mouseleave 不会冒泡。  （因为不会冒泡所以不能事件委托）</code></pre></li><li><blockquote><p>当鼠标移入更深入的子元素时，不会触发离开父元素的事件</p></blockquote></li></ul><h5 id="鼠标拖放事件"><a href="#鼠标拖放事件" class="headerlink" title="鼠标拖放事件"></a>鼠标拖放事件</h5><ul><li><p>在现代 HTML 标准中有一个 关于拖放的部分，其中包含了例如 dragstart 和 dragend 等特殊事件</p></li><li><blockquote><p> 原生的拖放事件也有其局限性。例如，我们无法阻止从特定区域的拖动。并且，我们无法将拖动变成“水平”或“竖直”的。还有很多其他使用它们无法完成的拖放任务。并且，移动设备对此类事件的支持非常有限。</p></blockquote></li><li><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DragEvent">MDN</a>原生拖放事件</p></li></ul><ul><li><p>基础的拖放算法 ： mousedown  mousemove  mouseup</p></li><li><blockquote><p>我们在 document 上跟踪 mousemove，而不是在 ball 上 因为在快速移动鼠标后，鼠标指针可能会从球上跳转至文档中间的某个位置（甚至跳转至窗口外）。</p></blockquote></li><li><blockquote><p>因为浏览器有自己的对图片和一些其他元素的拖放处理。它会在我们进行拖放操作时自动运行，并与我们的拖放处理产生了冲突。 解决冲突 ： ball.ondragstart = function() { return false;};</p></blockquote></li></ul><ul><li>潜在的放置目标: 在实际中，我们通常是将一个元素放到另一个元素上,当我们拖动时，可拖动元素一直是位于其他元素上的。而鼠标事件只发生在顶部元素上，而不是发生在那些下面的元素。所以无法使用鼠标事件实现</li><li><blockquote><p>使用 document.elementFromPoint 检测鼠标指针下的 “droppable” 的元素</p></blockquote></li><li><blockquote><p>document.elementFromPoint(clientX, clientY) 的方法。它会返回在给定的窗口相对坐标处的嵌套的最深的元素</p></blockquote></li></ul><h5 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h5><ul><li><p>指针事件是一种现代方式，可以处理来自各种指针设备（例如鼠标，钢笔/手写笔，触摸屏等）的输入。</p></li><li><blockquote><p>待扩展…</p></blockquote></li></ul><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><ul><li><p>当一个按键被按下时，会触发 <strong>keydown</strong> 事件，而当按键被释放时，会触发 <strong>keyup</strong> 事件。</p></li><li><blockquote><p>如果按下一个键足够长的时间，它就会开始“自动重复”：keydown 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 keyup。因此，有很多 keydown 却只有一个 keyup 是很正常的。</p><p>对于由自动重复触发的事件，event 对象的 event.repeat 属性被设置为 true。 是一个只读属性</p></blockquote></li><li><p><strong>event.code 和 event.key</strong> </p></li><li><blockquote><p>事件对象的 key 属性允许获取按键的字符，</p><p>事件对象的 code 属性则允许获取“物理按键代码”。 </p></blockquote></li></ul><ul><li><p> 物理按键代码</p><blockquote><p>  字符键的代码为 “Key<letter>“：”KeyA”，”KeyB” 等。 大小写敏感：”KeyZ”，不是 “keyZ”<br>  数字键的代码为：”Digit<number>“：”Digit0”，”Digit1” 等。<br>   特殊按键的代码为按键的名字：”Enter”，”Backspace”，”Tab” 等。</p></blockquote></li></ul><ul><li><p>选择按键处理方式 :</p></li><li><blockquote><p>例如有些键盘布局不同,但我们只绑定按到”z”键才触发,不管键盘怎样布局 —- 使用event.key</p><p>就算键盘布局不同, 只要物理位置正确,无所谓是不是按到”z”,都可以执行  —- 使用event.code</p></blockquote></li></ul><ul><li><p>阻止对 keydown 的默认行为可以取消大多数的网页行为</p></li><li><blockquote><p>keydown的默认行为:</p><p>出现在屏幕上的一个字符（最明显的结果）。</p><p>一个字符被删除（Delete 键）。</p><p>滚动页面（PageDown 键）。</p><p>浏览器打开“保存页面”对话框（Ctrl+S）</p></blockquote><ul><li>过去曾经有一个 keypress 事件，还有事件对象的 keyCode、charCode 和 which 属性。大多数浏览器对它们都存在兼容性问题，现在不再使用</li></ul><blockquote><p>以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。</p></blockquote></li></ul><h5 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h5><ul><li><p>scroll 事件允许对页面或元素滚动作出反应</p></li><li><p>我们如何使某些东西变成不可滚动？我们不能通过在 onscroll 监听器中使用 event.preventDefault() 来阻止滚动，因为它会在滚动发生 之后 才触发。但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 keydown 事件上，使用 event.preventDefault() 来阻止滚动。</p></li><li><p>通过设置 overflow 可以控制页面滚动 不滚动</p></li></ul><h4 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h4><h5 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a>表单属性和方法</h5><ul><li><p>表单（form）以及例如 input 的控件（control）元素有许多特殊的属性和事件。</p></li><li><blockquote><p>获得文档中的表单:</p><p>document.forms.name      name: 表单的name属性</p><p>document.forms[0]             文档中第一个表单</p></blockquote></li><li><blockquote><p>获得表单中的元素</p><p>form.elements.name      name : 表单中空间的name属性 </p><p>form.elements[0]            表单中第一个</p><p>可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现,在这种情况下，form.elements[name] 将会是一个集合，</p></blockquote></li></ul><ul><li><p>&lt; fieldset&gt; 元素。它们也具有 elements 属性，该属性列出了 <fieldset> 中的表单控件。</p></li><li><p>我们可以将 form.elements.login 写成 form.login 或者 form[login]</p></li><li><blockquote><p>这样写会有一个小问题 , 如果我们访问一个元素，然后修改它的 name，之后它仍然可以被通过旧的 name 访问到（当然也能通过新的 name 访问） </p><p>但是通过 form.elements 来调用只能使用新名字</p></blockquote></li></ul><ul><li><p><strong>反向引用</strong> : </p></li><li><blockquote><p>表单引用了所有元素，元素也引用了表单</p><p>其对应的表单都可以通过 <code>element.form</code> 访问到    element :表单内元素</p></blockquote></li><li><p><strong>表单控件</strong>: </p></li><li><blockquote><p>我们可以通过 <code>input.value</code>（字符串）或 <code>input.checked</code>（布尔值）来访问复选框（checkbox）中的它们的 <code>value</code>。</p><p>使用 textarea.value 访问而不是textarea.innerHTML</p></blockquote></li><li><p>select 和 option: </p><pre><code>  select.options —— &lt;option&gt; 的子元素的集合，  select.value —— 当前所选择的 &lt;option&gt; 的 value，  select.selectedIndex —— 当前所选择的 &lt;option&gt; 的编号。  设置选中状态,改变value值 :  找到对应的 &lt;option&gt; 元素，并将 option.selected 设置为 true。  将 select.value 设置为对应的 value。  将 select.selectedIndex 设置为对应 &lt;option&gt; 的编号。</code></pre></li><li><blockquote><p>如果 <select> 具有 multiple 特性（attribute），则允许多选。这个功能很少使用。在这种情况下，我们需要使用第一种方式：从 <option> 的子元素中添加/移除 selected 属性</p></blockquote></li><li><p>有一个很好的简短语法可以创建 <option> 元素：option = new Option(text, value, defaultSelected, selected);</p></li><li><blockquote><p>text —— <option> 中的文本，</p><p>value —— <option> 的 value，  </p><p>defaultSelected —— 如果为 true，那么 selected HTML-特性（attribute）就会被创建，  </p><p>selected —— 如果为 true，那么这个 <option> 就会被选中</p></blockquote></li></ul><ul><li><option> 元素具有以下属性：<pre><code>  option.selected :  &lt;option&gt; 是否被选择。  option.index : &lt;option&gt; 在其所属的 &lt;select&gt; 中的编号。  option.text  : &lt;option&gt; 的文本内容（可以被访问者看到）。</code></pre></li></ul><h5 id="表单事件-聚焦"><a href="#表单事件-聚焦" class="headerlink" title="表单事件 聚焦"></a>表单事件 聚焦</h5><ul><li><p>当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus）。当网页加载时，HTML-特性（attribute）autofocus 也可以让一个焦点落在元素上</p></li><li><p><strong>focus/blur 事件  focus/blur 方法</strong> </p></li><li><blockquote><p>elem.focus() 和 elem.blur() 方法可以设置和移除元素上的焦点。</p><p>请注意，我们无法通过在 onblur 事件处理程序中调用 event.preventDefault() 来“阻止失去焦点”，因为 onblur 事件处理程序是在元素失去焦点 之后 运行的。</p></blockquote><p><strong>不适用情况:</strong></p></li><li><p>默认情况下，很多元素不支持聚焦。列表（list）在不同的浏览器表现不同，但有一件事总是正确的：focus/blur 保证支持那些用户可以交互的元素：<button>，<input>，<select>，<a> 等。</p></li><li><p>另一方面，为了格式化某些东西而存在的元素像 <div>，<span> 和 <table> —— 默认是不能被聚焦的。elem.focus() 方法不适用于它们，并且 focus/blur 事件也绝不会被触发。</p></li></ul><ul><li><p>使用 HTML特性 tabindex可以允许在任何元素上聚焦</p></li><li><blockquote><p>任何具有 <code>tabindex</code> 特性的元素，都会变成可聚焦的。该特性的 <code>value</code> 是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号。</p><p> 值为-1 元素被忽略   = 0 默认排在最后</p><p>.tabIndex 有对应的DOM属性</p></blockquote></li></ul><ul><li><p><strong>focus/blur 委托 : focus 和 blur 事件不会向上冒泡</strong></p></li><li><blockquote><p>解决方法 : </p><p>方案一，有一个遗留下来的有趣的特性（feature）：focus/blur 不会向上冒泡，但会在捕获阶段向下传播。</p><p>方案二，可以使用 focusin 和 focusout 事件 —— 与 focus/blur 事件完全一样，只是它们会冒泡。必须使用 elem.addEventListener 来分配它们，而不是 on<event>。</p></blockquote></li></ul><ul><li>可以通过 document.activeElement 来获取当前所聚焦的元素。</li></ul><h5 id="事件：change，input，cut，copy，paste"><a href="#事件：change，input，cut，copy，paste" class="headerlink" title="事件：change，input，cut，copy，paste"></a>事件：change，input，cut，copy，paste</h5><ul><li><blockquote><p>当元素更改完成时，将触发 change 事件。</p><p>对于文本输入框，当其失去焦点时，就会触发 change 事件</p></blockquote></li><li><p>每当用户对输入值进行修改后，就会触发 input 事件。</p></li><li><blockquote><p>如果我们想要处理对 <input> 的每次更改，那么此事件是最佳选择。  </p><p><strong>无法阻止</strong> <code>oninput</code>事件 :当输入值更改后，就会触发 input 事件。我们无法使用 event.preventDefault() —— 已经太迟了，不会起任何作用了。</p></blockquote></li><li><p>剪切/拷贝/粘贴 : cut，copy，paste</p></li><li><blockquote><p>它们属于 ClipboardEvent 类，并提供了对拷贝/粘贴的数据的访问方法。我们也可以使用 event.preventDefault() 来中止行为，然后什么都不会被复制/粘贴</p></blockquote></li></ul><h5 id="表单：事件和方法提交"><a href="#表单：事件和方法提交" class="headerlink" title="表单：事件和方法提交"></a>表单：事件和方法提交</h5><ul><li><p>提交表单时，会触发 submit 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。</p></li><li><blockquote><p>form.submit() 方法允许从 JavaScript 启动表单发送。</p><p>我们可以动态地创建表单，使用该方法将其发送到服务器。</p><p>如果要手动将表单提交到服务器，我们可以调用 form.submit()。这样就不会产生 submit 事件</p></blockquote></li><li><p>提交表单主要有两种方式：</p></li><li><blockquote><ul><li><p>第一种 —— 点击 &lt; input type=”submit”&gt; 或 &lt; input type=”image”&gt;。</p></li><li><p>第二种 —— 在 input 字段中按下 Enter 键。</p></li></ul><ul><li>这两个行为都会触发表单的 submit 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用 event.preventDefault()，这样表单就不会被发送到服务器了。</li></ul></blockquote></li></ul><blockquote><p>在输入框中使用 Enter 发送表单时，会在 <input type="submit"> 上触发一次 click 事件</p></blockquote><h4 id="加载文档-和资源"><a href="#加载文档-和资源" class="headerlink" title="加载文档 和资源"></a>加载文档 和资源</h4><h5 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h5><ul><li><p>HTML 页面的生命周期包含三个重要事件：</p><pre><code>  DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 &lt;img&gt; 和样式表之类的外部资源可能尚未加载完成。  load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。  beforeunload/unload —— 当用户正在离开页面时。</code></pre></li><li><p>每个事件都是有用的：</p></li><li><blockquote><p>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。<br> load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。<br> beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。<br> unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</p></blockquote></li><li><p>**DOMContentLoaded **</p></li><li><p>DOMContentLoaded 事件发生在 document 对象上。我们必须使用 addEventListener 来捕获它,不能使用on<event></p></li></ul><ul><li>当浏览器处理一个 HTML 文档，并在文档中遇到 <script> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，<strong>所以 DOMContentLoaded 必须等待脚本执行结束。</strong></li></ul><ul><li><p><code>DOMContentLoaded</code> 不会等待样式表, 但是如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成, </p></li><li><blockquote><p>原因: 脚本可能想要获取元素的坐标和其他与样式相关的属性, 脚本等待样式表,<code>DOMContentLoaded</code> 等待脚本</p></blockquote></li></ul><ul><li><blockquote><p>例外 :</p><p>具有 async 特性（attribute）的脚本不会阻塞 DOMContentLoaded，稍后 我们会讲到。</p><p>使用 document.createElement(‘script’) 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded。</p></blockquote></li></ul><ul><li>Firefox，Chrome 和 Opera 都会在 <code>DOMContentLoaded</code> 中自动填充表单。</li></ul><ul><li><p><strong>load /unload/beforeunload事件</strong>:</p></li><li><p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件.</p></li><li><p>当访问者离开页面时，window 对象上的 unload 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。 发送分析数据。</p></li><li><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将要求进行更多确认。 如果我们要取消事件，浏览器会询问用户是否确定。</p></li><li><blockquote><p>window.onbeforeunload = function() {  return false; };</p></blockquote></li></ul><ul><li><p><strong>document.readyState 属性</strong>: 提供当前加载状态的信息。</p><pre><code>  loading —— 文档正在被加载。  interactive —— 文档被全部读取。  complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</code></pre></li><li><blockquote><p>还有一个 readystatechange 事件，会在状态发生改变时触发</p></blockquote></li></ul><h5 id="脚本：async，defer"><a href="#脚本：async，defer" class="headerlink" title="脚本：async，defer"></a>脚本：async，defer</h5><ul><li><p>当浏览器加载 HTML 时遇到 <script>...</script> 标签，浏览器就不能继续构建 DOM。对于外部脚本 <script src="..."></script> 也是一样的.</p></li><li><blockquote><p>这会导致两个重要的问题：</p><p>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</p><p>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容：</p></blockquote><p>解决方法: </p></li><li><blockquote><p>例如，我们可以把脚本放在页面底部, 但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。</p><p>对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p><p>使用 defer asynv解决</p></blockquote></li></ul><ul><li><p><strong>defer 和 async</strong></p></li><li><p>defer 特性告诉浏览器它应该继续处理页面，并“在后台”下载脚本，然后等页面加载完成后，再执行此脚本。</p></li><li><blockquote><p>具有 defer 特性的脚本不会阻塞页面, 等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。</p></blockquote></li><li><p>具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。 多个脚本下载时,并行下载,按顺序执行,如果我们有一个长脚本在前，一个短脚本在后，那么后者就会等待前者执行</p></li><li><p><strong>defer 特性仅适用于外部脚本</strong>, 如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>defer</code> 特性。</p></li></ul><ul><li><p><strong>async 特性意味着脚本是完全独立的</strong>：</p></li><li><blockquote><p>页面不会等待异步脚本，它会继续处理并显示页面内容。</p><p>DOMContentLoaded 和async异步脚本不会彼此等待：DOMContentLoaded可能会发生在异步脚本之前也可能在后面发生</p><p>其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本, 如果我们有几个 async 脚本，它们可能按任意次序执行。总之是先加载完成的就先执行</p></blockquote></li><li><p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p></li><li><p><strong>动态脚本</strong> : </p></li><li><blockquote><p>使用 JavaScript 动态地添加脚本：默认情况下，动态脚本的行为是“异步”的。</p><p>它们不会等待任何东西，也没有什么东西会等它们。  先加载完成的脚本先执行（“加载优先”顺序）。</p></blockquote></li><li><blockquote><p>我们可以通过将 async 特性显式地修改为 false，以将脚本的加载顺序更改为文档顺序（就像常规脚本一样）</p></blockquote></li></ul><h5 id="资源加载：onload，onerror"><a href="#资源加载：onload，onerror" class="headerlink" title="资源加载：onload，onerror"></a>资源加载：onload，onerror</h5><ul><li><p>浏览器通过load 和 error 事件,允许我们跟踪外部资源的加载  —— 脚本，iframe，图片等。基本上（basically）适用于具有外部 src 的任何资源。</p></li><li><blockquote><p>唯一的例外是 <iframe>：出于历史原因，不管加载成功还是失败，即使页面没有被找到，它都会触发 load 事件。</p></blockquote></li><li><p> onload —— 成功加载，     onerror —— 出现 error。</p></li><li><blockquote><p>我们需要加载第三方脚本时,使用 onload事件,在成功加载时执行,失败时执行 onerror</p></blockquote></li><li><blockquote><p>onload/onerror 事件仅跟踪加载本身。也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件。如果要跟踪脚本 error，可以使用 window.onerror 全局处理程序。</p></blockquote></li></ul><ul><li><p><strong>跨源策略</strong> : 这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。更确切地说，一个源（域/端口/协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。</p></li><li><p>如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。(如果想要获取到就必须允许跨源访问)</p></li><li><blockquote><p>对其他类型的资源也执行类似的跨源策略（CORS）。</p></blockquote></li></ul><ul><li><p>要允许跨源访问，<script> 标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">无 crossorigin 特性 —— 禁止访问。<br><br>crossorigin=<span class="hljs-string">&quot;anonymous&quot;</span> —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header Access-Control-Allow-Origin，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。<br><br>crossorigin=<span class="hljs-string">&quot;use-credentials&quot;</span> —— 如果服务器发送回带有我们的源的 header   <br>Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials: <span class="hljs-literal">true</span>，则允许访问浏览器会将授权信息和 cookie 发送到远程服务器。<br></code></pre></td></tr></table></figure></li></ul><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li><h5 id="DOM-变动观察器（Mutation-observer）"><a href="#DOM-变动观察器（Mutation-observer）" class="headerlink" title="DOM 变动观察器（Mutation observer）:"></a>DOM 变动观察器（Mutation observer）:</h5></li><li><blockquote><p> MutationObserver 是一个内建对象，它观察 DOM 元素，在其发生更改时触发回调。</p><p><code>MutationObserver</code> 可以对 DOM 的变化作出反应：特性（attribute），添加/删除的元素，文本内容。</p><p>我们可以用它来跟踪代码其他部分引入的更改，以及与第三方脚本集成</p></blockquote><p>语法: </p></li><li><blockquote><p>let observer = new MutationObserver(callback);  创建一个带有回调函数的观察器</p><p>observer.observe(node, config);   将其附加到一个 DOM 节点</p></blockquote></li><li><p>用于集成 : 你需要添加一个第三方脚本，该脚本不仅包含有用的功能，还会执行一些我们不想要的操作，例如显示广告 <div class="ads">Unwanted ads</div>。当然，第三方脚本没有提供删除它的机制。使用 MutationObserver，我们可以监测到我们不需要的元素何时出现在我们的 DOM 中，并将其删除</p></li><li><p>我们可以使用 <code>MutationObserver</code> 来自动检测何时在页面中插入了代码段，并高亮显示之它们</p></li></ul><h5 id="选择（Selection）和范围（Range）"><a href="#选择（Selection）和范围（Range）" class="headerlink" title="选择（Selection）和范围（Range）"></a>选择（Selection）和范围（Range）</h5><ul><li>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本,如果按下鼠标左键，并在不松开的情况下移动鼠标，这也常常会造成不必要的选择。有多种防止选择的方法.</li></ul><ul><li><p>Range 是用于管理选择范围的通用对象。我们可能会创建此类对象，并传递它们 —— 它们在视觉上不会自行选择任何内容。</p></li><li><blockquote><p>let range = new Range();</p></blockquote></li><li><p>range 对象具有以下属性：</p><pre><code>  startContainer，startOffset —— 起始节点和偏移量，  endContainer，endOffset —— 结束节点和偏移量，  collapsed —— 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 true，  commonAncestorContainer —— 在范围内的所有节点中最近的共同祖先节点，</code></pre></li></ul><ul><li><p>设置范围的起点：</p><pre><code>  setStart(node, offset) 将起点设置在：node 中的位置 offset  setStartBefore(node) 将起点设置在：node 前面  setStartAfter(node) 将起点设置在：node 后面  设置范围的终点（类似的方法）：  setEnd(node, offset) 将终点设置为：node 中的位置 offset  setEndBefore(node) 将终点设置为：node 前面  setEndAfter(node) 将终点设置为：node 后面  如前所述，node 既可以是文本节点，也可以是元素节点：对于文本节点，offset 偏移的是字符数，而对于元素节点则是子节点数。  其他：  selectNode(node) 设置范围以选择整个 node  selectNodeContents(node) 设置范围以选择整个 node 的内容          collapse(toStart) 如果 toStart=true 则设置 end=start，否则设置 start=end，从而折叠范围  cloneRange() 创建一个具有相同起点/终点的新范围  如要操纵范围内的内容：  deleteContents() —— 从文档中删除范围内容  extractContents() —— 从文档中删除范围内容，并将删除的内容作为 DocumentFragment 返回  cloneContents() —— 复制范围内容，并将复制的内容作为 DocumentFragment 返回  insertNode(node) —— 在范围的起始处将 node 插入文档  surroundContents(node) —— 使用 node 将所选范围内容包裹起来。要使此操作有效，则该范围必须包含其中所有元素的开始和结束标签：不能像 &lt;i&gt;abc 这样的部分范围。</code></pre></li></ul><ul><li><p>文档选择是由 Selection 对象表示的，可通过 window.getSelection() 或 document.getSelection() 来获取。</p></li><li><p>选择属性 :</p><pre><code>  anchorNode —— 选择的起始节点，  anchorOffset —— 选择开始的 anchorNode 中的偏移量，  focusNode —— 选择的结束节点，  focusOffset —— 选择开始处 focusNode 的偏移量，  isCollapsed —— 如果未选择任何内容（空范围）或不存在，则为 true 。  rangeCount —— 选择中的范围数，除 Firefox 外，其他浏览器最多为 1。</code></pre></li><li><p>在文档中，选择的终点可能在起点之前</p></li><li><p>选择获取 : </p><pre><code>  作为文本：只需调用 document.getSelection().toString()。  作为 DOM 节点：获取底层的（underlying）范围，并调用它们的 cloneContents() 方法（如果我们不支持  Firefox 多选的话，则仅取第一个范围）。</code></pre></li><li><p>选择事件 : 有一些事件可以跟踪选择：</p><pre><code>  elem.onselectstart —— 当选择从 elem 上开始时，例如，用户按下鼠标键并开始移动鼠标。  阻止默认行为会使选择无法开始。  document.onselectionchange —— 当选择变动时。  请注意：此处理程序只能在 document 上设置。</code></pre></li><li><p>选择方法 :</p><pre><code>  getRangeAt(i) —— 获取从 0 开始的第 i 个范围。在除 Firefox 之外的所有浏览器中，仅使用 0。  addRange(range) —— 将 range 添加到选择中。如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用。  removeRange(range) —— 从选择中删除 range。  removeAllRanges() —— 删除所有范围。  empty() —— removeAllRanges 的别名。  外，还有一些方便的方法可以直接操作选择范围，而无需使用 Range：  collapse(node, offset) —— 用一个新的范围替换选定的范围，该新范围从给定的 node 处开始，到偏移    offset 处结束。  setPosition(node, offset) —— collapse 的别名。  collapseToStart() —— 折叠（替换为空范围）到选择起点，  collapseToEnd() —— 折叠到选择终点，  extend(node, offset) —— 将选择的焦点（focus）移到给定的 node，位置偏移 oofset，  setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) —— 用给定的起点      anchorNode/anchorOffset 和终点 focusNode/focusOffset 来替换选择范围。选中它们之间的所有内容。  selectAllChildren(node) —— 选择 node 的所有子节点。  deleteFromDocument() —— 从文档中删除所选择的内容。  containsNode(node, allowPartialContainment = false) —— 检查选择中是否包含 node（特别是如果第二个参数是 true 的话）</code></pre></li></ul><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection">https://developer.mozilla.org/zh-CN/docs/Web/API/Selection</a></p></li><li><p>对于许多任务，我们可以调用 Selection 方法，而无需访问底层的（underlying）Range 对象。</p></li><li><p>如要选择，请先移除现有的选择<br>如果选择已存在，则首先使用 removeAllRanges() 将其清空。然后添加范围。否则，除 Firefox 外的所有浏览器都将忽略新范围。</p></li><li><p>表单控件中的选择 :</p></li><li><p>诸如 input 和 textarea 等表单元素提供了 专用的选择 API，没有 Selection 或 Range 对象。由于输入值是纯文本而不是 HTML，因此不需要此类对象，一切都变得更加简单。</p><pre><code>  input.selectionStart —— 选择的起始位置（可写），  input.selectionEnd —— 选择的结束位置（可写），  input.selectionDirection —— 选择方向，其中之一：“forward”，“backward” 或 “none”（例如使用鼠标双击进行的选择），  事件：  input.onselect —— 当某个东西被选择时触发。  方法：  input.select() —— 选择文本控件中的所有内容（可以是 textarea 而不是 input），  input.setSelectionRange(start, end, [direction]) —— 在给定方向上（可选），从 start 一直选择到 end。  input.setRangeText(replacement, [start], [end], [selectionMode]) —— 用新文本替换范围中的文本。  可选参数 start 和 end，如果提供的话，则设置范围的起点和终点，否则使用用户的选择。  最后一个参数 selectionMode 决定替换文本后如何设置选择。可能的值为：  &quot;select&quot; —— 将选择新插入的文本。  &quot;start&quot; —— 选择范围将在插入的文本之前折叠（光标将在其之前）。  &quot;end&quot; —— 选择范围将在插入的文本之后折叠（光标将紧随其后）。  &quot;preserve&quot; —— 尝试保留选择。这是默认值。</code></pre></li><li><blockquote><p>onselect 是在某项被选择时触发，而在选择被删除时不触发。根据 规范，发表单控件内的选择不应该触发 document.onselectionchange 事件，因为它与 document 选择和范围不相关。一些浏览器会生成它，但我们不应该依赖它。</p></blockquote></li></ul><ul><li><p>要使某些内容不可选，有三种方式：</p></li><li><blockquote><p>使用 CSS 属性 user-select: none。</p><p>防止 onselectstart 或 mousedown 事件中的默认行为。 这样可以防止在 elem 上开始选择，但是访问者可以在另一个元素上开始选择，然后扩展到 elem。</p><p>我们还可以使用 document.getSelection().empty() 来在选择发生后清除选择。很少使用这种方法，因为这会在选择项消失时导致不必要的闪烁。</p></blockquote></li></ul><ul><li>关于光标。在诸如 <textarea> 之类的可编辑元素中，光标的位置始终位于选择的起点或终点。我们可以通过设置 elem.selectionStart 和 elem.selectionEnd 来获取光标位置或移动光标。</li></ul><h5 id="事件循环-微任务-宏任务"><a href="#事件循环-微任务-宏任务" class="headerlink" title="事件循环  微任务 宏任务"></a>事件循环  微任务 宏任务</h5><ul><li><p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。</p></li><li><p>事件循环的概念:  </p></li><li><blockquote><p>它是一个在 JavaScript 引擎等待任务，<strong>执行任务</strong> 和 <strong>进入休眠状态</strong>  <strong>等待更多任务</strong>  这几个状态之间转换的无限循环。</p></blockquote></li><li><p>多个任务组成了一个队列，即所谓的“宏任务队列”</p></li><li><blockquote><p>队列中的任务基于“先进先出”的原则执行</p><p>引擎执行任务时永远不会进行渲染（render）,仅在任务完成后才会绘制对 DOM 的更改。</p><p>如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，无法处理用户事件，因此，在一定时间后浏览器会在整个页面抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</p></blockquote><p><strong>微任务:</strong></p></li><li><p>微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。</p></li><li><p>还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行。</p></li><li><blockquote><p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</p></blockquote></li></ul><ul><li><p>安排（schedule）一个新的 宏任务：用零延迟的 setTimeout(f)。</p></li><li><p>安排一个新的 微任务：使用 queueMicrotask(f)。 promise 处理程序也会通过微任务队列。</p></li><li><blockquote><p>在微任务之间没有 UI 或网络事件的处理：微任务之间它们一个立即接一个地执行。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/14/Js-dom/BOM%20Cookie%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
    <url>/2020/12/14/Js-dom/BOM%20Cookie%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="BOM-—window对象"><a href="#BOM-—window对象" class="headerlink" title="BOM —window对象"></a>BOM —window对象</h3><ul><li><p>一个浏览器窗口就是一个window对象</p></li><li><p>window对象有多个子对象</p></li><li><blockquote><ul><li>document 操作页面元素</li><li>location 地址对象,</li><li>navigator 用于获取浏览器版本信息 </li><li>history 历史对象操作浏览记录</li><li>screen 操作屏幕宽度高度  </li></ul></blockquote></li><li><blockquote><p>​    以上都是window 的属性, 返回一个对象 , 可以不用window前缀</p></blockquote></li><li><p>由于windwo对象下面的子对象都是操作浏览器窗口,所以我们称为BOM</p></li></ul><ul><li><p>location对象 属性: </p></li><li><blockquote><p> href 当前页面地址  </p><p>search 当前地址?后内容</p><p> hash 当前页面地址#后面的内容  </p><p>pathname</p><p>location.assign() 方法加载新的文档。</p></blockquote></li><li><p>history 属性:</p></li><li><blockquote><p>history.forward() - 与在浏览器中点击向前按钮相同</p><p>history.back() - 与在浏览器点击后退按钮相同</p></blockquote></li></ul><ul><li><blockquote><p>screen.availWidth - 可用的屏幕宽度</p><p>screen.availHeight - 可用的屏幕高度</p></blockquote></li></ul><ul><li><p><strong>弹窗</strong></p></li><li><blockquote><p>window.open(‘<a href="https://javascript.info/&#39;">https://javascript.info/&#39;</a>) : 打开一个具有给定 URL 的新窗口。大多数现代浏览器都配置为打开新选项卡</p><p>现在大多数浏览器都会通过阻止弹窗来保护用户。所以使用open() 会被拦截弹窗</p></blockquote></li><li><blockquote><p>弹窗是一个独立的窗口，具有自己的独立 JavaScript 环境。因此，使用弹窗打开一个不信任的第三方网站是安全的。</p></blockquote></li><li><blockquote><p><code>window.open(url, name, params) </code>   调用会返回对新窗口的引用。它可以用来操纵弹窗的属性，更改位置，甚至更多操作</p><p>name : 新窗口的名称, 每个窗口都有一个 <code>window.name</code></p><p>params : 新窗口的配置字符串。它包括设置，用逗号分隔。参数之间不能有空格，例如：<code>width:200,height=100</code>。</p><p><code>params</code> 的设置项：</p><ul><li>位置:<ul><li><code>left/top</code>（数字）—— 屏幕上窗口的左上角的坐标。这有一个限制：不能将新窗口置于屏幕外（offscreen）。</li><li><code>width/height</code>（数字）—— 新窗口的宽度和高度。宽度/高度的最小值是有限制的，因此不可能创建一个不可见的窗口。</li></ul></li><li>窗口功能：<ul><li><code>menubar</code>（yes/no）—— 显示或隐藏新窗口的浏览器菜单。</li><li><code>toolbar</code>（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。</li><li><code>location</code>（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。</li><li><code>status</code>（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。</li><li><code>resizable</code>（yes/no）—— 允许禁用新窗口大小调整。不建议使用。</li><li><code>scrollbars</code>（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</li></ul></li></ul></blockquote></li><li><p>从窗口访问弹窗 , 也可以从弹窗访问窗口</p></li><li><p>关闭窗口: <code>win.close()</code>。检查一个窗口是否被关闭：<code>win.closed</code></p></li><li><blockquote><p>如果 <code>window</code> 不是通过 <code>window.open()</code> 创建的，那么大多数浏览器都会忽略 <code>window.close()</code>。因此，<code>close()</code> 只对弹窗起作用。</p></blockquote></li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ul><li><p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分</p></li><li><blockquote><p>当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a> 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a> 请求头部将 Cookie 信息发送给服务器。</p></blockquote></li></ul><ul><li><p>使用 <code>document.cookie</code> 属性从浏览器访问 cookie</p></li><li><blockquote><p>写入 <code>document.cookie</code>。但这不是一个数据属性，它是一个访问器（getter/setter）</p><p><strong>对 <code>document.cookie</code> 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie。</strong></p><p>document.cookie = “user=John”; // 只会更新名称为 user 的 cookie</p></blockquote></li><li><p>cookie 的名称和值可以是任何字符，为了保持有效的格式，它们应该使用内建的 <code>encodeURIComponent</code> 函数对其进行转义</p></li><li><blockquote><pre><code class="javascript">let name = &quot;my name&quot;; let value = &quot;John Smith&quot; // 将 cookie 编码为 my%20name=John%20Smith document.cookie = encodeURIComponent(name) + &#39;=&#39; + encodeURIComponent(value);</code></pre></blockquote></li><li><p>Cookie属性:</p></li><li><blockquote><ul><li><p><strong><code>path=/mypath</code></strong> 我们应该将 <code>path</code> 设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</p></li><li><p>**<code>domain=site.com</code>**默认情况下，cookie 只有在设置的域下才能被访问到,</p><blockquote><p> 但是棘手的是，我们在子域 <code>forum.site.com</code> 下也无法获取它！如果我们想要批准像 <code>forum.site.com</code> 这样的子域访问 cookie，将 <code>domain</code> 选项显式地设置为根域：<code>domain=site.com</code></p><p>document.cookie = “user=John; domain=site.com”</p></blockquote></li></ul></blockquote></li><li><blockquote><ul><li><p>expires，max-age</p></li><li><blockquote><p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 “session cookie”。</p><p>为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 <code>expires</code> 或 <code>max-age</code> 选项中的一个。</p><ul><li><strong><code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code></strong></li><li>日期必须完全采用 GMT 时区的这种格式。我们可以使用 <code>date.toUTCString</code> 来获取它</li></ul></blockquote></li><li><blockquote><p><strong><code>max-age=3600</code></strong></p><p><code>expires</code> 的替代选项，具指明 cookie 的过期时间距离当前时间的秒数。</p><p>// cookie 会在一小时后失效 </p><p>document.cookie = “user=John; max-age=3600”;</p></blockquote></li><li><p><strong><code>secure</code></strong></p></li><li><blockquote><p>Cookie 应只能被通过 HTTPS 传输。</p><p><strong>默认情况下，如果我们在 <code>http://site.com</code> 上设置了 cookie，那么该 cookie 也会出现在 <code>https://site.com</code> 上，反之亦然。</strong></p><p>也就是说，cookie 是基于域的，它们不区分协议。</p></blockquote></li><li><p> cookie samesite 选项</p></li><li><blockquote><p>Cookie 的 <code>samesite</code> 选项提供了另一种防止此类攻击的方式，跨网站请求伪造（Cross-Site Request Forgery，简称 XSRF）攻击</p><ul><li><p><strong><code>samesite=strict</code>（和没有值的 <code>samesite</code> 一样)</strong></p></li><li><p><strong><code>samesite=lax</code></strong></p></li><li><blockquote><p><code>samesite</code> 会被到 2017 年左右的旧版本浏览器忽略（不兼容</p></blockquote></li></ul></blockquote></li></ul></blockquote></li></ul><ul><li>有关 cookie 操作的函数，比手动修改 <code>document.cookie</code> 方便得多。有很多这种 cookie 库，</li></ul><h4 id="LocalStorage，sessionStorage"><a href="#LocalStorage，sessionStorage" class="headerlink" title="LocalStorage，sessionStorage"></a>LocalStorage，sessionStorage</h4><ul><li>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。<br>在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。</li></ul><ul><li><p>我们已经有了 cookie。为什么还要其他存储对象呢？</p></li><li><blockquote><p>与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。(节省开销)</p><p>还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。</p><p>存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。</p></blockquote></li><li></li><li><p>两个存储对象都提供相同的方法和属性：</p></li><li><blockquote><ul><li><code>setItem(key, value)</code> —— 存储键/值对。</li><li><code>getItem(key)</code> —— 按照键获取值。</li><li><code>removeItem(key)</code> —— 删除键及其对应的值。</li><li><code>clear()</code> —— 删除所有数据。</li><li><code>key(index)</code> —— 获取该索引下的键名。</li><li><code>length</code> —— 存储的内容的长度。</li></ul></blockquote></li><li><p><code>localStorage</code> 最主要的特点是：</p></li><li><blockquote><ul><li>在同源的所有标签页和窗口之间共享数据。</li><li>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</li></ul></blockquote></li><li><blockquote><p>我们还可以像使用一个普通对象那样，读取/设置键,这是历史原因造成的，并且大多数情况下都可行，但通常不建议这样做: 用户保存的数据可能是关键字, 读取出来之后导致错误</p></blockquote></li><li><blockquote><p><code>Object.keys</code> 只返回属于对象的键，会忽略原型上的。可以配合他进行键值迭代</p></blockquote></li></ul><ul><li><p>键和值都必须是字符串, 如果是任何其他类型，例数字或对象，它会被自动转换为字符串</p></li><li><blockquote><p>我们可以使用 <code>JSON</code> 来存储对象,使用JSON.srtingify,转换为字符串,使用时再换出来</p></blockquote></li></ul><p><strong>sessionStorage:</strong></p><ul><li><p><code>sessionStorage</code> 对象的使用频率比 <code>localStorage</code> 对象低得多。</p><p>属性和方法是相同的，但是它有更多的限制：</p><blockquote><ul><li><p>数据只存在于当前浏览器标签页。具有相同页面的另一个标签页中将会有不同的存储。</p><p>但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。</p></li><li><p>数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。</p></li></ul></blockquote></li><li><p>当 <code>localStorage</code> 或 <code>sessionStorage</code> 中的数据更新后，<a href="https://www.w3.org/TR/webstorage/#the-storage-event">storage</a> 事件就会触发，它具有以下属性：</p></li><li><blockquote><ul><li><p><code>key</code> —— 发生更改的数据的 <code>key</code>（如果调用的是 <code>.clear()</code> 方法，则为 <code>null</code>）。</p></li><li><p><code>oldValue</code> —— 旧值（如果是新增数据，则为 <code>null</code>）。</p></li><li><p><code>newValue</code> —— 新值（如果是删除数据，则为 <code>null</code>）。</p></li><li><p><code>url</code> —— 发生数据更新的文档的 url。</p></li><li><p><code>storageArea</code> —— 发生数据更新的 <code>localStorage</code> 或 <code>sessionStorage</code> 对象。</p></li></ul></blockquote></li></ul><ul><li><blockquote><p>  重要的是：该事件会在所有可访问到存储对象的 <code>window</code> 对象上触发</p><p>  如果两个窗口都在监听 <code>window.onstorage</code> 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应</p></blockquote></li></ul><h4 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB:"></a><strong>indexDB:</strong></h4><ul><li><p>IndexedDB 是一个浏览器内置的数据库，它比 <code>localStorage</code> 强大得多。</p></li><li><blockquote><p>通过支持多种类型的键，来存储几乎可以是任何类型的值。<br> 支撑事务的可靠性。<br> 支持键范围查询、索引。<br> 和 <code>localStorage</code> 相比，它可以存储更大的数据量。</p></blockquote><ul><li><blockquote><p>对于传统的 客户端-服务器 应用，这些功能通常是没有必要的。IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用。</p></blockquote></li></ul></li><li><blockquote><p>基本操作就是, 根据监听事件,对数据库进行增删改查, 就像操作数据库一样, 所以传统的客户端-服务器 应用,用不到</p></blockquote></li></ul><ul><li><p>语法: </p></li><li><blockquote><p>let openRequest = indexedDB.open(name, version);</p><ul><li><code>name</code> —— 字符串，即数据库名称。</li><li><code>version</code> —— 一个正整数版本，默认为 <code>1</code>（下面解释）。</li></ul></blockquote></li><li><p>调用之后会返回 <code>openRequest</code> 对象，我们需要监听该对象上的事件：</p></li><li><blockquote><ul><li><code>success</code>：数据库准备就绪，<code>openRequest.result</code> 中有了一个数据库对象“Database Object”，使用它进行进一步的调用。</li><li><code>error</code>：打开失败。</li><li><code>upgradeneeded</code>：数据库已准备就绪，但其版本已过时（见下文）。</li></ul></blockquote></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BOM</tag>
      
      <tag>Cookie</tag>
      
      <tag>浏览器存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html5基础</title>
    <link href="/2020/12/14/Html/html5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2020/12/14/Html/html5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h5 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h5><ul><li><p>video audio属性</p><p>  controls : 为网页中的音频显示标准的HTML5控制器。<br>  autoplay : 使音频自动播放。<br>  loop : 使音频自动重复播放。<br>  muted  这个属性会导致媒体播放时，默认关闭声音。<br>  poster:这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。<br>  preload 这个属性被用来缓冲较大的文件</p></li><li><p>可以用 &lt; source&gt; 标签来指定多个文件，以为不同浏览器提供可支持的编码格式</p></li><li><p>&lt; audio&gt; 标签与 &lt; video&gt; 标签的使用方式几乎完全相同 &lt; audio&gt; 上式使用方式几乎一样，不支持宽高设置 同时也不支持poster属性</p></li><li><p>播放控制: 当你已经用新的元素将媒体嵌入 HTML 文档以后，你就可以用 JavaScript 代码 采用编程的方式来控制它们。  方法在实现媒体元素的接口中定义 常用的有 play() pause()….</p></li><li><p>停止媒体播放很简单，只要调用 pause() 方法即可，然而浏览器还会继续下载媒体直至媒体元素被垃圾回收机制回收。通过移除媒体元素的 src 属性（或者直接将其设为一个空字符串——这取决于具体浏览器）， 你可以摧毁该元素的内部解码，从而结束媒体下载</p></li><li><p>媒体元素支持在媒体的内容中从当前播放位置移到某个特定点。 这是通过设置元素的属性currentTime的值来达成的；有关元素属性的详细信息请看HTMLMediaElement</p></li></ul><ul><li><p>&lt; video&gt; 标签不被支持时可以使用Flash播放Flash格式的影像。video 内嵌 object param标签</p></li><li><p>错误处理: 最后一个source元素上增加一个错误处理器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;dynamicsearch.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;dynamicsearch.mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;dynamicsearch.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Dynamic app search in Firefox OS&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Click image to play a video demo of dynamic app search<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>给那些听不懂音频语言的人们提供一个音频内容岂不是一件很棒的事情吗？所以，感谢 HTML5&lt; video&gt;使之成为可能，有了WebVTT格式，你可以使用&lt; track&gt;标签。</p></li></ul><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><ul><li>SVG 是用于描述矢量图像的XML语言。 它基本上是像HTML一样的标记，只是你有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。</li><li>引用svg   要通过 <img>元素嵌入SVG，你只需要按照预期的方式在 src 属性中引用它 缺点是无法通过js css操作图像</li><li>直接引用svg代码块<h4 id="区块-段落元素"><a href="#区块-段落元素" class="headerlink" title="区块 段落元素"></a>区块 段落元素</h4></li><li>header article ..  这些区块标签在实际开发中很少用,主要功能是对文档内容进行分块<h4 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a>MathML</h4></li><li>是一组标签,可以再内容中直接嵌入复杂的数学公式(有工作需要才学习)  <h4 id="cavans"><a href="#cavans" class="headerlink" title="cavans"></a>cavans</h4></li></ul><hr><p> 以下内容作为h5前端不太有联系, 以下主要就是些API学习实现各个功能,和JsDOM  后端关系更大<br> 下列内容的学习放在后端学习/ JSDOM<br>** (具体参考现代 javascript教程文档) **</p><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><ul><li> localStorage   sessionStorage  indexedDB<h4 id="设备-移动-访问"><a href="#设备-移动-访问" class="headerlink" title="设备(移动)访问"></a>设备(移动)访问</h4></li><li>定位 检测方向 触控事件 使用摄像机 指针锁定<h4 id="通信-属于后端接触范围-和网络还有关系-前端暂时不需要"><a href="#通信-属于后端接触范围-和网络还有关系-前端暂时不需要" class="headerlink" title="通信 (属于后端接触范围 和网络还有关系 前端暂时不需要)"></a>通信 (属于后端接触范围 和网络还有关系 前端暂时不需要)</h4></li><li> WebSockets 是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此API，您可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。<h4 id="拖放api-History-API-全屏api"><a href="#拖放api-History-API-全屏api" class="headerlink" title="拖放api  History API  全屏api"></a>拖放api  History API  全屏api</h4></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html表单</title>
    <link href="/2020/12/14/Html/HTML5%E8%A1%A8%E5%8D%95/"/>
    <url>/2020/12/14/Html/HTML5%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="html5-表单"><a href="#html5-表单" class="headerlink" title="html5  表单"></a>html5  表单</h3><h5 id="原生表单部件"><a href="#原生表单部件" class="headerlink" title="原生表单部件"></a>原生表单部件</h5><ul><li><p>表单标签 </p><p>  &lt; form name method action &gt;<br>  &lt; input type =”” 多个type&gt;<br>  &lt; label&gt;<br>  &lt; select：选择列表&gt;<br>  &lt; input type=”image”：创建图形按钮 &gt;<br>  &lt; button type  &gt;<br>  &lt; textarea&gt; </p></li><li><p>表单组件通用属性：<br>  name        元素的名称;这是跟表单数据一起提交的。<br>  value        元素的初始值。<br>  autofocus    (false)    这个布尔属性允许您指定当页面加载时元素应该自动具有输入焦点,文档中只有一个与表单相关的元素可以指定这个属性。<br>  disabled    这个布尔属性表示用户不能与元素交互</p></li><li><p>所有输入用的文本框都有一些通用规范:<br>  readonly:用户不能修改输入值<br>  disabled：输入值永远不会与表单数据的其余部分一起发送<br>  placeholder:提供输入提示信息<br>  formaction:制定后台处理软件<br>  autofocus ：自动获得焦点<br>  pattern：验证输入元素，验证输入格式。。<br>  requid:非空检测    multiple属性添加到&lt; select&gt;元素，可以允许选择几个值<br>  它们可以被限制在size (框的物理尺寸) 和 长度 (可以输入的最大字符数)。</p></li></ul><h5 id="各个表单部件之间注意点"><a href="#各个表单部件之间注意点" class="headerlink" title="各个表单部件之间注意点"></a>各个表单部件之间注意点</h5><h6 id="input-button-textarea-注意点"><a href="#input-button-textarea-注意点" class="headerlink" title="input  button textarea 注意点"></a>input  button textarea 注意点</h6><ul><li>要定义&lt; input&gt;的默认值，你必须使用value 属性,如果您想定义&lt; textarea&gt;的默认值，您只需在&lt; textarea&gt;元素的开始和结束标记之间放置默认值</li><li>注意，&lt; textarea&gt;元素与&lt; input&gt;元素的编写略有不同。&lt; input&gt;元素是一个空元素，这意味着它不能包含任何子元素。&lt; textarea&gt;元素可以包含文本内容的子元素。&lt; textarea&gt;元素只接受文本内容；这意味着将任何HTML内容放入&lt; textarea&gt;中都呈现为纯文本内容。</li></ul><ul><li>&lt; button&gt;元素也接受一个 type属性，它接受submit, reset或者 button 三个值中的任一个</li><li>使用&lt; button&gt;元素或&lt; input&gt;元素定义的按钮几乎没有区别。唯一值得注意的区别是按钮本身的标签。在&lt; input&gt;元素中，标签只能是字符数据，而在&lt; button&gt;元素中，标签可以是HTML(br strong)，因此可以相应地进行样式化。</li></ul><p>-对于checkbox  通过name属性识别此复选框,value属性是被后台获取的值,不指定value结果为默认”on” ,复选框单选框都需要拥有value属性</p><blockquote><p>HTML表单文本字段是简单的纯文本输入控件(input)。 这意味着您不能使用它们执行富文本编辑(粗体、斜体等)。你遇到的所有富文本编辑器（rich text editors）都是使用HTML、CSS和JavaScript所创建的自定义小部件<br>我们还需要为我们的数据提供一个名称, 要将数据命名为表单，您需要在每个表单小部件上使用 name 属性来收集特定的数据块。<br>严格禁止在一个表单内嵌套另一个表单 </p></blockquote><ul><li><p>表单结构的常用做法</p></li><li><blockquote><p>用&lt; div&gt;元素包装标签和它的小部件是很常见的做法。&lt; p&gt;元素也经常被使用，HTML列表 ul也是如此（后者在构造多个复选框或单选按钮时最为常见） 除了&lt; fieldset&gt;元素之外，使用HTML标题（例如，&lt; h1&gt;、 &lt; h2&gt;）和分段（如&lt; section&gt;）来构造一个复杂的表单也是一种常见的做法。</p></blockquote></li><li><p>通过包括multiple属性，它还可以让用户将多个电子邮件地址输入相同的输入(以逗号分隔)。</p></li><li><blockquote><p>&lt; input type=”email” id=”email” name=”email” multiple&gt;</p></blockquote></li></ul><h6 id="选择表单-注意点"><a href="#选择表单-注意点" class="headerlink" title="选择表单 注意点"></a>选择表单 注意点</h6><ul><li>如果一个&lt; option&gt;元素设置了value属性，那么当提交表单时该属性的值就会被发送。如果忽略了value属性，则使用&lt; option&gt;元素的内容作为选择框的值。</li><li>select框中 在&lt; optgroup &gt;元素中，label属性(和label元素不是一个)显示在值之前，但即使它看起来有点像一个选项，它也不是可选的。<br>作系统提供的默认机制来选择几个值。 (如， 同时按下 Cmd/Ctrl 并点击多个值).</li></ul><ul><li>您可以使用&lt; datalist&gt;元素来为表单小部件提供建议的、自动完成的值(自动补全框)，并使用一些&lt; option&gt;子元素来指定要显示的值。 然后使用list属性将数据列表绑定到一个文本框(通常是一个 &lt; input&gt; 元素)。 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;myFruit&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myFruit&quot;</span> <span class="hljs-attribute">list</span>=<span class="hljs-string">&quot;mySuggestion&quot;</span>&gt;<br>&lt;datalist <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;mySuggestion&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><ul><li>几个单选按钮可以连接在一起。如果它们的name属性共享相同的值，那么它们将被认为属于同一组的按钮。同一组中只有一个按钮可以同时被选；这意味着当其中一个被选中时，所有其他的都将自动未选中。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，并且没有以表单的形式发送任何值。<blockquote><p>单选项  复选项 复选框和单选按钮。两者都使用checked属性，以指示该部件的默认状态: “选中”或”未选中”。,值得注意的是，这些小部件与其他表单小部件不一样。对于大多数表单部件，一旦表单提交，所有具有name属性的小部件都会被发送，即使没有任何值被填。对于可选中项，只有在勾选时才发送它们的值。如果他们没有被勾选，就不会发送任何东西，甚至连他们的名字也没有。</p></blockquote></li></ul><blockquote><p>默认情况下，选择框只允许用户选择一个值。通过将multiple属性添加到&lt; select&gt;元素，您可以允许用户通过操</p></blockquote><h5 id="高级表单部件"><a href="#高级表单部件" class="headerlink" title="高级表单部件"></a>高级表单部件</h5><ol><li><p>数字 type=number</p><blockquote><p>通过设置min和max属性来约束该值。<br>通过设置step属性来指定增加和减少按钮更改小部件的步进值大小。</p></blockquote></li><li><p>滑块 type=range 正确配置滑块是很重要的；为了达到这个目的，我们强烈建议您设置min、max和step属性。</p></li><li><p>拾色器  &lt; input type=”color” name=”color” id=”color”&gt;</p></li><li><p>文件选择器小部件，您可以使用&lt; input&gt;元素，将它的type属性设置为file。被接受的文件类型可以使用accept属性来约束。此外，如果您想让用户选择多个文件，那么可以通过添加multiple属性来实现。</p></li></ol><blockquote><p>有时候，由于为了方便技术原因，有些数据是用表单发送的，但不显示给用户。要做到这一点，您可以在表单中添加一个不可见的元素。要做到这一点，需要使用&lt; input&gt;将它的type属性设置为hidden值。如果您创建了这样一个元素，就需要设置它的name和value属性：</p></blockquote><ul><li>&lt; input type=”file” id=”input”&gt; 上传组件, 你不能使用 input.value 来获取该文件路径,由于浏览器安全问题,路径会被修改, 使用window.URL.createObjectURL() 来获取路径, 如果是使用文件,通过files属性返回选择的一个/多个文件, 返回值是包含file对象的类数组.</li></ul><ol><li>图像按钮是使用type属性值设置为image&lt; input&gt;的元素创建的。这个元素支持与&lt; img&gt;元素相同的属性，和其他表单按钮支持的所有属性。如果使用图像按钮来提交表单，这个小部件不会提交它的值；相反，提交的是在图像上单击处的X和Y坐标(坐标是相对于图像的，这意味着图像的左上角表示坐标0，0)，坐标被发送为两个键/值对：</li></ol><p>6.进度条 使用&lt; progress&gt;元素创建的。</p><ul><li><blockquote><p> &lt; progress max=”100” value=”75”&gt;75/100&lt;/ progress&gt;</p></blockquote></li></ul><p>7.仪表</p><ul><li><blockquote><p>&lt; meter min=”0” max=”100” value=”75” low=”33” high=”66” optimum=”50”&gt;75&lt;/ meter&gt;</p></blockquote></li></ul><blockquote><p>警告——日期和时间窗口小部件仍然很不受支持。目前，Chrome、Edge和Opera都支持它们，但IE浏览器没有支持，Firefox和Safari对这些都没有太大的支持。</p></blockquote><h4 id="表单数据效验"><a href="#表单数据效验" class="headerlink" title="表单数据效验"></a>表单数据效验</h4><ul><li>分为客户端效验 服务器效验两种<h5 id="效验方式"><a href="#效验方式" class="headerlink" title="效验方式"></a>效验方式</h5></li></ul><ol><li><p>html5内置的效验属性</p><ol><li>required </li><li>pattern 属性 (属性内书写正则表达式)</li><li>所有文本框 (&lt; input&gt; 或 &lt; textarea&gt;) 都可以使用minlength 和 maxlength 属性来限制长度 在数字条目中 (&lt; input type=”number”&gt;), 该 min 和 max 属性同样提供校验约束</li></ol></li></ol><ul><li><blockquote><p>该元素将可以通过 CSS 伪类 :valid 进行特殊的样式化；如果一个元素未校验通过：该元素将可以通过 CSS 伪类 :invalid 进行特殊的样式化；</p></blockquote></li></ul><ol start="2"><li>使用Js 效验表单</li></ol><ul><li>越来越多的浏览器支持限制校验API，并且这逐渐变得可靠。这些 API 由成组的方法和属性构成，可在特定的表单元素接口上调用：</li><li><blockquote><p>HTMLButtonElement  HTMLFieldSetElement  HTMLInputElement…</p></blockquote></li><li>约束校验的 API 及属性  validity</li></ul><blockquote><p>也可以不使用js的API 属性,通过原生js实现建立自己的校验系统并不难。 困难的部分是使其足够通用，以跨平台和任何形式使用它可以创建。 有许多库可用于执行表单校验; 你应该毫不犹豫地使用它们。 这里有一些例子：独立的库（原生 Javascript 实现）：Validate.js    jQuery 插件:Validation  Valid8</p></blockquote><h5 id="自定义错误信息-远程效验"><a href="#自定义错误信息-远程效验" class="headerlink" title="自定义错误信息  远程效验"></a>自定义错误信息  远程效验</h5><ul><li>每次我们提交无效的表单数据时, 浏览器总会显示错误信息. 但是显示的信息取决于你所使用的浏览器.</li><li>HTML5 提供 constraint validation API (指的就是js 调用的验证API 属性 方法)来检测和自定义表单元素的状态. 除此之外,他可以改变错误信息的文本.<blockquote><p>关于自定义问题观看 表单数据效验–MDN</p></blockquote></li></ul><ul><li>远程校验 : 一个应用实例就是注册表单，在这里你需要一个用户名。 为了避免重复，执行一个 AJAX 请求来检查用户名的可用性，要比让先用户发送数据，然后因为表单重复了返回错误信息要好得多。<blockquote><p>两个条件:需要确保它不是敏感数据。网络滞后需要执行异步校验。确保如校验没有适当的执行，用户还能继续操作</p></blockquote></li></ul><h4 id="Css样式化表单"><a href="#Css样式化表单" class="headerlink" title="Css样式化表单"></a>Css样式化表单</h4><ul><li><p>有些元素根本不能用应用CSS样式。 这些包括：所有高级用户界面小部件，如范围，颜色或日期控件; 和所有下拉小部件，包括&lt; select&gt;, &lt; option&gt;, &lt; optgroup&gt;和&lt; datalist&gt; 元素。 文件选择器小部件也被称为不可样式化。 新的&lt; progress&gt;和&lt; meter&gt; 元素也属于这个类别</p></li><li><p>搜索框是唯一一种应用CSS样式有点棘手的文本字段。 在基于WebKit的浏览器（Chrome，Safari等）上，您必须使用-webkit-appearance专有属性来调整它</p></li><li><p>如果你想保持组件的原生观感，又想给它们一致的大小，你会面临一些困难)。这是因为每个小部件都有自己的边框，填充和边距的规则。 所以如果你想给几个不同的小部件相同的大小，你必须使用box-sizing 属性：</p></li><li><p>默认情况下，所有浏览器都认为&lt; textarea&gt; 元素是inline block，与文本底线对齐, 这很少是我们真正想看到的。 要将内联(inline-block)块更改为块(block)，使用display属性非常简单。 但是如果你想以inline方式使用它，通常改变垂直对齐方式：vertical-top</p></li><li><p>&lt; textarea&gt; 元素默认地被渲染成一个块级元素。这里有重要地两点是 resize 和 overflow 属性(css属性而不是html属性)。因为我们的设计是一个固定大小的设计，所以我们会使用 resize 属性来防止用户调整我们的多行文本域的大小。overflow 属性是用来让域在不同的浏览器上渲染得更一致。一些浏览器默认值为 auto，而一些将默认值设为 scroll。在我们得例子中，最好确定每个浏览器都使用 auto： </p></li><li><p>&lt; button&gt; 元素上使用 CSS 非常方便；你可以做你任何想做得事情，甚至包括使用 伪元素：</p></li><li><p>注意添加outline 属性非常重要，这样可以移除由某些浏览器添加的默认高亮效果：</p></li></ul><p>CSS Basic UI Level 3 也增加了几个伪类用于描述小部件的状态：</p><pre><code>  :default  :valid  :invalid        :in-range        :out-of-range       :required        :optional        :read-only        :read-write</code></pre><blockquote><p>要实现对表单小部件的完全控制，你别无选择，只能选择依靠JavaScript。使用JS库</p></blockquote><hr><h5 id="表单-样式各个浏览器的兼容问题"><a href="#表单-样式各个浏览器的兼容问题" class="headerlink" title="表单 样式各个浏览器的兼容问题"></a>表单 样式各个浏览器的兼容问题</h5><h5 id="自定义表单部件-通过js发送表单数据-而不是采用默认"><a href="#自定义表单部件-通过js发送表单数据-而不是采用默认" class="headerlink" title="自定义表单部件 通过js发送表单数据,而不是采用默认"></a>自定义表单部件 通过js发送表单数据,而不是采用默认</h5><h5 id="表单提交时安全问题-格式问题"><a href="#表单提交时安全问题-格式问题" class="headerlink" title="表单提交时安全问题  格式问题"></a>表单提交时安全问题  格式问题</h5><ul><li>跨站脚本(XSS)和跨站点请求伪造(CSRF)是常见的攻击类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html表单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html基础</title>
    <link href="/2020/12/14/Html/Html%20%E5%85%A5%E9%97%A8/"/>
    <url>/2020/12/14/Html/Html%20%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML基础："><a href="#HTML基础：" class="headerlink" title="HTML基础："></a>HTML基础：</h2><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><ol><li><p>段落标题：&lt; hn&gt;&lt; p&gt;    强调语义：&lt; strong 加粗&gt; &lt; em斜体&gt; 为了阅读识别时使用，表现形式和&lt; b&gt; &lt; i&gt;没有区别           &lt; span&gt;没有语义  &lt; div&gt;  </p></li><li><p>&lt; b&gt; &lt; i&gt; &lt; u&gt; 粗 斜 下划线  用于标记联系方式的元素——&lt; address&gt; 斜体表示内容</p></li><li><p>超链接 &lt; a href target title&gt; 不仅可以链接外部网页，还可以链接到同一份文档的另一部分</p></li><li><p>描述列表 dl dd dt浏览器的默认样式会在描述列表的描述部分&lt; dd&gt;和描述术语&lt; dt&gt;缩进</p></li><li><p>&lt; abbr title=”” &gt; 当光标指向文字用来对某文字进行解释</p></li><li><p>使用上标和下标。&lt; sup&gt; 和&lt; sub&gt;元素</p></li><li><p>br hr    如果一个块级内容（一个段落、多个段落、一个列表等）从其他地方被引用，你应该把它用&lt; blockquote&gt;元素包裹起来表示，并且在cite属性里用URL来指向引用的资源  与之相对有行内引用《 q》</p></li><li><p>文档结构标签 &lt; header&gt; &lt; footer &gt; &lt; article&gt; &lt; aside&gt; &lt; section&gt; &lt; nav&gt;:导航栏 &lt; main&gt;:主体内容</p><h4 id="事件-字符集"><a href="#事件-字符集" class="headerlink" title="事件 字符集"></a>事件 字符集</h4></li></ol><h4 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h4><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ol><li><p>&lt; table&gt; &lt; td&gt;  &lt; th&gt;: 样式加粗 一般设置小标题, &lt; caption&gt;</p></li><li><p> colspan横跨 rowspan 竖跨  </p></li><li><p>表格内结构标签：&lt; thread:页眉 &gt;  &lt; tbody:定义表格主题&gt; &lt; tfoot:定义表格页脚&gt;：没有特效，只是格式标签  </p></li><li><p>&lt; colgroup&gt;  &lt; col&gt;为一列添加样式 ,每个col 代表一列 ,这里是第二列应用样式,如果想应用某行某列<br>span 表示该 &lt; col&gt; 元素横跨的列数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">col</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: yellow&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>scope 属性，可以添加在&lt; th&gt; 元素中 用来说明是列标题还是行标题  scope=”col” scope=”row”</p></li></ol><h4 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h4><ol><li>&lt; img src= alt= width height title= &gt;   title鼠标悬停的信息   alt它的值应该是对图片的文字描述</li></ol><ul><li><blockquote><p>如果图像对您的内容里有意义，则应使用HTML图像。如果图像纯粹是装饰，则应使用CSS背景图片。</p></blockquote></li><li><p>html5 中的&lt; figure&gt; 和 &lt; figcaption &gt;元素 （放置图片的说明信息）：为图片提供一个语义容器，在标题和图片之间建立清晰的关联。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;341&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>曼彻斯特大学博物馆展出的一只霸王龙的化石<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>&lt; iframe&gt;元素旨在允许您将其他Web文档嵌入到当前文档中。&lt; embed&gt;和&lt; object&gt;元素的功能不同于&lt; iframe&gt;—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具,不太使用</p></li></ul><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><h4 id="区块段落元素"><a href="#区块段落元素" class="headerlink" title="区块段落元素"></a>区块段落元素</h4><ul><li><p>HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。</p><pre><code>  &lt;section&gt;, &lt;article&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;aside&gt; 和 &lt;hgroup&gt;  新的HTML5标记 &lt;time&gt;元素，使用pubdate布尔值，表示整个文档的发布时间  &lt;blockquote&gt; 元素是一个外部引用 ,表示该文字是引用内容</code></pre><h4 id="新的元素"><a href="#新的元素" class="headerlink" title="新的元素"></a>新的元素</h4><blockquote><p> &lt; mark&gt;， &lt; figure&gt;， &lt; figcaption&gt;， &lt; data&gt;， &lt; time&gt;， &lt; output&gt;， &lt; progress&gt;， 或者 &lt; meter&gt;和&lt; main&gt;，这增加了有效的 HTML5 元素的数量。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JqueryApi 进阶</title>
    <link href="/2020/12/14/jquery/jquery%20%E6%8B%BE%E5%BF%86/"/>
    <url>/2020/12/14/jquery/jquery%20%E6%8B%BE%E5%BF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="Ajax-等待-高级ajax操作-高级DOM操作-对服务器传来的数排序"><a href="#Ajax-等待-高级ajax操作-高级DOM操作-对服务器传来的数排序" class="headerlink" title="Ajax (等待)  高级ajax操作  高级DOM操作(对服务器传来的数排序)"></a>Ajax (等待)  高级ajax操作  高级DOM操作(对服务器传来的数排序)</h4><ul><li>理解扩展事件 : 相当于给jquery新建事件,封装起来复用<h4 id="延迟对象-不理解"><a href="#延迟对象-不理解" class="headerlink" title="延迟对象(不理解)"></a>延迟对象(不理解)</h4><ul><li> promise  都用于ajax 这中耗时操作中, 延迟对象一般不需要手动建立,一般建立好的知道使用方法即可</li><li> 回调对象</li><li><blockquote><p>$.Callbacks()模块开发目的是：给内部$.ajax()和$.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能</p></blockquote></li></ul></li><li>涉及到jquery的原理层面<h5 id="自定义遍历符-开发插件的一部分-参考高级遍历"><a href="#自定义遍历符-开发插件的一部分-参考高级遍历" class="headerlink" title="自定义遍历符(开发插件的一部分) 参考高级遍历"></a>自定义遍历符(开发插件的一部分) 参考高级遍历</h5></li><li>选择符选择优化问题(原理)</li><li> 利用 $.expr[‘:’]  开发自定义选择器<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4></li></ul><hr><h3 id="根据API进行分类"><a href="#根据API进行分类" class="headerlink" title="根据API进行分类"></a>根据API进行分类</h3><h4 id="选择器过滤"><a href="#选择器过滤" class="headerlink" title="选择器过滤"></a>选择器过滤</h4><ul><li><p>.last()  获取匹配元素集合中最后一个元素 和:last 相同。  :last-child  判断匹配到的元素是否是其父元素的最后一个子元素  </p></li><li><p>:selected 选取select 中被选取的元素</p></li><li><p>:even 从0开始算</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4></li><li><p>add() 添加元素到匹配的元素集合。  addback([ selector]) 添加<strong>当前堆栈中</strong>元素<strong>集合</strong>到当前集合 ,(选择器可以筛选出之前堆栈内容 之后添加到当前集合)</p></li><li><blockquote><p>在end addback中的堆栈操作解释 : 每次遍历方法都会找到新的元素,这些新的元素构成一个jq对象压入堆栈</p></blockquote></li><li><p>end() addback()都是通过堆栈来实现的,end终止在当前链的过滤操作,返回匹配的元素的以前状态,本质使用了出栈操作,返回原来的一个状态</p></li><li><p>closest() 从元素本身开始，逐级向上找到符合条件的第一个元素，该元素可能是当前元素自身，也可能是最靠近当前元素的一个祖先元素。</p></li></ul><ul><li><p>.children()  获得元素的子元素(可以进行选择筛选)   .contents()获得元素的子元素包括文字注释节点</p></li><li><p>nextAll() prevAll() 返回的结果都不包括自身</p></li><li><p>next([selector ] )   返回元素紧邻的后面的同辈元素,如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。</p></li><li><p>has() 筛选相匹配的元素,如果符合条件就留下来,最后返回一个集合    not() 通过条件筛选,符合条件的去除 和has 相反</p></li><li><p> is()判断当前元素,返回布尔值</p></li><li><p>map(callback)  用于处理当前jQuery对象匹配的所有元素，并将处理结果封装为新的jq数组 </p></li><li><blockquote><p>特别适用于获取或设置元素集合中的值</p></blockquote></li><li><p>.slice(start [, end )  根据指定的下标范围，过滤匹配的元素集合 (从零开始计数,所以范围是到end-1) </p></li></ul><p>-find() 是往匹配元素的后代元素里寻找符合条件的</p><h4 id="偏移-尺寸"><a href="#偏移-尺寸" class="headerlink" title="偏移 尺寸"></a>偏移 尺寸</h4><ul><li><p>offsetparent() 获得被定位后的祖先元素的top left值,没有就返回undefined</p></li><li><p>position()  获得当前元素针对被定位祖先元素的偏移量 没有就返回针对document的偏移量</p></li><li><blockquote><p>被定位 指的是 position不为static的元素</p></blockquote></li><li><p>指的注意的是 偏移的top left值的计算是不包括margin值,到maigrin的边界的值才是偏移量</p></li><li><p>height() 获取高度值(只包括内容)  innerheight() 获取高度值(包含padding不包含border) outerheight(包括 padding border 参数为true 则包含margin)</p></li></ul><h4 id="DOM操作-css属性-html属性-DOM增删改查"><a href="#DOM操作-css属性-html属性-DOM增删改查" class="headerlink" title="DOM操作 (css属性 html属性 DOM增删改查)"></a>DOM操作 (css属性 html属性 DOM增删改查)</h4><ul><li><p>删除操作</p></li><li><p>empty() 这个方法不仅移除子元素（和其他后代元素),同样移除元素里的文本</p></li><li><p>remove() 和.empty()相似 , 当我们想将元素自身移除时我们用 .remove()</p></li><li><p>detach() 要删除的元素不删除数据和事件的情况下，使用.detach()来代替。 当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。</p></li><li><p>prop()  val() 对表单进行操作 </p></li><li><p>val() 主要用于获取表单元素的值, val()获得value属性内容,对于多选下拉列表则返回一个数组包含每个选择项     通过.val([ “表单value值”])可以设置被选中的状态 (对于select 没有value值的直接写选项中的值也可以被选中)</p></li><li><p>.prop( propertyName, value ) 获取/设置元素的property值(一般我们用在表单属性上,具体参考API)</p></li></ul><ul><li> html() 获取设置匹配元素内部的html内容(设置时会把之前的内容替换掉) </li><li> text() 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代.     可以用来给指定元素设置文本内容(文本内容会替换指定元素里的所有内容)</li></ul><ul><li><p>DOM 操作分为几类 : 内部/外部添加到前面/后面   调用顺序不同</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4></li><li><p>.triggerHandler()   .triggerHandler() 方法的行为与 .trigger() 相似,不会触发默认行为 事件冒泡, 只会对匹配到的第一个元素生效   trigger()与之相反</p></li><li><p>trigger() 除了一次模拟事件还可以给事件提供额外参数: .trigger( eventType [,extraParameters ])  额外参数是数组类型</p></li><li><blockquote><p>$(“p”).click( function (event, a, b) {}).triggr(“click”, [“foo”, “bar”]);</p></blockquote></li><li><p>.one() 要绑定一个事件，并且只运行一次，然后删除自己</p></li><li><p>on()函数  .on( events [, selector ] [, data ], handler(eventObject) ) </p></li><li><blockquote><p>.on( events [, selector ] [, data ] ) 这里的events是一个对象键值是事件名 值是处理函数,可以利用此一次处理多个事件</p></blockquote></li><li><p>keydown  keypress 事件区别 : keypress表示被输入哪个字符(字符代码) ,若想捕获敲击了哪个特殊键的话，例如，方向键(keycode)，  使用 .keydown()或.keyup() 更好。想要得到输入的文本内容只能是keyup,其他的只能获取输入前的文本</p></li></ul><ul><li>change 事件被&lt; input&gt;, &lt; select&gt;, 和&lt; textarea&gt; 触发,对元素值<strong>更改后</strong>触</li></ul><h4 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h4><ul><li><p>.animate() 所有用于动画的属性(设置变化的键值对)必须是数字的，除非另有说明,不要使用css简写属性<br>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。动画属性可以使用 +=</p></li><li><p>精细控制动画  animate 函数 step progress函数使用  : step函数被每个动画元素的每个动画属性调用 ,它接受两个参数（now 和 fx） this是当前正在执行动画的DOM元素集合</p></li><li><blockquote><p>now: 每一步动画属性的数字值 fx: jQuery.fx 原型对象的一个引用 </p></blockquote></li><li><blockquote><p>比如elem 表示前正在执行动画的元素，start和end分别为动画属性的第一个和最后一个的值，prop为进行中的动画属性。</p></blockquote></li><li><p>queue 属性,决定要不要进队列中一个动画接下一个,flase 则是会和下一个动画方法同时发生(前提 : 这些都是连缀书写动画方法)</p></li><li><p>progress函数 每一步动画(step大约13毫秒调用一次,progress相似的方式)完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数</p></li></ul><ul><li><p>.delay()  设置一个延时来推迟执行队列中后续的项  它无法取消延时,不是JavaScript的原生 setTimeout函数的替代品</p></li><li><p>.queue( [queueName ] 默认为fx),显示在匹配元素上已经执行的函数队列 (这里的执行不一定是已经完成了,有时动画可能在队列中排队,完成函数调用就算是执行) ,</p></li><li><p>.queue( [queueName ], newQueue ) newQueue是array类型代表函数数组,用来替换当前队列中的内容,newQueue可以是空的数组 [],可以用来取消队列中不想进行的函数操作  类似 clearQueue()操作</p></li><li><p>.queue( [queueName ], callback( next ) ) 它让我们把新函数置入到队列的末端。为jQuery集合中的每个元素执行一次回调函数。类似在动画方法提供回调函数</p><blockquote><p>当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。 从jQuery 1.4开始，向队列中追加函数时，可以向该函数中传入另一个函数next()</p></blockquote></li></ul><blockquote><p>队列允许一个元素来异步的访问一连串的动作，而不终止程序执行,在执行上一个同时还能继续下个操作,队列存储信息  :$(‘#foo’).slideUp().fadeIn(); ,这个元素开始立即做滑动动画，但渐入动画放置在 fx列队,  所以jq可以执行完slideup还能继续执行渐变, </p></blockquote><ul><li><p>.dequeue()  移除队列中的首个函数, 然后执行这个函数, 这个执行的函数中也应当直接或间接的包含.dequeue()语句，这样才能继续执行队列中的其它函数</p></li><li><p>.clearQueue( [queueName ] )方法被访问的时候，所有在这个列队中未执行的函数将被移除 。当不使用参数的时候，.clearQueue()会从标准的动画队列fx中移除剩下的函数</p></li><li><blockquote><p>这个方法类似.stop(true)。然而.stop()方法只适用在动画中。.clearQueue()还可以用来移除用.queue()方法添加到普通jQuery列表的任何函数。 </p></blockquote></li></ul><ul><li><p>stop()  , 只会停止当前动画,对于队列中的其他动画可以选择停止,stop停止的动画函数,无法执行动画里的回调函数</p></li><li><p>.stop( [clearQueue ] [, jumpToEnd ] ) 默认都为false</p></li><li><p>.stop( [queue ] [, clearQueue ] [, jumpToEnd ] ),还可以选择队列名称</p></li><li><p>finish() 在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值 和.stop(true, true)很相似,但是stop只会把当前的动画跳转到目标值</p></li></ul><blockquote><p>关于动画队列,每个元素维护自己的一个动画队列,不会不同的动画元素放在一起</p></blockquote><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li><p>data() 在匹配元素上存储任意相关数据. .removeData()移除存储数据 通过data()函数存取的数据都是临时数据，一旦页面刷新，之前存放的数据都将不复存在</p></li><li><p>toArry() 返回包含jquery对象的DOM元素数组  get()返回一个对应的DOM元素</p></li></ul><h4 id="高级事件处理"><a href="#高级事件处理" class="headerlink" title="高级事件处理"></a>高级事件处理</h4><ul><li>理解早委托 : 把事件绑定到document,不必等到文档全部加载好才能够处理事件,当委托加载好就可以</li><li>理解自定义事件 -自定义事件参数 : 用on函数定义 自定义事件处理 trigger 进行调用</li><li><blockquote><p>.on(“myCustomEvent”, function(e, myName, myValue){}) 自定义事件 还可以可以给与参数,在trigger调用时添加参数即可</p></blockquote></li></ul><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><ul><li>使用插件原理是一样的,默认的只需要调用一个(插件自定义函数),如果想要自定义内容就要在函数中提供参数,来修改一些属性(这些属性只能通过插件API 文档获得)</li></ul><h4 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h4><ul><li>添加jquery对象的全局函数    $.func    $.extend({})  </li><li>扩展jquery 对象的方法    $.fn.func  $.fn.extend({})</li><li><blockquote><p>jQuery.fn对象是jQuery.prototype的别名</p></blockquote></li><li><blockquote><p>在任何插件方法内部，关键字this引用的都是当前的jQuery对象</p></blockquote></li></ul><ul><li>使用命名空间隔离函数 : 其他jQuery插件也可能定义相同的函数名。为了避免和自己定义插件的函数冲突，最好的办法是 把属于一个插件的全局函数都封装到一个对象中 (实际上创建一个对象,在对象里定义方法,这样就起到隔离的效果)</li><li><blockquote><p> $.mathUtils = { 函数 ) </p></blockquote><h5 id="开发插件注意的问题"><a href="#开发插件注意的问题" class="headerlink" title="开发插件注意的问题"></a>开发插件注意的问题</h5></li></ul><p>-考虑方法的隐式迭代问题 :  jQuery的选择符表达式可能会匹配零、一或多个元素, 调用.each()方法；这样就会执行隐式迭代 (在调用的.each()方法内部，this依次引用每个DOM元素)</p><ul><li><blockquote><p>this.each(function(){})  这里this代表一个有很多元素集合的 jquery对象</p></blockquote></li><li><p>考虑方法的连缀问题:  函数的返回值要是一个jquery 对象</p></li><li><p>参数默认值 默认参数的可修改 自定义参数 问题</p></li><li><p>提供自定义参数,做到和animate()方法一样,能够给与参数修改属性值的操作, 提供默认值,有时候不用给参数的属性值也可以调用 或者给一部分, </p></li><li><p>方法参数也可能不是一个简单的数字值，可能会更复杂。在各种jQuery API中经常可<br>以看到另一种参数类型，即回调函数</p></li><li><p>多次调用一个插件,给与同一个参数改变默认值,很麻烦,可以直接修改默认值,例如 jquery.fx.interval 可以直接修改默认的动画频率</p></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123; <br>  $.fn.shadow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>&#123; <br>    <span class="hljs-keyword">var</span> defaults = &#123; <br>      copies: <span class="hljs-number">5</span>, <br>      opacity: <span class="hljs-number">0.1</span> <br>      copyOffset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;    <span class="hljs-comment">//默认方法参数是一个函数</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>: index, <span class="hljs-attr">y</span>: index&#125;;<br>    &#125;; <br>    <span class="hljs-keyword">var</span> options = $.extend(defaults, opts); <br>    <span class="hljs-keyword">var</span> offset = options.copyOffset(i);   <span class="hljs-comment">//自定义参数 (函数形式)</span><br>    <span class="hljs-comment">// ...  自定义参数格式: options.参数名</span><br>  &#125;; <br>&#125;)(jQuery);<br></code></pre></td></tr></table></figure><ul><li>extend函数,会使opt对象对defaults 进行覆盖.</li><li>上式只能改变自定义参数, 但是不能直接改变默认值,想直接改变默认值,默认值参数对象必须放在函数代码外,能够被外部调用</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123; <br>  $.fn.shadow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>&#123;  <br>    <span class="hljs-keyword">var</span> options = $.extend(&#123;&#125;,$.fn.shadow.defaults, opts); <span class="hljs-comment">//只能修改空对象,如果修改defaults, 在自定义参数中就会更改了默认值.</span><br> <br>    <span class="hljs-comment">// ...  自定义参数值 :  options.参数名</span><br>  &#125;; <br>  <span class="hljs-keyword">var</span> $.fn.shadow.defaults = &#123;<br>       copies: <span class="hljs-number">5</span>, <br>       opacity: <span class="hljs-number">0.1</span>,<br>  &#125;;<br>&#125;)(jQuery);<br><br></code></pre></td></tr></table></figure><ul><li>修改默认值 :   $.shadow.defaults.参数名=…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jquery指导</title>
    <link href="/2020/12/14/jquery/JQuery%20%20%E6%8C%87%E5%AF%BC/"/>
    <url>/2020/12/14/jquery/JQuery%20%20%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="Jquery-实践"><a href="#Jquery-实践" class="headerlink" title="Jquery 实践"></a>Jquery 实践</h1><ul><li><p>抽象jquery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax </p></li><li><p> jquery 总是面向对象,对节点集合可能会进行隐式迭代操作</p></li><li><p>编写程序时要尊重渐进增强,和平稳退化</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><blockquote><p>jQuery完全继承了css选择器风格,下面的选择器用法也是css选择器的用法<br>使用jquery选择器就算获取不到元素也不会报错,传统dom在获取之前要加上if判断是否存在,需要注意<br>$()获取的永远是一个对象,就算不存在该元素,所以jquery通过对象的长度大小.length//转换为dom对象判断,来评判是否存在该元素</p></blockquote><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4></li><li><p>id 标签名 类名 层次选择器(+ ~ &gt; 后代…)</p></li><li><p>表单选择器  :表单标签名字</p><h4 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h4><pre><code>基本过滤选择器 :first 选取第一个元素（单个元素）,:last:not(selector) 去除所有与给定选择器匹配的元素,:even :odd 索引从零开始:eq（index） 选取索引等于index的元素,:gt(index)  大于index :lt(index)：小于:header：选取所有的标题元素:animated：选取当前正在执行动画的所有元素:focus：选取当前获得焦点的元素属性选择器: element[attr] 选中拥有attr属性的元素,可以多选属性 element[attr][attr0]可以利用正则表达式进行判断属性 a[href^=&quot;mailto:&quot;] 判断href属性开头含有mailto的元素内容过滤器  :contains(text) 选取(直接)含有text文本内容的元素,(子元素含有并不算):empty 选取内容为空的元素(没有元素节点 没有文本节点)  :has(selector) 选取**含有**指定选择器选定的元素的元素  :parent 选取有子元素的元素:visible  选取所有可见的元素:hidden 子元素过滤器  nth-child() 参数可以为数字 even/odd  表达式  索引从1开始first-child last-child only-child表单元素过滤器 :checked :selected :enabled :disabled</code></pre></li></ul><blockquote><p>性能提示   DOM对象和jquery对象的互换(在jquery对象中调用DOM) </p></blockquote><blockquote><p>jQuery提供了一个jQuery.noConflict()方法，把对$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,jQuery(document).ready(function($) {正常使用符号} ) </p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li><p>在事件处理中常用内容:</p><pre><code>  当触发任何事件处理程序时，关键字this引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象  toggleClass(&quot;类名&quot;)方法,(类名不加点)能够根据相应的类是否存在而添加或删除类  is() 判断是否为一个选择器 DOM元素...  例如:  .is(&#39;:hidden&#39;) 判断元素是否是可见的  .one()只生效操作一次,参数和on函数一样,相当于一次的on函数调用</code></pre><h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5></li><li><p>.on(“click”,fn)  fn可以是函数引用或者匿名函数</p></li><li><p> 除了on绑定,还可以用事件名函数绑定  例如.click() 键盘事件 .keypress()…</p><blockquote><p>on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jquery隐式迭代机制,jquery的行为队列机制,可以给一个元素绑定多个相同事件不会被覆盖<br>老版本会有bind()查看jquery api<br>.on(),中的函数参数,可以是函数引用,函数引用,必须省略函数名称后面的圆括号。圆括号会导致函数被调用，而非被引用。</p></blockquote></li></ul><h5 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h5><ul><li>调用.off(“事件名”)方法移除</li><li>对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.<blockquote><p>例如:  .on(‘click.collapse’,fn);  .off(‘click.collapse’); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的</p></blockquote></li><li>对.off()的调用更有针对性,还可以在调用on(“click”,fn引用)时,在fn中进行判断事件对象,这样可以不用命名空间, 注意一个问题,如果重复触发事件,就会重复调用这个函数,比如重复点击.</li><li>重新绑定事件,只需要再次调用on函数.</li></ul><h5 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h5><ul><li>$(document).ready()  简写-&gt; $(function(){});<blockquote><p>window.onload和ready()区别：$(document).ready()，会在DOM完全就绪并可以使用时调用，但是关联文件不一定下载完毕,还有ready()可以一直添加不会被覆盖.</p></blockquote></li></ul><h3 id="事件传播（旅程）"><a href="#事件传播（旅程）" class="headerlink" title="事件传播（旅程）"></a>事件传播（旅程）</h3><ul><li><p>DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,</p><blockquote><p>在js编程中默认在冒泡阶段进行处理事件,改变addEventListener(type,fn,false)中的false为true,则是在事件捕获时进行处理事件(从最外层处理一直到最内层)</p></blockquote></li><li><p>jquery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。</p></li><li><p>避免事件传播的事件处理</p><pre><code>  hover(fn,fn)函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播  而mouseenter和mouseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。</code></pre></li></ul><h5 id="事件冒泡-–事件捕获"><a href="#事件冒泡-–事件捕获" class="headerlink" title="事件冒泡 –事件捕获"></a>事件冒泡 –事件捕获</h5><ul><li><p>冒泡副作用:错误的元素响应mouseover或mouseout事件的情况下,例如外层div最内层a,当最内层a元素鼠标离开时会触发mouseout事件向外层冒泡</p></li><li><p>事件冒泡,从具体元素到一般元素的理解: 具体元素指的是响应事件最(准确具体)的元素,例如a元素嵌套一个i元素图标,那么当不点击图标时,最具体的元素是a而不是 i元素,当li嵌套一个a(块级)时,响应没有最准确的那么选最具体的a元素</p></li><li><p>事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡</p><blockquote><p>mouseover out事件,在鼠标从父元素移入子元素时会触发 父元素out事件,over事件总是从父级元素到自己元素</p></blockquote><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3></li><li><p>事件对象是一种DOM结构，它会在元素获得处理事件时,获取触发事件的元素.这个对象中包含着与事件有关的信息,也提供了可以用来影响事件在DOM中传递进程的一些方法 (jquery对对象属性进行封装,使其可以兼容,以下是jquery封装过得,可能和原生DOM不同)</p><pre><code>属性: .target 获取触发事件的DOM元素 .type 获取事件类型 .pageX.pageY 获取相对于页面x坐标y坐标 .which 获取鼠标的左中右键 获取键盘事件的按键  .mateKey获取ctrl键方法:  preventDefault() 阻止默认行为  stopPropagation()阻止事件冒泡</code></pre></li></ul><blockquote><p>通过事件对象解决事件冒泡问题</p></blockquote><ul><li>事件传播和默认操作是相互独立的两套机制，在二者任何一方发生时，都可以终止另一方。<blockquote><p>如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false，这是对在事件对象上同时调用.stopPropagation()和.preventDefault()的一种简写方式。</p></blockquote></li></ul><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><ul><li><p>只在DOM中的一个祖先元素上指定一个单击处理程序。由于事件会冒泡，未遭拦截的单击事件最终会到达这个祖先元素,而我们可以在此时再作出相应处理.</p></li><li><p>使用内置的事件委托, on函数接受相应参数,例如: .on(‘click’, ‘button’, function(){}) :事件处理绑定到父元素上，同时比较event.target和选择符表达式（这里的’button’）。如果匹配执行事件处理.</p></li><li><p>某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素</p></li></ul><h5 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h5><ul><li>例如用户进入页面时,就触发点击事件,不要去点击它,这时需要模拟事件: trigger(“click”),也可以直接使用简化模式,调用.click();</li><li>tigger还可以触发自定义事件<blockquote><p>trigger()方法不仅会触发事件,还会触发默认行为 trigger(“focus”),这样除了触发事件,还会是该元素获得focus,单纯的触发事件使用triggerHandler()</p></blockquote></li></ul><h2 id="样式与动画"><a href="#样式与动画" class="headerlink" title="样式与动画"></a>样式与动画</h2><h3 id="css属性操作"><a href="#css属性操作" class="headerlink" title="css属性操作"></a>css属性操作</h3><ul><li><p>.css()方法,用来获取计算后的样式,设置内联样式.</p><pre><code> 获取使用: 单个样式属性   传递一个字符串形式的属性名，获取字符串形式的属性值, 多个样式属性   可以传入属性名的数组，得到的则是属性和值构成的对象, 对于属性名的格式,可以解释驼峰命名,也可以解释连字符的命名   设置使用: css()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值，另一种是为它传递一个由属性—值对构成的对象 例如:  1. $speech.css(&#39;fontSize&#39;, num + &#39;px&#39;);      2. var Obj =&#123;&#39;background-color&#39; : &#39;#ddd&#39;,&#39;color&#39; : &#39;rgb(0,40,244)&#39;&#125;;     $(this).css(Obj);</code></pre></li></ul><blockquote><p>浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在,。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性</p></blockquote><h3 id="样式变化"><a href="#样式变化" class="headerlink" title="样式变化"></a>样式变化</h3><ul><li><p>隐藏/显示元素:  .hide() .show()  -&gt;相当于设置display的值   默认是不带动画效果的.</p><blockquote><p>.hide()方法会将匹配的元素集合的内联style属性设置为display:none。但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局</p></blockquote></li><li><p>带动画效果: .hide(‘duration’)   duration:毫秒级   动画效果-&gt;会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,</p><blockquote><p>动画效果有两种预设的速度参数：’slow’和’fast’。也可以自定义指定显示速度. 以下动画效果都可以适用</p></blockquote></li><li><p>淡入和淡出, fadeIn(),fadeOut()  : 改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。</p></li><li><p>滑入和滑下, slideDown()和.slideUp() : 改变高度和display的值   元素本来就处在文档流中,适合使用滑入滑出</p></li><li><p>复合效果方法,  slideToggle() ,动画和slideDown(),slideUp()一样    toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3></li><li><p>.animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式</p><pre><code>第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:.animate(&#123;property1: &#39;value1&#39;, property2: &#39;value2&#39;&#125;, duration, easing, function() &#123;&#125;)第二种形式接受两个参数，一个属性对象和一个选项对象.animate(&#123; property1: &#39;value1&#39;, property2: &#39;value2&#39; &#125;, &#123; duration: &#39;value&#39;, easing: &#39;value&#39;,specialEasing: &#123; property1: &#39;easing1&#39;, property2: &#39;easing2&#39; &#125;, complete: function() &#123;&#125;, queue: true, step: callback &#125;);</code></pre></li><li><p>animate()方法最少要有两个参数,属性对象和duration</p><blockquote><p>.animate()方法针对CSS属性提供了方便简写值：’show’、’hide’和’toggle’,例如 : .animate({height: ‘toggle’}, ‘slow’);</p></blockquote></li><li><p>animate()方法中,属性对象中的值如果是 {“height” :”+=value” }表示在原来的基础上再加上value,而不是变化到value</p><h4 id="并发-同时发生-排队效果-一个接一个发生"><a href="#并发-同时发生-排队效果-一个接一个发生" class="headerlink" title="并发(同时发生)   排队效果(一个接一个发生)"></a>并发(同时发生)   排队效果(一个接一个发生)</h4></li><li><p> 同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.</p><blockquote><p>需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式</p></blockquote></li><li><p> 想要同时触发效果,要在一个方法内写多个属性</p></li><li><p> 多个元素,应用效果时,这些效果会同时发生,</p></li><li><p> 为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数,在效果方法中,它们是方法的最后一个参数。</p><blockquote><p>$clickedItem.next().slideDown(‘slow’, function() { $clickedItem.slideUp(‘slow’); }); 顺序为外层先执行,内层的回调函数在执行</p></blockquote><h5 id="越过队列-调整排队效果"><a href="#越过队列-调整排队效果" class="headerlink" title="越过队列(调整排队效果)"></a>越过队列(调整排队效果)</h5></li><li><p>第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始</p></li><li><p>对于非效果方法,如.css()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序</p><blockquote><p>解决方法1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({backgroundColor:’#f00’});next();}) ,传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码</p></blockquote></li></ul><blockquote><p>解决方法2:利用效果方法中的回调函数,在回调函数中书写.css(), 在外层函数完成时执行css,不需要调用next()</p></blockquote><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><h5 id="HTML-属性操作"><a href="#HTML-属性操作" class="headerlink" title="HTML 属性操作"></a>HTML 属性操作</h5><ul><li><p>.attr() 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值</p><blockquote><p>可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:</p></blockquote></li><li><p>$(‘div.chapter a’).attr({  title: ‘Learn more at Wikipedia’, id: function(index, oldValue) { return ‘wikilink-‘ + index; }</p><blockquote><p>这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用</p></blockquote></li><li><p>.removeAttr()方法 删除<em>一个</em>属性</p></li><li><p>类属性常用函数: .addClass()和.removeClass()   .toggleClass()方法交替添加删除类名</p><h5 id="DOM-属性"><a href="#DOM-属性" class="headerlink" title="DOM 属性"></a>DOM 属性</h5></li><li><p>在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同</p></li><li><blockquote><p>从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。</p></blockquote></li><li><p>DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性 例如:</p></li><li><blockquote><p>var id = div1.getAttribute(“id”)    var id = div1.id;</p></blockquote></li><li><p>HTML属性与DOM属性有一点区别。HTML属性是指页面标记中放在引号中的值，而DOM属性则是指通过JavaScript能够存取的值,HTML属性与DOM属性差别最大的地方是表单控件的属性,不要使用attr(),要使用val()获取/设置属性  或者是prop操作DOM属性(这个是要分情况的)</p><blockquote><p>.val()方法也可以接受一个函数作为其setter参数,与.attr()和.prop()一样 表单中最好都使用本函数</p></blockquote></li></ul><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul><li><p>创建节点 :  使用$(“”)函数创建节点</p></li><li><p>插入(添加).移动节点: </p><pre><code>内容.insertBefore(&quot;目标&quot;)在现有元素外部、之前添加内容；.prependTo()在现有元素内部、之前添加内容；.appendTo()在现有元素内部、之后添加内容；.insertAfter()在现有元素外部、之后添加内容。</code></pre></li></ul><blockquote><p>使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了<br>在隐式迭代添加多个节点时,插入顺序预定义的,不管是after before,从上到下顺序都是迭代顺序</p></blockquote><ul><li><p>反向插入方法 :内容目标的位置颠倒,名字更换了一下</p><pre><code> append() prepend() before() after()</code></pre><blockquote><p>反向插入方法,可以接受一个函数作为参数,这个函数会针对每个目标元素调用</p></blockquote></li><li><p>包裹节点</p><pre><code>被包裹的节点.wrap(&quot;节点&quot;)  .wrapAll(&quot;节点&quot;) 区别:后者在多个节点时,只包裹一次(最外面的节点),wrap每个节点都会包装,wrapInner()包裹匹配元素的子元素</code></pre></li><li><p>复制节点</p><pre><code>.clone()方法,默认不复制事件,如果想要复制.clone(true);  </code></pre></li><li><p>删除节点 </p><blockquote><p>从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件</p></blockquote><pre><code>remove(),detach()两者区别: 在于使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除,两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null empty()清空节点里的内容(文本 元素节点),*注意是节点里的,不是节点本身* 返回一个已经清空的元素</code></pre></li><li><p>替换节点(文本/元素)</p></li></ul><pre><code> .html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容 .text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本 .replaceAll(&quot;目标&quot;) 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动 .replaceWith(&quot;内容&quot;)   替换集合中所有匹配的元素,返回被删除元素的集合</code></pre><h4 id="DOM遍历"><a href="#DOM遍历" class="headerlink" title="DOM遍历"></a>DOM遍历</h4><ul><li>find(“选择器”)  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。</li><li>end() 终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.</li><li>each()方法就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次</li><li>.filter() 它可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中</li><li> next()方法 .nextAll() 获得后面所有的元素    对应方法: .prev()和.prevAll() </li><li>.siblings() 获取兄弟元素，无论这些元素处于当前元素之前还是之后.</li><li>  parent()     , children() :只考虑子元素,不考虑后代元素</li><li> jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]</li></ul><h3 id="jquery中的AJAX技术"><a href="#jquery中的AJAX技术" class="headerlink" title="jquery中的AJAX技术"></a>jquery中的AJAX技术</h3><blockquote><p>原生js的ajax并没有涉及,可以查阅资料了解</p></blockquote><ul><li>Ajax只不过是一种无需刷新页面即可从服务器（或客户端）上加载数据的手段。这些数据的格式可以是很多种,例如:HTML JSON XML js       </li><li>所有Ajax请求在默认情况下都是异步的<h5 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h5></li><li>HTML文件:  .load()方法,加载远程HTML代码插入DOM中,格式:load(URL,data,callback)</li><li>JSON文件:  $.getJson()方法用于加载json ,这是个全局函数, 可以接受第2个参数，这个参数是当加载完成时调用的函数(用来处理加载过来的数据)<blockquote><p>尽管JSON格式很简洁，但它却不容许任何错误，否则文件不会加载。而且在多数浏览器中当文件加载失败时我们看不到任何错误信息,脚本只是静默地彻底终止运转。</p></blockquote></li><li>js文件(可当做脚本文件): $.getScript()   (脚本文件基本有服务器端写,前端负责取数据直接调用)<blockquote><p>以这种方式取得的脚本会在当前页面的全局环境下执行。这意味着脚本有权访问在全局环境中定义的函数和变量，当然也包括jQuery自身。常见脚本php node.js… 一般纯j不用作脚本</p></blockquote></li><li>XML文件: $.get() <blockquote><p>通常，这个函数只是取得由URL指定的文件，然后将纯文本格式的数据提供给回调函数。但是,在根据服务器提供的MIME类型知道响应的是XML的情况下，提供给回调函数的将是XML DOM树。这样可以向操作html一样操作xML文件中数据</p></blockquote><h5 id="向服务器传递数据"><a href="#向服务器传递数据" class="headerlink" title="向服务器传递数据"></a>向服务器传递数据</h5></li><li>Ajax的价值只有当服务器能够基于浏览器的输入动态形成数据时才能得到充分体现</li><li>执行GET请求 根据 $.get函数,向服务器传递参数(要查询的数据),得到服务器返回的数据.<blockquote><p>load函数也可以,URL后面添加查询字符串,load()方法在接收到包含数据的对象参数时，会默认使用POST方法<br>发送请求</p></blockquote></li><li>执行POST请求  $.post()</li><li>表单提交——序列化表单</li></ul><h5 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h5><ul><li><p>jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。</p><pre><code>      .ajaxStart()和.ajaxStop()方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个      当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数       当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.      如.ajaxError()，会向它们的回调函数发送一个对XMLHttpRequest对象的      引用。这样就可以做到区别不同的请求来提供不同的行为      其他更具体的处理可以通过使用低级的$.ajax()函数来完成。</code></pre></li><li><p>错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 </p><h5 id="ajax中的常见问题"><a href="#ajax中的常见问题" class="headerlink" title="ajax中的常见问题"></a>ajax中的常见问题</h5></li><li><p>通过Ajax生成页面内容时的一个常见问题:事件绑定丢失</p><blockquote><p>事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。<br>解决方法: 每次页面内容更新重新绑定事件      使用事件委托</p></blockquote></li><li><p>安全限制 : 为了防止各种跨站点脚本攻击，一般情况下从提供原始页面的服务器之外的站点请求文档是不可能的。但是，从第三方来源中加载数据往往是很有必要的</p><blockquote><p>方法: 是通过服务器加载远程数据，然后在客户请求时提供给浏览器.    根据请求注入&lt; script&gt;标签或者$.getScript() 使用&lt; iframe&gt;这个HTML标签来加载远程数据。    从其他服务器取得JSONP文件.</p></blockquote></li><li><p>使用$.ajaxSetup()函数可以修改调用Ajax方法时每个选项的默认值。这个函数与.$.ajax()接受相同的选项对象参数，之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，</p></li><li><p>取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式</p></li></ul><hr><p>以上为最基础核心,掌握运用</p><blockquote><p>开发插件章节  需要后期编码后进行学习 </p></blockquote><h3 id="高级DOM遍历-高级事件处理-高级效果"><a href="#高级DOM遍历-高级事件处理-高级效果" class="headerlink" title="高级DOM遍历 高级事件处理  高级效果"></a>高级DOM遍历 高级事件处理  高级效果</h3><h5 id="高级遍历"><a href="#高级遍历" class="headerlink" title="高级遍历"></a>高级遍历</h5><ul><li> Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。<blockquote><p>使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异</p></blockquote></li><li>选择符优化问题 自定义选择符<blockquote><p>如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器</p></blockquote></li><li>DOM遍历背后的原理<blockquote><p>向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关</p></blockquote></li><li>addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑</li><li>DOM 遍历的性能问题 : 多使用连缀,和缓存jquery对象,来最低限度的重复使用选择符和遍历方法</li></ul><h5 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a>事件处理</h5><ul><li>扩展事件  自定义事件 节流事件</li></ul><h5 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h5><blockquote><p>使用jQuery自定义的:animated选择符, is(‘:animated’)判断是否在动画中</p></blockquote><ul><li><p>中止运行的动画 .stop([clearqueue][jumptoend]) 两个可选参数,默认都为false</p><blockquote><p>在1.7之前版本  在动画之前，这些简写的动画方法(slidedown fadein…)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。</p></blockquote></li><li><p>延迟动画执行 delay() </p></li></ul><ul><li><p>全局效果属性 :$.fx对象  \</p><pre><code>禁用所有动画效果-&gt; $.fx.off=true;定义效果时长 $.fx.speeds= ...  可以改变预设值的效果速度,可以自定义一个速度选项</code></pre></li></ul><ul><li><p>多属性缓动  </p><p>   通过动画方法中,specialEasing选项可以为每个要应用动画的属性设置不同的加速度曲线。任何没有包含在这个选项中的属性，都会使用easing选项中指定的缓动函数——如果提供了的话；否则，就要使用默认的swing函数</p></li><li><p>使用延迟对象,对于任何延迟对象，调用它的.promise()方法就可以取得其承诺对象,</p></li><li><blockquote><p>每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。通过在jQuery对象上调用.promise()方法，可以得到一个队列完成后被解决的承诺对象 .promise().done(showBio); 在队列完成之后调用showBio函数  .always() 在延迟对象完成任务时调用</p></blockquote></li><li><p>.animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  </p><blockquote><p>jQuery动画系统最底层的方法是$.Animation()和$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面</p></blockquote></li></ul><h5 id="高级DOM操作"><a href="#高级DOM操作" class="headerlink" title="高级DOM操作"></a>高级DOM操作</h5><ul><li>从服务端取得数据排序问题</li></ul><hr><p>第十三章 高级ajax操作,要等到node.js时开始</p><p>本文档参考                   &lt;  jquery 基础教程第四版  2020 6.30 &gt;</p>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World lalla</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="edit-github-from"><a href="#edit-github-from" class="headerlink" title="edit github from"></a>edit github from</h3><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h4 id="Github-action"><a href="#Github-action" class="headerlink" title="Github action"></a>Github action</h4><ul><li>加上 github action 就完成了自动打包 部署  不再使用hexo generate deploy, 直接提交代码就可以了</li></ul><h4 id="改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键"><a href="#改变模板留下链接进行直接编辑-文章内容-只能在-hexo-serve-时看到编辑键" class="headerlink" title="改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键"></a>改变模板留下链接进行直接编辑 文章内容, 只能在 hexo serve 时看到编辑键</h4>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3</title>
    <link href="/2020/12/13/Css/CSS3/"/>
    <url>/2020/12/13/Css/CSS3/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul><li><p>边框</p><ul><li><p>border-radius    圆角</p><blockquote><p>默认一个值应用在四个方向,如果想单独设置,可以各四个值分别代表 从左上顺时针到左下的角</p></blockquote></li><li><p>box-shadow   边框阴影 </p><blockquote><p>四个值分别   x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 </p></blockquote></li></ul></li><li><p>border-image    用图片创建边框</p><ul><li><blockquote><p>三个值 /* border-image: image-source image-height image-width image-repeat */</p></blockquote></li></ul></li><li><p>背景  </p><ul><li>background-size  规定背景图片的尺寸进行缩小扩大使用</li><li>background-origin  规定背景图片的定位区域<blockquote><p>参数:content-box、padding-box 或 border-box  以这几个区域为参考放置图片</p></blockquote></li></ul></li><li><p>文本</p><ul><li>text-shadow 文本应用阴影 (和box-shadow 格式一样)</li><li><blockquote><p>四个值分别 :水平阴影(px)、垂直阴影 (px)、模糊距离(px)，以及阴影的颜色</p></blockquote></li><li>word-break  指定了单词怎样断行</li><li><blockquote><p>有些英语单词单纯断行影响阅读</p></blockquote></li></ul></li><li><p>字体</p><ul><li>@font-face 规则   应用时设置font-family: name 使用自己设置的名字<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;ciclefina&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.eot&#x27;</span>);<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.eot?#iefix&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.woff2&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.woff&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),<br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/cicle_fina-webfont.svg#ciclefina&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;svg&#x27;</span>);<br>  <span class="hljs-attribute">font-weight</span>: normal;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>渐变</p><ul><li> linear-gradient()函数创建  </li><li><blockquote><p> background: linear-gradient(to bottom right, blue, pink);  第一个参数可选 也可以替换成角度  颜色参数也可以是多种颜色  可以控制结束为止,渐变中心… 在使用角度的时候, 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右</p></blockquote></li></ul></li></ul><h3 id="CSS-变形-transforms"><a href="#CSS-变形-transforms" class="headerlink" title="CSS 变形 (transforms)"></a>CSS 变形 (transforms)</h3><ul><li><p>transform-origin 指定原点的位置,默认值为元素的中心，可以被移动</p></li><li><p>适用于三维的属性</p><blockquote><p>首先需要设置的属性是透视值（perspective）。透视正是三维空间的立体感的源泉。元素与观察者之间的距离越远，他们就越小。  CSS 属性 perspective 可以更加真实3d的变换效果,一般放在变换图像外的容器写</p></blockquote><blockquote><p>通过 perspective-origin 属性来设置。默认透视值中，为观察者被置于中心，但是这并不总是适当的。<br>CSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。如果选择平面，元素的子元素将不会有 3D 的遮挡关系。<br> backface-visibility 指定当元素背面朝向观察者时是否可见。</p></blockquote></li></ul><ul><li><p>以下为transform利用函数</p><ul><li><p>translate()   偏移</p></li><li><blockquote><p>元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标）  translatex()  translatey()</p></blockquote></li><li><p>rotate() 平面旋转 参数给与度数</p></li><li><blockquote><p>元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转 rotateX() 围绕x轴旋转多少度  rotateY()  以上两个旋转都是围绕某个轴的<strong>立体旋转</strong></p></blockquote></li><li><blockquote><p>这里所有的3d坐标系, 都是y轴是竖直的,z轴则是向屏幕里的方向</p></blockquote></li><li><p>scale()  </p></li><li><blockquote><p>元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴） 当超出 [-1, 1]范围外时，缩放将在坐标方向上放大元素 如果为负值会反射(反方向投射)</p></blockquote></li><li><p>skew() </p><blockquote><p>一个元素在二维平面上的倾斜转换</p><ul><li>transform-origin  指明元素变形的远点</li></ul></blockquote></li></ul></li></ul><h3 id="CSS过渡-transitions"><a href="#CSS过渡-transitions" class="headerlink" title="CSS过渡 (transitions)"></a>CSS过渡 (transitions)</h3><ul><li><p>transition 提供了一种在更改CSS属性时控制动画速度的方法</p></li><li><p>想让一个元素的属性 transition起来 , 必须要先有预设值, 比如div元素 想要变换width, 那么div元素必须首先定义width,然后通过覆盖/ 添加类名的方式改变width 才可以, 如果一开始div没有width值, 通过添加类给与width值, 这时候是不发生变幻的</p><blockquote><p> 定义 transition:width 2s, height 2s, transform 2s 定义的样式后面书写时间  简写属性</p></blockquote></li><li><p>transition-delay<br>指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</p></li><li><p>transition-duration 变换时间<br>-transition-timing-function 指定一个函数，定义属性值怎么变化</p></li><li><p>当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend</p></li><li><blockquote><p>如果需要循环，查看 animation</p></blockquote></li><li><p>transition 是非常好的工具，可以让 JavaScript 效果平滑而不用修改 JavaScript</p></li><li><p>书写多个过渡效果时，每个完整的要用逗号隔开</p></li><li><p>触发过渡效果,只需要某个属性更改值,这时就会触发,比如 hover写新值,每次移入移出时都能触发过渡,js给标签添加新类也行</p></li></ul><blockquote><p>当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd. propertyName字符串，指示已完成过渡的属性。 elapsedTime 浮点数，指示当触发这个事件时过渡已运行的时间</p></blockquote><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><p>使用keyframes定义动画序列:@keyframes中补写关键帧 from{} to{},</p></li><li><p>animation 简写属性</p><pre><code>animation-duration  设置动画一个周期的时长animation-timing-function 定义CSS动画在每一动画周期中执行的节奏(匀速/先快后慢...)animation-direction  设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行animation-delay 延迟animation-iteration-count 设置动画重复次数， 可以指定infinite无限次重复动画animation-name  指定由@keyframes描述的关键帧名称    </code></pre><blockquote><p> animation: 3s ease-in 1s 2 reverse both paused slidein    animation属性的最后slidein一定为动画名字由@keyframes 定义</p></blockquote></li><li><p>哪些 CSS 属性可以动画?  关注可动画属性列表 对CSS转换同样适用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3 布局总览</title>
    <link href="/2020/12/13/Css/CSS3-%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88/"/>
    <url>/2020/12/13/Css/CSS3-%E5%B8%83%E5%B1%80%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="布局拾忆"><a href="#布局拾忆" class="headerlink" title="布局拾忆"></a>布局拾忆</h2><ul><li>正常布局流,以下行为覆盖默认的布局流<ul><li>display 标准的有block inline , 其他的布局形式: </li><li>css Grid </li><li>Flexbox(弹性盒子)</li><li>position</li><li>多列布局</li><li>表格布局</li><li>float</li></ul></li><li>响应式布局</li></ul><h3 id="Flexbox-弹性盒子-专门设计出来用于创建横向或是纵向的一维页面布局"><a href="#Flexbox-弹性盒子-专门设计出来用于创建横向或是纵向的一维页面布局" class="headerlink" title="Flexbox(弹性盒子) : 专门设计出来用于创建横向或是纵向的一维页面布局"></a>Flexbox(弹性盒子) : 专门设计出来用于创建横向或是纵向的一维页面布局</h3><ul><li><p>flex 优势(出现的原因):使多列等高(不管内容)  所有子项有相同的宽/高度(不论还有多少宽高)  父元素中垂直居中块内容</p></li><li><p>flex布局 占用的空间是在设置 padding 和 margin 之后剩余的空间 即尺寸都是内容尺寸 弹性盒子的真正价值可以体现在它的灵活性/响应性 ,flex布局是弹性的 根据排列方式 对你的width进行增加 删除(所以设置的width不一定就按照这个)</p></li><li><p>flex-direction:column  指定主轴方向,默认row排成一排</p></li><li><p>flex-grow : 它指定了flex容器中剩余空间的多少应该分配给项目。剩余的空间是flex容器的大小减去所有flex项的大小加起来的大小</p></li><li><p>flex-basis: 元素的最低的一个值,根据元素的多少会变大(不会变小因为是先减去这个初始大小进行计算的宽/高度)</p></li><li><p>flex-wrap : nowrap  控制flex items换行,这里换行不是在指标签中的内容,而是容器中每个flex元素,每个flex元素看做一个整体控制进行换行否</p></li><li><p>flex (缩写):  flex-grow flex-shrink flex-basis      </p><blockquote><p>行内元素为弹性盒子,可以设置为inline-flex<br>flex-flow(缩写) : flex-direction flex-wrap<br>flex-basis: auto,auto将使用宽度 width作为flex-basis值。</p></blockquote></li><li><p>align-items 控制 flex 项在交叉轴上的位置,默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器, 如果父元素没有固定高度,那就和最长的那一列高度相等</p></li><li><blockquote><p>center 值会使这些项保持其原有的高度，但是会在交叉轴居中</p></blockquote></li><li><blockquote><p>align-self  可以覆盖align-items 一般用来设置某个特定的元素使用</p></blockquote></li><li><p>justify-content 控制 flex 项在主轴上的位置。默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处。 </p></li><li><blockquote><p>space-around ——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。 space-between 则不会再两端留有空间</p></blockquote></li></ul><ul><li>利用order 进行flex 项排序 ,默认值为0 order小的显示顺序在前 可以为负值</li></ul><h3 id="Grid布局-在两个维度把元素按行和列-排列整齐"><a href="#Grid布局-在两个维度把元素按行和列-排列整齐" class="headerlink" title="Grid布局 在两个维度把元素按行和列 排列整齐"></a>Grid布局 在两个维度把元素按行和列 排列整齐</h3><ul><li><p>通过display:gird转到grid布局,分别使用grid-template-rows/columns 两个属性定义一些行/列的大小</p><ul><li>grid-template-rows :规定每一行的高度,有几行写几个值,如果元素内容超过此高度,就会溢出</li><li>grid-template-columns :规定每一列的宽度,宽度内不会溢出内容</li><li><blockquote><p>默认你会看到列的高度调整为与最高的容器一样高<br>grid-template-columns: repeat(12, 1fr);创建12列等宽<br>fr 单位——这个为网格布局定义的单位,如果所有列都是1fr，它们将占用相等的空间量。这消除了计算百分比以创建灵活网格的需要。</p></blockquote></li></ul></li><li><p>利用 grid-column 和 grid-row 两个属性来指定元素跨越的列数/行数.</p></li><li><blockquote><p>grid-column: auto / span 6; 跨6列</p></blockquote></li><li><blockquote><p>grid-column:span 2/3 -&gt; 从第三基线向前扩展两行</p></blockquote></li><li><blockquote><p>grid-template-areas设置区域 ,用 grid-area  是设置行和列的grid-column/row的简写</p></blockquote></li><li><p>grid-gap 属性用来设置网格行与列之间的间隙</p></li></ul><blockquote><p>使用grip-row/column 时有时候会导致子项之间位置变化,这时候同时设置grip-row grip-column 两项保证位置不变的情况进行扩展</p></blockquote><ul><li>在不使用gird的情况下怎么创建网格布局: 可以利用div块 子元素的浮动属性,构建一个网格系统布局,但是这是固定的宽度,创建流体网格可以使用百分比设置宽度   flex也可以用来创建网格系统,但是flex仍然是一维设计的,用来处理网格还是需要计算width</li><li>第三方网格系统 :  Bootstrap 提供了独立的网格系统</li></ul><h3 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h3><p>-绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素</p><ul><li><p>absolute 定位 :元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。 没有非static祖先元素定位,则针对可视窗口定位(类似fixed)</p></li><li><blockquote><p>绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p></blockquote></li><li><p>绝对定位元素填充可用空间 :</p></li><li><blockquote><p>大多数情况下，height和width 被设定为auto的绝对定位元素，按其内容大小调整尺寸, 被绝对定位的元素可以通过指定top和bottom ，保留height未指定（即auto），来填充可用的垂直空间。它们同样可以通过指定left 和 right并将width 指定为auto来填充可用的水平空间。     当大小不足以满足上下 左右的px值时,top left优先级大于 rigtht bottom</p></blockquote></li><li><p>固定定位应用于视口(viewport)边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p></li><li><p>相对定位(relative positioning)让你能够把一个正常布局流(normal flow)中的元素从它的默认位置按坐标进行相对移动。</p></li><li><p>固定定位fixed：对于浏览器可视窗口进行定位</p></li><li><p>粘性定位(sticky position)  元素根据正常文档流进行定位，然后相对它的最近滚动祖先,无法做到能够随意在页面像absolute那样定位, 正常文档流,简单理解粘性定位,是针对外围的父元素(作为容器)进行定位</p></li></ul><blockquote><p>left rigth 的值如果是百分比,则是非static定位的祖先元素的宽度   top bottom则是高度的百分比<br>z-index属性。 “z-index”是对z轴的参考 ,当元素开始重叠，什么决定哪些元素出现在其他元素的顶部</p></blockquote><ul><li>定位层级z-index：在重叠时决定谁在上面<br>对于<strong>定位元素</strong>来说通过定义层级来决定谁的层级高<br>默认后者高于前者 <strong>同级的元素才有可比性</strong>,父子元素之间的z-index是失效的(除非子元素设置负值父元素设置auto)</li><li>对于同级元素说,z-index根据数值大小进行排列</li><li>z-index 也支持过渡效果,它没有在每一步改变它的值(没有渐变效果)，所以你认为它没有过渡效果，但实际上是有的<blockquote><p>对于float元素 z-index还有更复杂的状况.详细查询资料</p></blockquote></li></ul><h3 id="多列布局-通常也简写为-multicol"><a href="#多列布局-通常也简写为-multicol" class="headerlink" title="多列布局 通常也简写为 multicol"></a>多列布局 通常也简写为 multicol</h3><ul><li>column-count    column-width 属性把块变为多列容器<blockquote><p>column-width  浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p></blockquote></li><li>Multicol 创建的列无法单独的设定样式。 不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。<ul><li> column-gap 改变列间间隙。</li><li> column-rule 在列间加入一条分割线。</li></ul></li><li>多列布局的内容因为空间问题(分配内容是按一列一列的填充)被拆成多个内容(称为内容折断)  通过属性break-inside: avoid 在内容(子元素)中添加防止</li></ul><h5 id="float-浮动"><a href="#float-浮动" class="headerlink" title="float 浮动"></a>float 浮动</h5><ul><li><p>浮动后,文本和内联元素环绕它,如果文本或者内联元素包裹在div中,那么仍然会环绕它,(块级元素不会换行,除非div块中还有块级元素,块级元素后还有内容),</p></li><li><p>行级元素可以设置宽高有了块级元素的特征 ，不设置时有内容撑开元素<br>浮动元素向指定方向移动，直到遇见边框。<br>浮动元素浮动时子元素撑开父元素 (创建bfc时才行)</p></li><li><p>浮动元素会提升层级压住标准元素</p></li><li><p>clear 属性适用于浮动和非浮动元素。 clear方法可以让浮动元素撑开父容器</p></li></ul><h3 id="正常文档流"><a href="#正常文档流" class="headerlink" title="正常文档流"></a>正常文档流</h3><ul><li>取得元素的内容来放在一个独立的元素盒子中，然后在其周边加上内边距、边框和外边距 — 就是我们之前看到的盒子模型。</li><li>默认的，一个块级元素的内容宽度是其父元素的100%，其高度与其内容高度一致。行内元素的height width与内容一致,你无法设置行内元素的height width</li></ul><h3 id="表格布局-通常用于老的不支持-弹性盒子的浏览器"><a href="#表格布局-通常用于老的不支持-弹性盒子的浏览器" class="headerlink" title="表格布局(通常用于老的不支持 弹性盒子的浏览器)"></a>表格布局(通常用于老的不支持 弹性盒子的浏览器)</h3><ul><li>display: table  display: table-row ..</li></ul><hr><p>(待实践…)</p><h3 id="传统的布局方法"><a href="#传统的布局方法" class="headerlink" title="传统的布局方法"></a>传统的布局方法</h3><ul><li>我们在宽度的表示上都用的是百分比,这创建了一个流动布局（liquid layout），能够适应不同的屏幕大小，这是响应式网页非常有价值的一个工具。</li><li>固定宽度网格,通过浮动和div块固定的width创建一个网格</li><li>创建液态网格(弹性（流体）的网格),把固定宽度转为伸缩的基于百分比宽度的算式在下面：</li><li><blockquote><p>target (目标列长度)/ context (上下文)= result  你可以用 calc() 函数来在CSS里面做数学方面的计算</p></blockquote></li><li>我们挪动小数点两位，得到百分数,在css中我们使用百分比代替固定数值</li><li><blockquote><p>这个系统的最大限制是，它本质上是一维的。我们在处理列、让元素跨越列，但是处理不了行。如果不设置一个确定的高度，用老方法很难控制元素高。这个方法很不灵活 —它只有在你确定你的内容有个明确的高的情况下有用。</p></blockquote></li></ul><h3 id="旧浏览器支持"><a href="#旧浏览器支持" class="headerlink" title="旧浏览器支持"></a>旧浏览器支持</h3><ul><li>在CSS中构建回滚 CSS规范包含了在一个物件上同时应用两种布局的时候，解释浏览器反应的信息</li><li>特性查询  允许测试一个浏览器是否支持特定的一个css特性</li><li>测试旧浏览器</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS指导</title>
    <link href="/2020/12/13/Css/CSS%E6%8C%87%E5%AF%BC/"/>
    <url>/2020/12/13/Css/CSS%E6%8C%87%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS-指南"><a href="#CSS-指南" class="headerlink" title="CSS 指南"></a>CSS 指南</h3><h4 id=""><a href="#" class="headerlink" title=""></a><!doctype html></h4><ul><li><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“**怪异模式(兼容模式)**”的渲染模式。“<!DOCTYPE html>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></li><li><p>兼容模式下 会出现很多问题, 比如 css应用问题, 加上标签和不加标签可能会出现差异,不如各个浏览器排版会出现问题</p><h4 id="css引用方法"><a href="#css引用方法" class="headerlink" title="css引用方法"></a>css引用方法</h4></li></ul><ol><li>行内式 </li><li>内嵌式  在head标签中书写《style》</li><li>链接式  《link href  rel  type》<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4></li></ol><ul><li><p>选择器：基本选择器</p><pre><code>  元素选择器、  类选择器、格式.   id选择器 格式：#   伪类/元素选择器 格式--&gt;标签：伪类  标签 ::伪元素     通用选择器 格式 *</code></pre></li><li><p>复合选择器（对基本选择器的组合使用）</p><pre><code>  交集选择器 格式：中间无空格   并集选择器(对于多个标签同时修饰) 格式：,  后代选择器  格式：中间加空格    子元素选择器：格式：标签&gt;标签   相邻兄弟选择器(拥有相同的父元素) 格式：+  属性选择器：格式 ：标签[属性]   </code></pre><blockquote><p>子元素选择器范围比后代更小<br>一个页面只能有一个独特的ID，但是很多元素都有相同的类 </p></blockquote></li><li><p>伪类选择器不能被嵌套  ，他们不能被当作 :not() 中的参数 ，形如 :not(p::before) 这样的选择器将不会工作。</p></li><li><h4 id="css样式规则"><a href="#css样式规则" class="headerlink" title="css样式规则"></a>css样式规则</h4></li></ul><ol><li>优先级  id&gt;class&gt;…  那个选择器更具体 那个优先级就高</li></ol><ul><li>为目标元素直接添加样式，永远比继承样式的优先级高，无视优先级的遗传规则。从上面结果不难看出 行间style &gt; 后代 &gt; id &gt; class &gt; 元素<blockquote><p>判断优先级，以权重为指标，权重越大优先级越高：一般约定 id选择器的权重为100，类选择器权重为10，元素选择器权重为1。一个复杂的选择器的权重,例如后代选择器 ID选择器 元素选择器 权重为101,</p></blockquote></li></ul><ol><li><p>层叠  当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</p></li><li><p>继承  设置在父元素上的css属性是可以被子元素继承的，有些不行不如width border…</p><pre><code> 控制继承:  inherit 开启继承,浏览器默认值 inherit  unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样       all: unset:重设所有属性值</code></pre></li><li><p>!important打破优先级使用该属性 覆盖!important 唯一的办法就是另一个 !important  </p></li></ol><ul><li><p>有继承性的属性</p><pre><code>  font  text-indent：文本缩进  text-align：文本水平对齐  visibility:隐藏  line-height：行高  word-spacing：增加或减少单词间的空白（即字间隔）  letter-spacing：增加或减少字符间的空白（字符间距）  text-transform：控制文本大小写  direction：规定文本的书写方向  color</code></pre></li><li><p>@import  @media<br>font, background, padding, border, andmargin等属性称为速记属性</p></li></ul><h4 id="盒子模型-–参考MDN"><a href="#盒子模型-–参考MDN" class="headerlink" title="盒子模型  –参考MDN"></a>盒子模型  –参考MDN</h4><ul><li><p>基本盒子分为：块级盒子（Block box） 和 内联盒子（Inline box） </p></li><li><p>css的box模型有内部和外部显示类型 ，外部显示类型，来决定盒子是块级还是内联。同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局 </p></li><li><p>如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。</p></li><li><p>内联盒子的特征，width height无效，就是说内联盒子的内容大小不会发生改变，</p><blockquote><p>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 如果碰见边界的话设置垂直padding,也不会应用<br>水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。</p></blockquote></li><li><p>盒子模型分为 标准盒模型 替代盒模型 ，区别在于标准盒模型计算盒子大小是需要加上 padding border</p><blockquote><p>盒子大小是border以内的值不包括margin<br>如果使用替代盒模型 需要html设置，全部改为替代模型</p></blockquote></li></ul><p>-</p><ul><li>display: inline-block 不希望一个项切换到新行，但希望它可以设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。  外部仍然为inline的状态 <blockquote><p>inline或者block，来控制盒子的外部显示类型<br>flex属性：内部显示属性  内联显示，外部显示类型为块级元素</p></blockquote></li><li>inline-flex：内外部为内联属性  但是和inline属性有点差别</li></ul><ul><li><p>内边距 padding特点：</p><pre><code>  撑大元素的尺寸，上下左右多出padding设置值，也就是2*padding  背景会随着撑大元素的尺寸而扩大</code></pre></li></ul><h5 id="盒子模型是否被内容撑开的问题"><a href="#盒子模型是否被内容撑开的问题" class="headerlink" title="盒子模型是否被内容撑开的问题"></a>盒子模型是否被内容撑开的问题</h5><ul><li><p>块级元素不能正好的撑开内联元素,而是外部的内联元素会变得超级大,所谓内容决定内联元素的宽度指的是文字,图片img元素也不能撑开内联元素 ,(内联元素无法撑开内联元素,通过嵌套span考证,个人理解,内联元素只能被文本撑开)  如果想要撑开,就把外层的内联元素换成 inline-black元素</p></li><li><p>内联元素撑开块级元素,带有文档的内联元素可以撑开块级元素,不带有文字的内联元素,比如img 不能正好的撑开块级元素,会有缝隙,解决方法:设置内部为块级元素就可以撑开 或者固定块级元素高度</p></li><li><p>只有块级元素能正好的撑开元素</p></li><li><p>三层嵌套 依次块级元素 内联元素 块级元素  按照以上分析  最内层的块级元素不能正好撑开内联元素,但是可以正好撑开最外部的块级元素 </p></li><li><p>块级元素在内联元素中,不再影响内联元素外的元素 </p></li></ul><h5 id="外边距margin-折叠"><a href="#外边距margin-折叠" class="headerlink" title="外边距margin 折叠"></a>外边距margin 折叠</h5><blockquote><p>创建新的BFC避免两个相邻 &lt; div&gt; 之间的外边距合并问题   </p></blockquote><blockquote><p>注意有设定float和position=absolute的元素不会产生外边距重叠行为。脱离文档流不存在此问题</p></blockquote><ol><li><p>同一层相邻元素之间的外边距重叠</p><pre><code> 外边距合并：相邻元素margin-top 和margin-bottom 长度会合并成两者间较大的数值，如果有负值就是两者的和,两者都为负值就取绝对值最大的 解决: 后一个元素加上clear-fix清除浮动。</code></pre></li><li><p>没有内容将父元素和后代元素分开</p><pre><code> 父子元素外边距合并：如果没有边框border，内边距padding，行内内容(背景也算内容)，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top； 父子元素上外边距会合并,较大的值最终会溢出到父级块元素外面。表现为父元素向下推了子元素多出来的值</code></pre></li></ol><ol start="3"><li><p>空白div块</p><pre><code> 假设有一个空元素，它有外边距，但是没有边框或填充 高度 inline clear-fix。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。</code></pre></li></ol><h5 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h5><ul><li>块格式化上下文（Block Formatting Context，BFC)，<strong>是块盒子的布局过程发生的区域</strong>，也是浮动元素与其他元素交互的区域。<blockquote><p>块格式上下文 最主要的目的:  对浮动元素的限制  清除浮动的范围,块格式上下文有点像一个针对浮动元素的容器</p></blockquote></li></ul><ul><li>浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</li><li>一个新的 display 属性的值，它可以创建无副作用的 BFC。在父级块中使用 display: flow-root 可以创建新的 BFC。</li></ul><ul><li>overflow 值不为 visible 的块元素 绝对定位元素  行内块元素 浮动元素…<blockquote><p>更多创建bfc方法参考 MDN  </p></blockquote></li></ul><ul><li><p>clearfix方法</p></li><li><p>如果一个元素里只有浮动元素，那它的高度会是0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-pseudo">::after</span> &#123; <br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="高度塌陷和BFC"><a href="#高度塌陷和BFC" class="headerlink" title="高度塌陷和BFC"></a>高度塌陷和BFC</h6></li><li><p>在文档流中，父元素的高度默认是被子元素撑开的，当为子元素设置浮动以后，子元素会完全脱离文档流，此时就会导致子元素无法撑起父元素的高度，此引发父元素的高度塌陷</p></li><li><p>解决塌陷方法:创建一个会包含这个浮动的BFC:</p></li></ul><h5 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h5><ul><li><p>content-box(默认值),设置宽高仅仅是内容的, 任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p></li><li><p>border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。</p></li></ul><h4 id="隐藏标签"><a href="#隐藏标签" class="headerlink" title="隐藏标签"></a>隐藏标签</h4><ul><li>display:none —不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。</li><li>visible:hidden— 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。这是个继承元素</li><li>元素使用visibility:hidde时 如果在设置:hover状态,这是不会触发,因为这时已经隐藏不可能触发</li><li>opacity : 0 , 不可见,但保留位置</li></ul><h4 id="行内元素-可替换元素"><a href="#行内元素-可替换元素" class="headerlink" title="行内元素 可替换元素"></a>行内元素 可替换元素</h4><ul><li><p>一般情况下，行内元素只能包含数据和其他行内元素。行内元素列表</p><p>  b, big, i, small, tt<br>  abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var<br>  a, bdo, br, img, map, object, q, script, span, sub, sup<br>  button, input, label, select, textarea</p></li><li><p>可替换元素可以设置宽高,css对可替换元素的影响在 内容在框中的位置和定位方式  可替换元素</p><pre><code>  &lt;iframe&gt;  &lt;video&gt;  &lt;embed&gt;  &lt;img&gt;</code></pre><blockquote><p>“image” 类型的 &lt; input&gt; 元素就像&lt; img&gt;一样被替换。 </p></blockquote></li></ul><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><ul><li><p>根据各种设备特征和参数的值或者是否存在来调整您的网站或应用,它们是响应式设计的关键组成部分。</p></li><li><p>在html中应用媒体查询 : 在&lt; link&gt;元素的media属性中，它们定义了待应用链接资源（通常是CSS）的媒体。   在&lt; style&gt;元素的media属性中，它们定义待应用样式的媒体。</p></li><li><p> 在 CSS 中，使用 @media at-rule 根据媒体查询的结果有条件地应用样式表的一部分。 使用 @import 条件地应用整个样式表。</p><blockquote><p>格式  @media media-type 媒体类型(4种) and (media-feature-rule 媒体特性) { }<br>媒体类型: 告诉浏览器这段代码是用在什么类型的媒体上的  媒体查询中存在逻辑运算</p></blockquote></li><li><p>在 JavaScript 中使用媒体查询   使用 Window.matchMedia() 方法根据媒体查询测试窗口 MediaQueryList.addListener()在查询状态发生变化时收到通知  DOM 提供了通过编程方法来获得媒体查询结果的特性   具体参看MDN</p></li></ul><blockquote><p>使用媒体查询 需要参考 媒体特性  详情查询MSN @media</p></blockquote><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><ul><li><p>指的是允许Web页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践</p><blockquote><p>需要你理解的很重要的一点是响应式Web设计不是单独的技术,它是用来建立可以响应查看内容的设备的样式的一个词。</p></blockquote></li><li><p>响应式设计是三种技术的混合使用。第一个是液态网格,第二个是液态图像的理念,第三个关键的组件是媒体查询</p><ul><li>媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将CSS选择性地适应用户的需要应用在样式化页面上。</li></ul></li><li><p>你真的需要媒体查询吗？</p><blockquote><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。</p></blockquote></li></ul><ul><li><p>响应式设计方法: </p><pre><code>   你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做移动优先的响应式设计，很多时候是最值得仿效的做法。</code></pre></li></ul><ul><li>响应式图像 <ul><li>使用max-width : 100% 设置img ,这种方式的弊端显而易见,图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽(手机端不需要这么大的文件)</li><li>使用了&lt; picture&gt;元素 或者&lt; img&gt; srcset和sizes 特性 浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。 (详情查看picture)</li></ul></li></ul><ul><li>响应式排版(针对文本)</li><li>使用视口单位(vw)实现响应式排版,文本内容使用vw根据视口大小变化</li><li><blockquote><p>永远都不要只用viewport单位设定文本。这样会导致文本内容一直随着视口变化,没有了一个最低变化的限度,内容不能够放缩(通过改变宽度导致内容缩在边框之外)  将vw单位加到了使用固定大小解决</p></blockquote></li></ul><ul><li>视口元标签 &lt; meta name=”viewport” content=”width=device-width,initial-scale=1”&gt;</li><li><blockquote><p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度,为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为960像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本</p></blockquote></li></ul><h4 id="Css-条件规则组"><a href="#Css-条件规则组" class="headerlink" title="Css 条件规则组"></a>Css 条件规则组</h4><ul><li><p>格式 @ + name</p><h3 id="CSS-指北-–参考MDN"><a href="#CSS-指北-–参考MDN" class="headerlink" title="CSS 指北  –参考MDN"></a>CSS 指北  –参考MDN</h3><h4 id="样式化-文本"><a href="#样式化-文本" class="headerlink" title="样式化 (文本)"></a>样式化 (文本)</h4></li><li><p>字体种类<br>   网页安全字体 font-family 的例子</p></li><li><p>字体大小</p><ul><li>1em 等于我们设计的当前元素的父元素上设置的字体大小 </li><li><blockquote><p>font-size是一个继承属性</p></blockquote></li><li>浏览器的font-size 默认的值为 16px,其他元素也许有默认的大小，比如&lt; h1&gt;元素有一个 2em 的默认值，所以它的最终大小值为 32px</li><li><blockquote><p>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小 rem 不支持 Internet Explorer 8 和以下的版本</p></blockquote></li></ul></li><li><p>四种属性改变文本样式</p><pre><code>font-style 打开关闭斜体font-weight 设置字体粗细text-decoration  设置文本划线text-transform: 允许你设置要转换的字体 比如大小写,全半角 </code></pre></li><li><p>text-shadow 文本阴影</p></li><li><p>文本布局</p><pre><code>  text-align 属性定义行内内容（例如文字）如何相对它的块父元素(内容盒子)对齐,这里的行内内容不一定是文字,可能是a标签.  line-height 行高,设置文本每行之间的高 设置无单位的值 例如:1.5 1.5乘以font-size得到的是行高  letter-spacing  字母之间间距  word-spacing 单词与单词之间的间距  text-indent: 指定文本内容的第一行前面应该留出多少的水平空间。  text-overflow: 定义如何向用户表示存在被隐藏的溢出内容。  white-space: 定义如何处理元素内部的空白和换行。  word-break: 指定是否能在单词内部换行。  text-orientation: 定义行内文本的方向。  word-wrap: 指定浏览器是否可以在单词内换行以避免超出范围。  writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</code></pre></li></ul><ul><li><p>height = line-height时 文字垂直居中显示</p></li><li><p>内联元素的高度有其中的文本内容 的font-size line-height共同决定, 如果字体大小比行高小一定的值,那高度就是行高</p></li><li><p>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。</p></li><li><p>text-indent 属性能定义一个块元素首行文本内容之前的缩进量。设置负值用来移出文档显示,块内元素中如果有内联元素例如 img span等,会移出文档,  该属性为继承属性 ,对内联元素中的内容无效</p></li><li><p>vertical-align 用于以下两种情况  1.使行内元素盒模型与其行内元素容器垂直对齐</p></li><li><p>2.垂直对齐表格单元内容:</p></li><li><p>vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。</p></li><li><p>margin取负值margin-left 和 margin-top：影响自身元素，自身元素将向指定方向偏移margin-bottom将影响后元素，使后元素向上偏移对应像素</p></li></ul><h4 id="样式化列表"><a href="#样式化列表" class="headerlink" title="样式化列表"></a>样式化列表</h4><pre><code>    &lt;ul&gt;和&lt;ol&gt;元素默认设置margin的顶部和底部    &lt;li&gt;  默认是没有设置间距的    &lt;dl&gt;元素默认设置 margin的顶部和底部: 16px(1em) ，无内边距设定    &lt;dt&gt;     &lt;dd&gt; 元素设置为： margin-left  40px (2.5em)。           list-style-type ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。    list-style-position ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。    list-style-image ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。    速记属性 list-style 完成以上三个的设置</code></pre><ul><li>管理列表技术  <ul><li>ul ol上的属性    </li><li>start 属性允许你从1 以外的数字开始计数  </li><li>reversed 属性将启动列表倒计数</li><li>value 属性允许设置列表项指定数值</li></ul></li></ul><h4 id="样式化链接"><a href="#样式化链接" class="headerlink" title="样式化链接"></a>样式化链接</h4><ul><li>链接状态 通过伪类进行设置<ul><li>Link (没有访问过的): 这是链接的默认状态 </li><li>Visited: 这个链接已经被访问过了</li><li>Hover: 当用户的鼠标光标刚好停留在这个链接</li><li>Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab  移动到这个链接的时候)</li><li>Active: 一个链接当它被激活的时候 (比如被点击的时候)</li></ul></li><li>在链接中包含图片 通过background</li><li>样式化链接为按钮 </li></ul><h4 id="网络字体"><a href="#网络字体" class="headerlink" title="网络字体"></a>网络字体</h4><ul><li>在CSS的开始处有一个@font-face块，它指定要下载的字体文件</li></ul><h4 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h4><ul><li><p>使用 table-layout: fixed 创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。</p></li><li><blockquote><p>默认情况下表格及单元格的宽度取决于其包含的内容。</p></blockquote></li><li><p>使用 border-collapse: collapse 使单元格边框塌陷,使得多个边框合并成一条</p></li><li><p>caption-side属性 : 会将表格的标题&lt; caption&gt; 放到规定的位置</p></li><li><p>使用样式化文本的属性来对表格中的文字格式样式化,加上字体/背景色,完成了样式化的工作</p><h4 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h4></li><li><p>background 属性</p><pre><code>-clip  设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。三个参数为:border-box  padding-box padding-box-color  设置背景色  关键字transparent-image 用于为一个元素设置一个或者多个背景图像 url()-origin 指定背景图片的原点位置,从border开始 border-box;从内边距开始 padding-box;从内容开始 content-box;  (默认在左上角)- position 为每一个背景图片设置初始位置。这个位置是相对于由 background-origin 定义的位置图层的。如果被定义为两个值，那么第一个值代表水平位置，第二个代表垂直垂直位置。百分比值的偏移指定图片的相对位置和容器的相对位置重合。值0%代表图片的左边界（或上边界）和容器的左边界（上边界）重合。值100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值50%则代表图片的中点和容器的中点重合 关键字 center，用来居中背景图片。(并非把图片移动到中间显示) 关键字 top, left, bottom, right 中的一个。用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，- repeat 定义背景图像的重复方式 背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。- size   设置图片大小;  1个值,这个值指定图片的宽  2个值 宽和高;- 关键字cover 拉伸到新的尺寸覆盖容器全部空间  contain 按原有比例缩放到可用空间的尺寸,不一定能够覆盖完容器  - attachment 决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。 fixed表示背景相对于视口固定背景不会随着内容滚动 local 随着内容滚动    scroll 相对于内容固定,对于外部元素随之滚动  </code></pre></li></ul><ul><li><p>opacity属性指定了一个元素的透明度, 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待, 即使这个值没有被子元素继承</p></li><li><blockquote><p>因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值</p></blockquote></li><li><p>使用opacity属性，当属性值不为1时，会把元素放置在一个新的层叠上下文中。</p></li></ul><h4 id="处理不同方向的文本"><a href="#处理不同方向的文本" class="headerlink" title="处理不同方向的文本"></a>处理不同方向的文本</h4><ul><li>CSS中的书写模式是指文本的排列方向是横向还是纵向的。</li><li>writing-mode 属性使我们从一种模式切换到另一种模式,horizontal-tb模式,水平方式写入，写入方向从top到bottom</li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul><li>CSS中万物皆盒，因此我们可以通过给width和height（或者 inline-size 和 block-size）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，</li><li>只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。</li><li>overflow属性是你控制一个元素溢出的方式，</li><li>溢出建立了块级排版上下文 BFC，你改变了overflow的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。</li></ul><h4 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h4><ul><li><p>在CSS中使用了各种数值数据类型 :数字 长度 百分比</p></li><li><p>长度分为绝对长度 相对长度(em  rem lh),相对长度单位相对于其他一些东西</p></li><li><p>如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p></li><li><p>如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。</p></li><li><p>关于使用百分比来确定 元素的高度宽度,  body,html 百分比,是针对浏览器可视窗口的宽度高度,对于body中嵌套的子元素,如果也使用百分比确定宽高,那么针对的也是可视窗口</p></li></ul><h4 id="调节项目大小"><a href="#调节项目大小" class="headerlink" title="调节项目大小"></a>调节项目大小</h4><ul><li><p>块级元素的行为就是这样的。它没有高度，或者说高度为0，因为内部没有内容</p></li><li><p>块级元素我们可以给它一个具体的 width 和 height 值, 然后不论我们放什么内容进去它都是该尺寸,如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出</p></li><li><p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p></li><li><p>如果你把margins和padding设置为百分数的话，你会注意到一些奇怪的表现。你也许会希望上下的外边距是元素高的一个百分数，左右外边距是元素宽的百分数。但是，情况不是这样的！所有的值都是以父容器的宽度来计算的</p></li><li><p>min-和max-尺寸 这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p></li><li><p> max-width的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。作为示例，如果你设定一个图像的属性为width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p></li><li><blockquote><p>如果你使用了max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的100%。这个技术是用来让图片可响应的</p></blockquote></li><li><p>我们有与视口尺寸相关的度量单位，即意为视口宽度的vw单位，以及意为视口高度的 vh单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。1vh等于视口高度的1%，1vw则为视口宽度的1%.你可以用这些单位约束盒子的大小</p></li></ul><h4 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h4><ul><li>图像和视频被描述为替换元素。 这意味着CSS不能影响这些元素的内部布局-仅影响它们在页面上于其他元素中的位置,</li><li>你可以对容器内的图像作其他选择，例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。</li><li>object-fit属性可以在这里帮助你。当使用object-fit时，替换元素可以以多种方式被调整到合乎盒子的大小。 cover  contain fill …</li><li>在替换元素使用各式CSS布局技巧时，你可能深切地体会到他们的展现略微与其他元素不同，例如，在一个flex或者grid布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
