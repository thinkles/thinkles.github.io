---

title:  JS事件循环
date: {{ date }}
updated: {{date}}
tags: js
categories: Javascript

---
### 事件循环

- JavaScript 有一个基于**事件循环**的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。

- 并发模型的解释:

  > 栈:  调用函数时创建元素压入栈,元素中包含参数和局部变量, 解析函数内容,如果函数内又调用了函数,那就再次压入栈,执行完之后弹出栈
  >
  > 堆: 当 JS 引擎解析JS代码的过程中遇到一些变量或者函数申明的时候，它会将它们存储到里面。
  >
  > 消息队列(回调函数队列): 存储待处理信息,每个信息是经过Web API 处理结束后的回调函数
  
- 大致过程:

  > 首先同步函数依次进入栈中进行调用,如果遇见异步函数就发送给web API 调用相应的模块进行处理(例如: 计时器有timer模块进行执行), 执行完成之后,发送给消息队列进行等待

- 事件循环:

  > 事件循环是一种机制，他不断的检查栈是否执行空, 如果栈执行空了把消息队列的第一个放入栈中处理,**函数的处理会一直进行到执行栈再次为空为止**,然后处理队列中的下一个消息

- 以上模型解释了两个问题:

  - 异步函数的执行顺序:   异步函数就算在同步函数内部, 执行也会在所有同步函数执行结束之后,才会执行

  - 计时器函数为什么不准确: 计时器时间值代表了消息被实际加入到队列的最小延迟时间。但是实际中执行该计时器需要等到同步函数结束,所以就算时间为0,也不代表立即执行

- 其他

  > 一个 web worker 或者一个跨域的 `iframe` 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 [`postMessage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) 方法进行通信。
  >
  > 由于历史原因有一些例外，如 `alert` 或者同步 XHR，但应该尽量避免使用它们,它会导致堵塞
  
  

### JS的单线程

- 当每一个消息被**完整**的处理完之后,才会执行其他的消息,

  > 其他多线程语言不同,资源不会被抢占,  对于多线程语言,可能函数执行时会被终止,来执行其他的任务, 
  >
  > JS的单线程处理方式导致它 永不堵塞
  >
  > 但是一个消息长时间才能处理完毕,我们必须等待而无法进行网页交互


- 多线程学习重点是要大量面对资源争抢与同步方面的问题 ，JS是单线程的可以避免此类问题
- 

### 宏任务/微任务队列    

- Es6 之后因为Promise 的原因,引入宏任务/微任务队列的概念

- 微任务: 微任务仅来自于我们的代码,它们通常是由 promise 创建的

  > 对  .then/catch/finally 处理程序的执行会成为微任务。await `的“幕后”
  >
  > 使用queueMicrotask(f) 可以安排一个微任务

- 宏任务: 就是平时我们说的消息队列

  > 细节: 页面`渲染`也算是宏任务队列的一个消息,所以引擎执行时永远不会进行渲染,只有当栈为空,才会进行渲染
  >
  > 所以在函数中对一个元素持续改变,然后渲染它,改变过程是看不到的,因为只有函数结束后,才会执行渲染任务

- **`每个`宏任务之后，引擎会立即执行微任务队列中的`所有`任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。**

- 微任务会一个接一个执行,中间没有其他任务

- 利用JS事件循环的模型, 宏任务/微任务的概念, 使用异步操作常见的三种操作

  > 拆分大任务, 不让CPU过载 
  >
  > 持续渲染页面 (进度指示)
  >
  > 在浏览器事件结束之后,再进行操作, 





- Promise

- promise 本质是同步函数返回的对象, 返回的对象再次调用回调函数,这是我们常见的形式

- 

- > new Promise() 同步函数,返回promise对象,而.then/catch/finally则是异步函数

- 