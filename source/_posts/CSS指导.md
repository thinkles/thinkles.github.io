---
title: CSS指导
date: 2020-12-13 19:59:06
tags: Css 基础
categories: 前端Css
---

### CSS 指南

#### <!doctype html>  
- 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“**怪异模式(兼容模式)**”的渲染模式。“<!DOCTYPE html>" 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。

- 兼容模式下 会出现很多问题, 比如 css应用问题, 加上标签和不加标签可能会出现差异,不如各个浏览器排版会出现问题
#### css引用方法 
1. 行内式 
2. 内嵌式  在head标签中书写《style》
3. 链接式  《link href  rel  type》
#### 选择器

- 选择器：基本选择器
        
        元素选择器、
        类选择器、格式. 
        id选择器 格式：# 
        伪类/元素选择器 格式-->标签：伪类  标签 ::伪元素   
        通用选择器 格式 *
- 复合选择器（对基本选择器的组合使用）
 
        交集选择器 格式：中间无空格 
        并集选择器(对于多个标签同时修饰) 格式：,
        后代选择器  格式：中间加空格  
        子元素选择器：格式：标签>标签 
        相邻兄弟选择器(拥有相同的父元素) 格式：+
        属性选择器：格式 ：标签[属性]   
>子元素选择器范围比后代更小           
>一个页面只能有一个独特的ID，但是很多元素都有相同的类 

- 伪类选择器不能被嵌套  ，他们不能被当作 :not() 中的参数 ，形如 :not(p::before) 这样的选择器将不会工作。

- 
#### css样式规则
1. 优先级  id>class>...  那个选择器更具体 那个优先级就高
- 为目标元素直接添加样式，永远比继承样式的优先级高，无视优先级的遗传规则。从上面结果不难看出 行间style > 后代 > id > class > 元素
>判断优先级，以权重为指标，权重越大优先级越高：一般约定 id选择器的权重为100，类选择器权重为10，元素选择器权重为1。一个复杂的选择器的权重,例如后代选择器 ID选择器 元素选择器 权重为101,
1. 层叠  当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。
2. 继承  设置在父元素上的css属性是可以被子元素继承的，有些不行不如width border...
 
        控制继承:  inherit 开启继承,浏览器默认值 inherit 
        unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样      
        all: unset:重设所有属性值
3. !important打破优先级使用该属性 覆盖!important 唯一的办法就是另一个 !important  
- 有继承性的属性

        font  text-indent：文本缩进
        text-align：文本水平对齐
        visibility:隐藏
        line-height：行高
        word-spacing：增加或减少单词间的空白（即字间隔）
        letter-spacing：增加或减少字符间的空白（字符间距）
        text-transform：控制文本大小写
        direction：规定文本的书写方向
        color

- @import  @media
  font, background, padding, border, andmargin等属性称为速记属性



#### 盒子模型  --参考MDN
- 基本盒子分为：块级盒子（Block box） 和 内联盒子（Inline box） 

- css的box模型有内部和外部显示类型 ，外部显示类型，来决定盒子是块级还是内联。同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局 
- 如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。

- 内联盒子的特征，width height无效，就是说内联盒子的内容大小不会发生改变，
>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 如果碰见边界的话设置垂直padding,也不会应用
>水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。

- 盒子模型分为 标准盒模型 替代盒模型 ，区别在于标准盒模型计算盒子大小是需要加上 padding border
  >盒子大小是border以内的值不包括margin
  >如果使用替代盒模型 需要html设置，全部改为替代模型

-

- display: inline-block 不希望一个项切换到新行，但希望它可以设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。  外部仍然为inline的状态 
  >inline或者block，来控制盒子的外部显示类型  
  >flex属性：内部显示属性  内联显示，外部显示类型为块级元素
 - inline-flex：内外部为内联属性  但是和inline属性有点差别


- 内边距 padding特点：
  
        撑大元素的尺寸，上下左右多出padding设置值，也就是2*padding
        背景会随着撑大元素的尺寸而扩大

##### 盒子模型是否被内容撑开的问题
- 块级元素不能正好的撑开内联元素,而是外部的内联元素会变得超级大,所谓内容决定内联元素的宽度指的是文字,图片img元素也不能撑开内联元素 ,(内联元素无法撑开内联元素,通过嵌套span考证,个人理解,内联元素只能被文本撑开)  如果想要撑开,就把外层的内联元素换成 inline-black元素

- 内联元素撑开块级元素,带有文档的内联元素可以撑开块级元素,不带有文字的内联元素,比如img 不能正好的撑开块级元素,会有缝隙,解决方法:设置内部为块级元素就可以撑开 或者固定块级元素高度
- 只有块级元素能正好的撑开元素
- 三层嵌套 依次块级元素 内联元素 块级元素  按照以上分析  最内层的块级元素不能正好撑开内联元素,但是可以正好撑开最外部的块级元素 
- 块级元素在内联元素中,不再影响内联元素外的元素 

##### 外边距margin 折叠
> 创建新的BFC避免两个相邻 < div> 之间的外边距合并问题   

> 注意有设定float和position=absolute的元素不会产生外边距重叠行为。脱离文档流不存在此问题

1. 同一层相邻元素之间的外边距重叠

        外边距合并：相邻元素margin-top 和margin-bottom 长度会合并成两者间较大的数值，如果有负值就是两者的和,两者都为负值就取绝对值最大的
        解决: 后一个元素加上clear-fix清除浮动。

2. 没有内容将父元素和后代元素分开

        父子元素外边距合并：如果没有边框border，内边距padding，行内内容(背景也算内容)，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top； 父子元素上外边距会合并,较大的值最终会溢出到父级块元素外面。表现为父元素向下推了子元素多出来的值


3. 空白div块
   
        假设有一个空元素，它有外边距，但是没有边框或填充 高度 inline clear-fix。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。
     

 
##### BFC
- 块格式化上下文（Block Formatting Context，BFC)，**是块盒子的布局过程发生的区域**，也是浮动元素与其他元素交互的区域。
> 块格式上下文 最主要的目的:  对浮动元素的限制  清除浮动的范围,块格式上下文有点像一个针对浮动元素的容器


- 浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。
- 一个新的 display 属性的值，它可以创建无副作用的 BFC。在父级块中使用 display: flow-root 可以创建新的 BFC。


- overflow 值不为 visible 的块元素 绝对定位元素  行内块元素 浮动元素...
> 更多创建bfc方法参考 MDN  


- clearfix方法
- 如果一个元素里只有浮动元素，那它的高度会是0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素

- 
```
#container::after { 
  content: "";
  display: block; 
  clear: both;
}
```
###### 高度塌陷和BFC  
       
- 在文档流中，父元素的高度默认是被子元素撑开的，当为子元素设置浮动以后，子元素会完全脱离文档流，此时就会导致子元素无法撑起父元素的高度，此引发父元素的高度塌陷

- 解决塌陷方法:创建一个会包含这个浮动的BFC:




##### box-sizing 属性 
- content-box(默认值),设置宽高仅仅是内容的, 任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。

- border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。


#### 隐藏标签
- display:none ---不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。
- visible:hidden--- 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。这是个继承元素
- 元素使用visibility:hidde时 如果在设置:hover状态,这是不会触发,因为这时已经隐藏不可能触发
- opacity : 0 , 不可见,但保留位置

#### 行内元素 可替换元素
- 一般情况下，行内元素只能包含数据和其他行内元素。行内元素列表
  
    b, big, i, small, tt
    abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var
    a, bdo, br, img, map, object, q, script, span, sub, sup
    button, input, label, select, textarea
- 可替换元素可以设置宽高,css对可替换元素的影响在 内容在框中的位置和定位方式  可替换元素
    
        <iframe>
        <video>
        <embed>
        <img>
>"image" 类型的 < input> 元素就像< img>一样被替换。 

#### 媒体查询
- 根据各种设备特征和参数的值或者是否存在来调整您的网站或应用,它们是响应式设计的关键组成部分。

- 在html中应用媒体查询 : 在< link>元素的media属性中，它们定义了待应用链接资源（通常是CSS）的媒体。   在< style>元素的media属性中，它们定义待应用样式的媒体。

-  在 CSS 中，使用 @media at-rule 根据媒体查询的结果有条件地应用样式表的一部分。 使用 @import 条件地应用整个样式表。
>格式  @media media-type 媒体类型(4种) and (media-feature-rule 媒体特性) { }\
> 媒体类型: 告诉浏览器这段代码是用在什么类型的媒体上的  媒体查询中存在逻辑运算

- 在 JavaScript 中使用媒体查询   使用 Window.matchMedia() 方法根据媒体查询测试窗口 MediaQueryList.addListener()在查询状态发生变化时收到通知  DOM 提供了通过编程方法来获得媒体查询结果的特性   具体参看MDN

> 使用媒体查询 需要参考 媒体特性  详情查询MSN @media

#### 响应式设计
- 指的是允许Web页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践
>需要你理解的很重要的一点是响应式Web设计不是单独的技术,它是用来建立可以响应查看内容的设备的样式的一个词。

- 响应式设计是三种技术的混合使用。第一个是液态网格,第二个是液态图像的理念,第三个关键的组件是媒体查询
  - 媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将CSS选择性地适应用户的需要应用在样式化页面上。

- 你真的需要媒体查询吗？
 > 弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。


- 响应式设计方法: 
        
         你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做移动优先的响应式设计，很多时候是最值得仿效的做法。




- 响应式图像 
  - 使用max-width : 100% 设置img ,这种方式的弊端显而易见,图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽(手机端不需要这么大的文件)
  - 使用了< picture>元素 或者< img> srcset和sizes 特性 浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。 (详情查看picture)


- 响应式排版(针对文本)
 - 使用视口单位(vw)实现响应式排版,文本内容使用vw根据视口大小变化
 - > 永远都不要只用viewport单位设定文本。这样会导致文本内容一直随着视口变化,没有了一个最低变化的限度,内容不能够放缩(通过改变宽度导致内容缩在边框之外)  将vw单位加到了使用固定大小解决


 - 视口元标签 < meta name="viewport" content="width=device-width,initial-scale=1">
 - >这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度,为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为960像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本

#### Css 条件规则组
- 格式 @ + name
### CSS 指北  --参考MDN
#### 样式化 (文本)
- 字体种类
     网页安全字体 font-family 的例子
- 字体大小
  - 1em 等于我们设计的当前元素的父元素上设置的字体大小 
  - >font-size是一个继承属性
  - 浏览器的font-size 默认的值为 16px,其他元素也许有默认的大小，比如< h1>元素有一个 2em 的默认值，所以它的最终大小值为 32px
  - >rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小 rem 不支持 Internet Explorer 8 和以下的版本

- 四种属性改变文本样式
     
      font-style 打开关闭斜体
      font-weight 设置字体粗细
      text-decoration  设置文本划线
      text-transform: 允许你设置要转换的字体 比如大小写,全半角 
- text-shadow 文本阴影

- 文本布局

        text-align 属性定义行内内容（例如文字）如何相对它的块父元素(内容盒子)对齐,这里的行内内容不一定是文字,可能是a标签.
        line-height 行高,设置文本每行之间的高 设置无单位的值 例如:1.5 1.5乘以font-size得到的是行高
        letter-spacing  字母之间间距
        word-spacing 单词与单词之间的间距
        text-indent: 指定文本内容的第一行前面应该留出多少的水平空间。
        text-overflow: 定义如何向用户表示存在被隐藏的溢出内容。
        white-space: 定义如何处理元素内部的空白和换行。
        word-break: 指定是否能在单词内部换行。
        text-orientation: 定义行内文本的方向。
        word-wrap: 指定浏览器是否可以在单词内换行以避免超出范围。
        writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向。


- height = line-height时 文字垂直居中显示
- 内联元素的高度有其中的文本内容 的font-size line-height共同决定, 如果字体大小比行高小一定的值,那高度就是行高
- 在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。
- text-indent 属性能定义一个块元素首行文本内容之前的缩进量。设置负值用来移出文档显示,块内元素中如果有内联元素例如 img span等,会移出文档,  该属性为继承属性 ,对内联元素中的内容无效
- vertical-align 用于以下两种情况  1.使行内元素盒模型与其行内元素容器垂直对齐
- 2.垂直对齐表格单元内容:
- vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。

- margin取负值margin-left 和 margin-top：影响自身元素，自身元素将向指定方向偏移margin-bottom将影响后元素，使后元素向上偏移对应像素
  
#### 样式化列表
 
        <ul>和<ol>元素默认设置margin的顶部和底部
        <li>  默认是没有设置间距的
        <dl>元素默认设置 margin的顶部和底部: 16px(1em) ，无内边距设定
        <dt> 
        <dd> 元素设置为： margin-left  40px (2.5em)。       
        list-style-type ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。
        list-style-position ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。
        list-style-image ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。
        速记属性 list-style 完成以上三个的设置
  - 管理列表技术  
     - ul ol上的属性    
     - start 属性允许你从1 以外的数字开始计数  
     - reversed 属性将启动列表倒计数
     - value 属性允许设置列表项指定数值

#### 样式化链接
- 链接状态 通过伪类进行设置
  - Link (没有访问过的): 这是链接的默认状态 
  - Visited: 这个链接已经被访问过了
  - Hover: 当用户的鼠标光标刚好停留在这个链接
  - Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab  移动到这个链接的时候)
  - Active: 一个链接当它被激活的时候 (比如被点击的时候)
- 在链接中包含图片 通过background
- 样式化链接为按钮 

#### 网络字体
- 在CSS的开始处有一个@font-face块，它指定要下载的字体文件


#### 样式化表格
- 使用 table-layout: fixed 创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。
- > 默认情况下表格及单元格的宽度取决于其包含的内容。
- 使用 border-collapse: collapse 使单元格边框塌陷,使得多个边框合并成一条

- caption-side属性 : 会将表格的标题< caption> 放到规定的位置

- 使用样式化文本的属性来对表格中的文字格式样式化,加上字体/背景色,完成了样式化的工作
#### 背景与边框
- background 属性
  
      -clip  设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。三个参数为:border-box  padding-box padding-box

      -color  设置背景色  关键字transparent
      -image 用于为一个元素设置一个或者多个背景图像 url()
      -origin 指定背景图片的原点位置,从border开始 border-box;从内边距开始 padding-box;从内容开始 content-box;  (默认在左上角)

      - position 为每一个背景图片设置初始位置。这个位置是相对于由 background-origin 定义的位置图层的。如果被定义为两个值，那么第一个值代表水平位置，第二个代表垂直垂直位置。
      百分比值的偏移指定图片的相对位置和容器的相对位置重合。值0%代表图片的左边界（或上边界）和容器的左边界（上边界）重合。值100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值50%则代表图片的中点和容器的中点重合
       关键字 center，用来居中背景图片。(并非把图片移动到中间显示) 关键字 top, left, bottom, right 中的一个。用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，
      - repeat 定义背景图像的重复方式 背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。
  
      - size   设置图片大小;  1个值,这个值指定图片的宽  2个值 宽和高;
      - 关键字cover 拉伸到新的尺寸覆盖容器全部空间  contain 按原有比例缩放到可用空间的尺寸,不一定能够覆盖完容器  
       
      - attachment 决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。 fixed表示背景相对于视口固定背景不会随着内容滚动 local 随着内容滚动    scroll 相对于内容固定,对于外部元素随之滚动  



- opacity属性指定了一个元素的透明度, 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待, 即使这个值没有被子元素继承
- > 因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值

- 使用opacity属性，当属性值不为1时，会把元素放置在一个新的层叠上下文中。


####  处理不同方向的文本
- CSS中的书写模式是指文本的排列方向是横向还是纵向的。
- writing-mode 属性使我们从一种模式切换到另一种模式,horizontal-tb模式,水平方式写入，写入方向从top到bottom


#### 溢出
- CSS中万物皆盒，因此我们可以通过给width和height（或者 inline-size 和 block-size）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，
- 只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。
- overflow属性是你控制一个元素溢出的方式，
- 溢出建立了块级排版上下文 BFC，你改变了overflow的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。


#### 值和单位
- 在CSS中使用了各种数值数据类型 :数字 长度 百分比
- 长度分为绝对长度 相对长度(em  rem lh),相对长度单位相对于其他一些东西
- 如果使用百分比作为宽度值，那么它将是父值宽度的百分比。
- 如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。

- 关于使用百分比来确定 元素的高度宽度,  body,html 百分比,是针对浏览器可视窗口的宽度高度,对于body中嵌套的子元素,如果也使用百分比确定宽高,那么针对的也是可视窗口


#### 调节项目大小
- 块级元素的行为就是这样的。它没有高度，或者说高度为0，因为内部没有内容
  
- 块级元素我们可以给它一个具体的 width 和 height 值, 然后不论我们放什么内容进去它都是该尺寸,如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出
  
- 由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。
  
- 如果你把margins和padding设置为百分数的话，你会注意到一些奇怪的表现。你也许会希望上下的外边距是元素高的一个百分数，左右外边距是元素宽的百分数。但是，情况不是这样的！所有的值都是以父容器的宽度来计算的
- min-和max-尺寸 这在避免溢出的同时并处理变化容量的内容的时候是很有用的。
-  max-width的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。作为示例，如果你设定一个图像的属性为width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。
- >如果你使用了max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的100%。这个技术是用来让图片可响应的

- 我们有与视口尺寸相关的度量单位，即意为视口宽度的vw单位，以及意为视口高度的 vh单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。1vh等于视口高度的1%，1vw则为视口宽度的1%.你可以用这些单位约束盒子的大小


#### 图像、媒体和表单元素
- 图像和视频被描述为替换元素。 这意味着CSS不能影响这些元素的内部布局-仅影响它们在页面上于其他元素中的位置,
- 你可以对容器内的图像作其他选择，例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。
- object-fit属性可以在这里帮助你。当使用object-fit时，替换元素可以以多种方式被调整到合乎盒子的大小。 cover  contain fill ...
- 在替换元素使用各式CSS布局技巧时，你可能深切地体会到他们的展现略微与其他元素不同，例如，在一个flex或者grid布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。

