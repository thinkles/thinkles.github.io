---

title:  jQuery 基础
date: {{ date }}
updated: {{date}}
tags: jQuery基础
categories: jQuery

---
# jQuery 实践
- 抽象jQuery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax 

- jQuery 总是面向对象,对节点集合可能会进行隐式迭代操作

- 编写程序时要尊重渐进增强,和平稳退化

   

## 选择器
- 使用jQuery选择器就算获取不到元素也不会报错,传统Dom在获取之前要加上if判断是否存在,需要注意

  > $()获取的永远是一个对象,就算不存在该元素,所以jQuery通过对象的长度大小.length 属性进行判断是否存在

#### 基本选择器
- id 标签名 类名 层次选择器(+ ~ > 后代...)
- 表单选择器  :表单标签名字

#### 属性选择器

-  element[attr] 选中拥有attr属性的元素,可以多选属性 

- > 可以利用正则表达式进行判断属性 `a[href^="mailto:"]` 判断href属性开头含有mailto的元素

#### 过滤选择器(自定义选择器)

- 过滤选择器又被成为**自定义选择器**, 隶属于jQuery独有的选择器

- 基本过滤器:

  >   `:first `选取第一个元素（单个元素）,`:last`
  >   `:not(selector)` 去除所有与给定选择器匹配的元素,
  >   `:even :odd `索引从零开始
  >  ` :eq（index）` 选取索引等于index的元素,
  >
  > `:gt(index)`  大于index `:lt(index)：`小于
  >   `:header`  选取所有的标题元素
  >   `:animated：`选取当前正在执行动画的所有元素
  >   `:focus：`选取当前获得焦点的元素
  >
  >   `nth-child() `参数可以为数字
  > `  even/odd ` 表达式  索引从1开始
  >   `first-child last-child only-child`

-   内容过滤器 

  > `:contains(text)` 选取(直接)含有text文本内容的元素,(子元素含有并不算)
  > `  :empty `选取内容为空的元素(没有元素节点 没有文本节点) 
  > `:has(selector) `选取**含有**指定选择器选定的元素的元素  
  >
  >  ` :parent` 选取有子元素的元素
  >  ` :visible`  选取所有可见的元素
  > `  :hidden `

- 表单选择符

  > `:checked :selected :enabled :disabled`



- 只要可能，jQuery就会使用浏览器原生的DOM选择符引擎去查找元素。但在
   使用自定义选择符的时候，就无法使用速度最快的原生方法了。



#### Dom遍历方法

- 遍历方法提供了筛选 元素的另一种角度, 结合选择器操作可以更好的互补



- > `find(selector )`  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。
  >
  > `.filter()` 它除了以上参数,可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中

- > `next([selector ]) nextAll()` 获得匹配元素集合后面同级的所有元素 ,...all() 返回结果都不包含自己,       
  >
  >  对应方法: ` .prev()和.prevAll() `
>
  > *如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。*
  >
  > `.siblings()`  能够选择处于相同DOM层次的所有其他元素

- > `.parent( [selector ] )  ` 取得匹配元素集合中，每个元素的父元素
  >
  > `.children([selector ]) `   获得匹配元素集合中每个元素的子元素, 返回结果只包含子元素不包括后代元素
  >
  >  `.contents()`  获得元素的子元素包括文字注释节点

- > `each()方法` 就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次
  >
  > `end() `终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.

- > jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]

  

## 事件
### .ready()事件处理程序

- 通过使用$(document).ready()方法，jQuery支持我们预定在DOM加载完毕后调用某个函
  数，而不必等待页面中的图像加载

  > 简写模式 : $(function(){})
  >
  > 不使用该方法也可以,但是ready()方法为我们提供了很好的跨浏览器解决方法

- jQuery提供了一个`jQuery.noConflict()`方法，把对\$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,

  > jQuery(document).ready(function($) {正常使用符号} )  
  >
  > 简写 : jQuery(function($){})  

### 事件处理

- 在事件处理中常用内容:
  
    > `addClass()`  为每个匹配的元素添加指定的样式类名
    >
    > `hasClass()`   确定任何一个匹配元素是否有被分配给定的类,返回Boolean值
    >
    > `removeClass()`  移除集合中每个匹配元素上 一个，多个或全部样式
    >
    > `toggleClass("类名")` 能够根据相应的类是否存在而添加或删除类
    
    
    
    ```
    当触发任何事件处理程序时，关键字this引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象
    
    is() 判断是否为一个选择器 DOM元素...  例如:  .is(':hidden') 判断元素是否是可见的
    
    ```
##### 事件绑定
- `.on("click",fn)`   参数可以是函数引用或者匿名函数, 还可以用事件名函数绑定  例如.click()  .change()

  > on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jQuery隐式迭代机制

- `.one()   `处理函数在每个元素上每种事件类型最多执行一次,然后删除自己

- > `trigger()`  一次模拟事件的触发  
  >
  > `triggerHandler()` 与 .trigger() 相似,不会触发默认行为,不会事件冒泡, 只会对匹配到的第一个元素生效 

- 早期版本使用 `bind()` 进行事件绑定
##### 事件解绑
- `.off("事件名")`方法移除

- 对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.

  > 例如:  .on('click.collapse',fn);  .off('click.collapse'); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的

##### 事件传播(冒泡)
- DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,

- jQuery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。

- 避免事件传播的事件处理

    > `hover(fn,fn)`函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播
    > `mouseenter()和mouseleave()`，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。

- 事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡



##### 事件对象
- jQuery对事件对象进行了必要的扩展，从而在任何浏览器中都能够使用这个属性,jQuery提升了兼容性

- 如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false

  > 对于Dom 中 返回 false 只是阻止默认行为

##### 事件委托
- 某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素



## 样式与动画
### CSS属性操作
- .CSS()方法,用来获取计算后的样式,设置内联样式.
  
   > `获取`使用:
   > 单个样式属性   传递一个**字符串形式**的属性名，获取字符串形式的属性值,
   > 多个样式属性   可以传入属性名的**数组**，得到的则是属性和值构成的对象,对于属性名的格式,可以是驼峰命名或者连字符  
   
   > `设置`使用:
   > CSS()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值
   >
   > 另一种是为它传递一个由属性—值对构成的对象

- 浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性

### 效果和时长
- 隐藏/显示元素:  `.hide() .show()`   相当于设置display的值   默认是不带动画效果的.

  > .hide()方法会将匹配的元素集合的内联style属性设置为 display:none。
  >
  > 但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局

- 带动画效果: .hide('duration')   duration:毫秒级   

  > 动画效果->会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,
  > 动画效果有两种预设的速度参数：'slow'和'fast'。也可以自定义指定显示速度. 以下动画效果都可以适用

- 淡入和淡出, `fadeIn(),fadeOut()`  :

  > 改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。

- 滑入和滑下, `slideDown()和.slideUp() :`  改变高度和display的值  

  > 元素本来就处在文档流中,适合使用滑入滑出

- 复合效果方法,  `slideToggle()` ,动画和`slideDown(),slideUp()`一样   

  > toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见
### 自定义动画
- .animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式
  
  > 第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:
  >
  > `.animate({property1: 'value1', property2: 'value2'}, duration, easing, function() {})`
  >
  > 第二种形式接受两个参数，一个属性对象和一个选项对象:
  >
  > `.animate({ property1: 'value1', property2: 'value2' }, `
  >
  > `{ duration: 'value', easing: 'value',`
  >
  > `specialEasing: { property1: 'easing1', property2: 'easing2' }, `
  >
  > `complete: function() {}, queue: true, step: callback });`
  
  
  
- animate()方法最少要有两个参数,属性对象和duration

  > .animate()方法针对CSS属性提供了方便简写值：`'show'、'hide'和'toggle'`
  >
  > 例如 : .animate({height: 'toggle'}, 'slow');

- animate()方法中,属性对象中的值如果是 {"height" :"+=value" }表示在原来的基础上再加上value,而不是变化到value
##### 并发与排队
- 同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.

  > 需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式

- 想要同时触发效果,要在一个方法内写多个属性



- 多个元素,应用效果时,这些效果会同时发生,

  > 为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数
  >
  > $clickedItem.next().slideDown('slow', function() { $clickedItem.slideUp('slow'); }); 先执行外层,在执行回调函数

##### 越过队列
- 第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始
- 对于非效果方法,如.CSS()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序
>解决方法
>
>1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({background Color:'#f00'});next();}) 
>
>传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码

>2:利用效果方法中的回调函数,在回调函数中书写.CSS(), 在外层函数完成时执行CSS,不需要调用next()



## DOM操作
#### 属性操作
##### HTML 特性操作
- `.attr()` 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值
- `.removeAttr()方法`  删除*一个*属性
> 可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:
> - ```
>   $('div.chapter a').attr({  
>   title: 'Learn more at Wikipedia',
>   id: function(index, oldValue)
>   { return 'wikilink-' + index; }
>   });
>   这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用
>   ```
>
> 
##### DOM 属性
- 在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同
- >从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。
- DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性

  > 差别最大的地方是表单控件的属性,不要使用attr(),要使用Val() 获取/设置属性 
  >
  >  或者是prop操作DOM属性(这个是要分情况的)
- 与.attr()和.prop()一样，.val()方法也可以接受一个函数作为其setter参数

#### 节点操作

- 创建节点 :  使用$("")函数创建节点

- 插入(添加) / 移动节点: 
  
  > `内容.insertBefore("目标")` 在现有元素外部、之前添加内容；
  >
  > `.insertAfter() `在现有元素外部、之后添加内容。
  >
  > 
  >
  > `.prependTo() `  在现有元素内部、之前添加内容；
  > `.appendTo() `     在现有元素内部、之后添加内容；
> 使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了
> 在隐式迭代添加多个节点时,插入顺序**预定义**的,不管是after before,从上到下顺序都是迭代顺序

- 反向插入方法 :内容目标的位置颠倒,名字更换了一下
  
   > `append()  prepend()   before()   after()`



- 包裹节点

  > 被包裹的节点 `.wrap("节点") .wrapAll("节点")`
  > 区别:后者在多个节点时,只包裹一次(最外面的节点), 而wrap每个节点都会包装一次
  >
  > `wrapInner()`包裹匹配元素的子元素

  

- 复制节点

  > `.clone()`  在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件
  >
  > 通过 clone(true) 复制事件处理函数

  

- 删除节点 

  > 从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件
  >
  > `remove(),detach()`  两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null 
  >
  > 两者区别: 使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除

-  ` empty()` 清空节点里的内容(文本 元素节点),

  > *注意是节点里的,不是节点本身* , 返回一个已经清空的元素

  

- 替换节点(文本/元素)
  
  > .html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容
     >
     > .text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本
     > .replaceAll("目标") 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动
     > .replaceWith("内容")   替换集合中所有匹配的元素,返回被删除元素的集合

  
  
  

## AJAX
##### 请求过程
- jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。

        > `.ajaxStart()和.ajaxStop()`方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个
        > 当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数 
        > 当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.
        
- 错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 
##### ajax中的常见问题
- 通过Ajax生成页面内容时的一个常见问题:事件绑定丢失

  > 事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。
  >
  > 解决方法: 每次页面内容更新重新绑定事件      使用事件委托

- `$.ajaxSetup()` 函数可以修改调用Ajax方法时每个选项的默认值。之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，

- 取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式

## 开发插件

- 添加新的全局函数, 即jQuery对象的方法

  > `$.funcname = func()   `
  >
  > `$.extend({funcame:func(){}})`
  >
  > 添加全局函数
  >
  > 为了避免冲突，最好的办法是把属于一个插件的全局函数都封装到一个对象中

- 扩展jQuery对象的方法

  > ` jQuery.fn.myMethod = function(){}` 
  >
  >  jQuery.fn对象是jQuery.prototype的别名

- 开发插件注意的问题

  > - 考虑方法的隐式迭代问题 :  jQuery的选择符表达式可能会匹配零、一或多个元素,
  >
  >   > 调用.each()方法；这样就会执行隐式迭代 (在调用的.each()方法内部，this依次引用每个DOM元素)
  >
  > - 考虑方法的连缀问题:  函数的返回值要是一个jQuery对象
  > - 默认参数值, 灵活的参数(传递对象参数) , 

- 利用QUnit等测试框架为自己的插件维护一组自动的单元测试



## jQuery进阶内容

##### 高级遍历
- Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。

  > 使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异

- 选择符优化问题 自定义选择符

  > 如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器

- DOM遍历背后的原理

  > 向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关
  >
  > addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑

  

- DOM 遍历的性能问题 : 多使用连缀,和缓存jQuery对象,来最低限度的重复使用选择符和遍历方法

##### 高级事件处理
- 早委托 : 选择document作为委托作用域,不必等待Dom完全加载后才进行绑定事件, 通过早委托实现早绑定

- 自定义事件: 通过 on()注册自定义事件, 使用trigger方法进行手动调用, 它只能手动调用

  > 在触发自定义事件时，我们也可以给任何注册的事件处理程序传入额外的信息。这种技术就叫做自定义事件参数, 在trigger调用处理程序时传入参数

- 节流事件: 浏览器中有几个原生事件都会频繁触发。最常见的事件有scroll、resize和mousemove。为了解决这个问题，就需要节流事件

  >  这个技术会限制一些无谓的计算，即不是每次事件发生都计算
  >
  > 1. 通过定时器,函数的调用只会在计时器结束时调用, 那么多次触发事件只有一次调用
  > 2. 通过定时器进行轮询检查,调用函数

- 在频繁重复的事件发生期间限制处理次数的第三种技术叫消除抖动

- 扩展事件: 利用这些事件扩展API，可以创建出与原生DOM事件非常类似的新事件。具备默认行为....

##### 高级动画
- 如果在两次事件发生后调用动画, 如果时间很多的情况下,那么图像会在最后一次事件出发后反复的运行动画

  > 原因: 元素的动画逐一的添加进队列,它会依次运行直到队列为空

- 使用jQuery自定义的`:animated`, is(':animated')判断是否在动画中,但是还不够,还需要**终止运行中的动画**

  > `.stop()`，它能在动画运行过程中让动画立即停止。这里的关键是在处理新动画之前先停止当前动画, .stop()方法可以接收两个布尔值,第二个参数 `gotoend`
  >
  > `.finish() `  清除队列中的动画,并使当前动画跳转到最终值,和.stop(true,true)相似

> 在1.7之前版本中,   在动画之前，这些简写的动画方法(**slidedown fadein..**.)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。




- 全局效果属性 :`$.fx`对象  

  > 禁用所有动画效果  `$.fx.off=true;`
  > 定义效果时长 `$.fx.speeds= ...  `可以改变预设值的效果速度,可以自定义一个速度选项
  
  


- 多属性缓动  

     > 通过动画方法中,`specialEasing`选项可以为每个要应用动画的属性设置不同的加速度曲线。 默认的是 swing函数

- 延迟对象(promise)

     > 每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。

     > 通过在jQuery对象上调用.promise()方法,获得延迟对象
     >
     > `.done()`方法添加的处理程序会在延迟对象被成功解决之后调用。
     > ` .fail()`方法添加的处理程序会在延迟对象被拒绝之后调用。
     > ` .always()`方法添加的处理程序会在延迟对象完成其任务（无论解决或拒绝）时
     >  调用。

- > 通过延迟对象可以使动画在某个操作结束后调用函数, 取代了回调函数

- .animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  
> jQuery动画系统最底层的方法是\$.Animation()和\$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面



-----------


本文档参考                   <  jQuery 基础教程第四版  2020 6.30 >