---

title: CSS 指南
date: {{ date }}
updated: {{date}}
tags: CSS
categories: CSS

---

### CSS 指南



- 响应式 和 自适应的区别 

响应式 :  改变布局  适配多种屏幕   **流动**的网格、**灵活**的图片和媒体查询是响应式网页设计的3个技术要素，

自适应 ,根据固定屏幕大小,使用多种不同的布局设计

另一种分别是平滑设计和快速设计的区别。响应式设计是平滑的，因为不管在什么设备上看，布局都可以流畅地调整。

适应性思维方式既不是流动的也不是灵活的，而是寻找适应的特定点,在特定点来适配

[响应式和自适应](https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/)

[响应式和自适应](https://www.interaction-design.org/literature/article/adaptive-vs-responsive-design)

自适应设计(理论上)将确保根据用户使用的接口设备提供最佳的用户体验。不像响应式设计，屏幕从桌面设计“流动”到更小的设备，自适应设计提供了量身定做的解决方案。

2011年，网页设计师Aaron Gustafson在他的书《自适应网页设计》里率先提出了自适应网页设计的概念。

Adaptive design (自适应设计)：为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。目前AWD网页主要针对这几种分辨率（320，480，760，960，1200，1600）

和响应式网页不同，自适应设计是基于断点使用静态布局，一旦页面被加载就无法再进行自动适应，自适应会自动检测屏幕的大小来加载适当的工作布局。

自适应设计的优势在于，它允许设计人员量身定制解决方案，从而使GUI在不同的屏幕尺寸上呈现最佳状态。 缺点是自适应设计的成本很高，

#### CSS使用

- 行内式  内嵌式   外部链接式 (rel href 必填项)

#### CSS工作原理(浏览器工作)

- 简单的步骤 :  载入HTML,然后转化为DOM,拉取大部分资源(图片,视频,CSS),JS稍后进行处理. 拉取到CSS 后进行解析,并应用到DOM树上,这个步骤称为  `渲染树`,  根据渲染树进行布局,显示在网页上(着色)



#### 层叠与继承 优先级
- **优先级:**   id>class>...  那个选择器更具体 那个优先级就高

  > 分为千位 百位  十位  个位,依次为:
  >
  > style 声明属性    ID选择器    类选择器/属性选择器/伪类       元素/伪元素选择器
  >
  > 依次加1000  100  10 1, 按最后的结果获得权重值

  > 通用选择器 (`*`)，组合符 (`+`, `>`, `~`, `' '`)，和否定伪类 (`:not`) 不会影响优先级。 `只根据有多少个选择器 多少元素 进行计算权重`

- **层叠:**  当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。

  > 没有优先级权重时, 使用的是层叠规则

- **继承:**  设置在父元素上的CSS属性是可以被子元素继承的，有些不行不如width border...

  >  控制继承: 
  >
  > inherit 开启继承,使子元素属性和父元素相同, (**默认值 inherit**) 
  >
  > initial 设置属性和浏览器默认样式一样,没有默认样式改为 inherit
  >
  > unset  : 如果属性是继承的就是inherit,不是就是initial,使用默认样式
  >
  > 
  >
  > 属性值 : 控制属性值  => background-color: unset;    来控制属性的是否继承
  >
  > 也可以通过 all: 控制属性值, 对父元素所有的属性进行控制  , **或者用来撤销对样式所做更改**,    all: unset; 可以使得某个元素重置所有的样式为默认样式
  >
  > 

- `!important打破优先级使用该属性 覆盖!important 唯一的办法就是另一个 !important  `

- >  !important 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难,建议不使用



- **有继承性的属性:** 实践中寻找,最常见的有 字体属性   文本属性



#### 选择器

- **基本选择器:**

  > 元素、类、id选择器
  > 标签属性选择器 : a[title]{}
  > 伪类、伪元素选择器  :类   ::元素
  >
  > 全局选择器  *

- **选择器运算符:**

  > 交集选择器  `''`   并集选择器 `,`   
  >
  > 后代选择器   `' '`   子元素选择器：`>`   
  >
  > 相邻兄弟(后面紧跟的一个)选择器 `+`     通用兄弟(选择所有兄弟)选择器:  `~`

  ------



- **标签选择器详解:**

  >[attr~=value]  含有一个value (不能是子字符串,但之间可以是空格隔开)  
  >
  >[*attr*|=*value*] 含有value (不能是子字符串,但后面可以跟-字符)
  >
  >[attr~=value] [attr^=value] [attr*=value]   
  >
  >依次为 :  开头、结尾、字符串中匹配value的 属性
  >
  >attr 可以换成 class     例如: li[class="a"]

  

- **伪类 伪元素选择器详解 :** 

- > 伪类是选择器的一种，它用于选择处于特定状态的元素
  >
  > 伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。

  

- **伪元素使用:**

- 例子 : `::first-line`伪元素选择器,会始终选择元素内的第一行,进行样式化,如果使用其他选择器无法实现, 因为不知道一行有多少个字段,如果使用span标签进行包裹,如果字段较多,他就会延展到第二行, 无法只给第一段应用样式.

  >  有一组特别的伪元素`::before`和`::after`，它们和`content`属性一同使用，使用CSS将内容插入到你的文档中中。
  >
  > ```
  > .box::after{
  >  content: "This should show before the other content."
  > }   
  > <p class="box">Content in the box in my HTML page.</p>
  > //after加载内容后面  before相反
  > ```

- **这些伪元素的更推荐的用法是插入一个图标**, 这些伪元素经常用于插入空字符串,然后对空字符串进行样式化,可以给他一个宽高 和背景就会形成一个图形

- > 其余的伪元素 : `::first-letter`第一个字母 **`::selection`** 应用被高亮的部分(鼠标选择)

  

- 伪类选择器和伪元素可以组合使用 , 但不能嵌套使用(比如:not()的参数)

  

#### 盒子模型 

- 盒子分为：块级盒子（Block box)和  内联盒子（Inline box） 

- **块级盒子:**

  > 在内联的方向上扩展并占据父容器的所有可用空间:  简单说,占据父容器所有的宽度
  >
  > 发生换行   宽高   padding  border margin 发挥作用

- **内联盒子:**

  > 不会产生换行   width 和 height 属性将不起作用 
  >
  > 垂直方向的padding 、margin以及border会被应用但是推不开其他的盒子
  >
  > 水平方向的可以推开

- **inline-block盒子:**

  > 外部表现为 inline 不会换行 , 但是可以设置宽高  设置四个方向的padding 、margin以及border 可以推开盒子
  >
  > 相当于内联 和 块级的 中和的产物

- CSS的盒子模型有**内部**和**外部**显示类型 ，外部显示类型，来决定盒子是块级还是内联。内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局 (块级和内联布局), 

  > 特殊的 display: flex, 外部显示类型是 block，但是内部显示类型修改为 flex。
  >
  > 标准的  inline-block   inline-flex

  

- **盒子模型分为 标准盒模型   替代盒模型** 

  > 区别在于标准盒模型计算盒子大小是 内容加上 padding border
  >
  > 替代盒模型: 设置box-sizing: content-box(默认值)/ border-box 
  >
  > content-box : 设置的宽/高度只有内容
  >
  >  border-box :宽/高度包含边框
  >
  > 



##### padding、margin、border

- **margin(外边距):**

- `margin-left:atuto`   :  会占据这个方向的剩余空间的宽度,用来让某一项顶到边框

- **外边距外边距margin 折叠问题:**

- > 注意有设定`float`和`position=absolute`的元素不会产生外边距重叠行为。脱离文档流不存在此问题

  > 1. 同一层相邻元素之间的外边距重叠:
  >
  > 外边距合并：相邻元素margin-top 和margin-bottom 长度会合并成两者间较大的数值，如果有负值就是两者的和,两者都为负值就取绝对值最大的
  > **解决:** 后一个元素 设置 inline-block
  >
  > 
  >
  > 2. 没有内容将父元素和后代元素分开:
  >
  > 如果没有设置边框border-top，内边距padding-top，行内内容(文字)，也没有创建块级格式上下文或清除浮动,那么margin-top就会折叠 .对于margin-bottom 也适用上面的判断,区别在于 高度也是margin-bottom的判断标准
  >
  > 较大的值最终会溢出到父级块元素外面。表现为父元素移动了溢出的值
  >
  > 
  >
  > 3. 空白块
  >
  > 当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素**完全没有设定**边框border、内边距paddng、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。(不太理解)
  >
  > - 上述情况的组合会产生更复杂的外边距折叠。

  

- **padding(内边距):**

- 应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。

  > padding可以撑大元素的尺寸，背景会随着撑大元素的尺寸而扩大




##### BFC
- 块格式化上下文（Block Formatting Context，BFC)，**是块盒子的布局过程发生的区域**，也是浮动元素与其他元素交互的区域。

  > **浮动定位** 和 **清除浮动** 时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。
  >
  > 外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间


- 创建BFC方法: 

  > 在父级块中使用 display: flow-root 可以无副作用的创建新的 BFC。还能够使正常块级元素可以推开浮动元素,(默认情况是重叠的)
  >
  > overflow 值不为 visible 的块元素 绝对定位元素  行内块元素 浮动元素...
  >
  > 更多创建BFC方法参考 MDN  

- BFC可以解决了 `高度塌陷`  `外边距折叠问题`

  > 在文档流中，父元素的高度默认是被子元素撑开的，当为子元素设置浮动以后，子元素会完全脱离文档流，此时就会导致子元素无法撑起父元素的高度，此引发父元素的高度塌陷




#### 隐藏标签
- `display:none`   不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。
- `visible:hidden` 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。这是个继承元素

  > 元素使用`visibility:hidde`时 如果在设置:hover状态,这是不会触发,因为这时已经隐藏不可能触发
- `opacity : 0` , 不可见,但保留位置



#### 样式化文本
- **字体**


- 浏览器的 `font-size` 标准设置的值为 16px, 建议把根元素的font-size 调成10px,这样可以更方便的使用 em rem计算font-size值

- > font-style 打开关闭斜体
  > font-weight 设置字体粗细
  > text-decoration  设置文本划线 上下中划线...
  > text-transform: 转换文本的大小写,全半角 
  >
  > text-shadow 文本阴影 : 
  
- #### 网络字体:  在CSS的开始处有一个@font-face块，它指定要下载的字体文件



- **文本布局**

    - `text-align` 用来控制行内内容(文本/节点..)如何和它所在的内容盒子(有宽度的块级元素)对齐

      > 在内容盒子中对齐,会改变行内元素的内联,比如左对齐,每个行内元素都独占一行

    - **`vertical-align`** 用来指定**行内元素**（inline）或**表格单元格**（table-cell）元素的垂直对齐方式。

      >    垂直方式根据  行内元素基线相对于元素所在行的基线, 进行调整    
  >
      >   该属性对块级元素是不能使用的
    
    - `letter-spacing ` 字母之间间距  ` word-spacing `单词与单词之间的间距

    - `text-overflow:` 定义如何向用户表示存在被隐藏的溢出内容。
  
    > 这个属性只对那些在块级元素溢出的内容有效，**但是必须要与块级元素内联(inline)方向一致**（举个反例：内容在盒子的下方溢出。此时就不会生效）。
>
      > 对于多行文本的向下溢出无法处理

    - `white-space:` 处理元素内部文本的空白和换行。

    - `word-break:` 是否能在单词内部断行。

      > 对于中文来说可以在任意处断行,所以在处理一串英文时需要加上该属性值,否则他不会换行的

    - `text-orientation`: 定义行内文本的方向。
  
    - `word-wrap(overflow-wrap):` 指定是否可以在单词内换行以避免超出范围。
    
      > 和word-break的区别时在于, word-wrap会尽量保证单词的完整性的情况下断行,word-break会在只要可以断行的时候断行writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向
  
    


- height = line-height时 文字垂直居中显示
- 内联元素的高度有其中的文本内容 的font-size line-height共同决定, 如果字体大小比行高小一定的值,那高度就是行高
- 在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。
- text-indent 属性能定义一个块元素首行文本内容之前的缩进量。设置负值用来移出文档显示,块内元素中如果有内联元素例如 img span等,会移出文档,  该属性为继承属性 ,对内联元素中的内容无效
- vertical-align 用于以下两种情况  1.使行内元素盒模型与其行内元素容器垂直对齐
- 2.垂直对齐表格单元内容:
- vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。
- margin取负值margin-left 和 margin-top：影响自身元素，自身元素将向指定方向偏移margin-bottom将影响后元素，使后元素向上偏移对应像素
- 多个内联文本有一个设置上外边距值 会一起移动, 内联元素布局默认是一指的
#### 样式化列表

- > `list-style-type` ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。
  > `list-style-position `：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。
  > `list-style-image` ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。
  > 速记属性 list-style 完成以上三个的设置

  

- `ul ol`属性  

  > start 属性允许你从1 以外的数字开始计数  
  >
  > reversed 属性将启动列表倒计数
  >
  > li中 的value 属性允许设置列表项指定数值

  

#### 样式化链接
- 链接状态 通过伪类进行设置
  - Link (没有访问过的): 这是链接的默认状态 
  - Visited: 这个链接已经被访问过了
  - Hover: 当用户的鼠标光标刚好停留在这个链接
  - Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab  移动到这个链接的时候)
  - Active: 一个链接当它被激活的时候 (比如被点击的时候)
  
  


#### 样式化表格
- 使用` table-layout: fixed `创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。

  > **默认情况下表格及单元格的宽度取决于其包含的内容。**
- 使用` border-collapse: collapse `使单元格边框塌陷,使得多个边框合并成一条

- `caption-side属性` : 会将表格的标题< caption> 放到规定的位置

  

#### 背景与边框
- background 属性
  
- > `-clip ` 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。   border-box  padding-box content-box
  >
  > `-origin` 指定背景图片的原点位置,   从边框开始;从内边距开始  从内容开始 content-box;  (默认在左上角)  border-box  padding-box content-box
  >
  > `-position `选择背景图像显示在其应用到的盒子中的位置, 默认是框的左上角(0,0),
  >
  > > 这个位置是相对于由 background-origin 定义的位置图层的。
  > >
  > > 百分比值0%代表图片和容器左/上边界重合  100%左上边界和容器的右/下重合
  > >
  > > 指定关键字 top, left, bottom, right 中的一个,另一个维度被设置成 50%，
  >
  > 
  >
  > `-repeat`  背景图像可以沿着水平轴/垂直轴重复，或者根本不重复,或者都重复
  >
  > `-size`   1个值指定图片的宽  2个值指定宽和高;
  >
  > > cover 拉伸到新的尺寸覆盖容器全部空间 
  > > contain 按原有比例缩放到可用空间的尺寸,不一定能够覆盖完容器  
  >
  > `-attachment`    指定内容滚动,背景如何滚动
  >
  > > fixed 表示背景相对于视口固定,背景不会随着内容滚动 
  > > local 背景相对于**元素内容**固定,它会随着内容滚动    
  > >
  > > scroll 背景相对于**元素本身**固定,而不是随着它的内容滚动



- opacity属性指定了一个元素的透明度, 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待, 即使这个值没有被子元素继承
- > 因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值

- 使用opacity属性，当属性值不为1时，会把元素放置在一个新的层叠上下文中。


####  处理不同方向的文本
- CSS中的书写模式是指文本的排列方向是横向还是纵向的。
- writing-mode 属性使我们从一种模式切换到另一种模式,
- horizontal-tb模式,水平方式写入，写入方向从top到bottom


#### 溢出
- 我们通过给width和height（或者 inline-size 和 block-size）来约束盒子的尺寸。但是内容过多时,内容(例如文本会超出宽度显示)就会溢出

- > 溢出的内容不会当做盒子的尺寸,也就是说如果有行内元素的话,可能会忽略溢出内容,覆盖内容

  

- 只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。通过`overflow` ``overflow-x/y`属性控制元素溢出的方式，

  > hidden : 隐藏     scroll: 滚动来显示内容     visible(默认值):显示数据  

- 溢出建立了块级排版上下文 BFC，在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。


#### 值和单位
- 在CSS中使用了各种数值数据类型 :数字 长度 百分比

- 长度分为绝对长度 相对长度

  > 常用的绝对长度: px
  >
  > **相对长度:** 
  >
  > 使用相对单位的好处是,可以使文本或其他元素的大小与页面上的其他内容相对应。
  >
  > `em` :  在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小,例如height
  >
  > `rem`: 根元素的字体大小
  >
  > `lh`:元素的line-height     `vw`: 视窗的高度的1%  `vh`:视窗高度的1%

- 如果使用百分比作为大小，那么它将是父元素大小的百分比。

  > body,html 百分比,是针对浏览器可视窗口的宽度高度


#### 调节项目大小
- 在受CSS设置影响之前，HTML元素有其`原始的尺寸`,
  
  > 比如  Img的固有尺寸是图片的尺寸, div块高由内容决定
  >
  > 元素的**固有尺寸** — 由其所包含的内容决定。对于块级元素来说内容只影响它的高度,宽度默认独占一行
  
- 当你用百分数设定内外边距的时候，值是以**内联尺寸**进行计算的，也即对于左右书写的语言来说的宽度(浏览器视口的宽度)。而不是元素的尺寸大小



- min-和max-尺寸:

  > 你有一个`变化容量`的盒子,但你想让它**至少**有个确定的高度,你应该给它设置一个[`min-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height)属性
  >
  > [`max-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width)的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。
  >
  > 设定一个img的属性为width: 100%,那么它会充满整个容器,
  >
  > max-width: 100%,那它最大只能是图片的原始尺寸

- min-和max-尺寸 这在避免溢出的同时并处理变化容量的内容的时候是很有用的。






#### 图像、媒体和表单元素
- object-fit属性  指定 可替换元素 的内容应该如何适应到其使用的高度和宽度确定的框

  > **contain**: 保持宽高比 进行缩放   **cover**:保持宽高比,填充  **fill**: 填充不保持宽高比

- 在替换元素使用各式CSS布局技巧时，你可能深切地体会到他们的展现略微与其他元素不同，

- > 记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为
- > 例如，在一个flex或者grid布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。







#### CSS预处理和后处理

- Sass   预处理  
- cssnano 后处理  你对加入例如许多额外的注释和空格，增大你的样式表大小有所关心的话，那么后处理会通过在生产版本中略去任何不必要的东西的方式



##### 块级元素 行内元素互相嵌套问题

- 以上问题都是 没有设置外部容器的宽高的情况

- **内联元素嵌套块级元素**

- 块级元素无法撑开内联元素,但是例如 cursor: pointer /a便签 发生区域还是被撑大了, 而且不能覆盖块元素的性质, 它还是会独占一行, 因为没有尺寸背景色无法应用

- > img 元素 也可以撑开内联元素,但是情况和上面一样,尺寸不正确,是默认的尺寸
  >
  > 个人理解,内联元素只能被文本撑开

- 解决方法: 

  > 把外层的内联元素换成 inline-black元素

  

- **块级元素嵌套内联元素**

- 有内容的内联元素可以撑开块级元素,

- 没有内容的内联元素,比如img 不能正好的撑开块级元素,会有缝隙,

- 解决方法:

  > 设置内部为块级元素就可以撑开 
  >
  > 外部设置宽度 img 100%

  

- 只有块级元素之间能正好的撑开元素

  
