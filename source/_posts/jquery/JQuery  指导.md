---
title: Jquery指导
date: 
tags: Jquery
categories: Jquery
---

# Jquery 实践
- 抽象jquery 功能:  改变文档内容样式  动态效果 更好的数据交互操作 ajax 
-  jquery 总是面向对象,对节点集合可能会进行隐式迭代操作
- 编写程序时要尊重渐进增强,和平稳退化
## 选择器
> jQuery完全继承了css选择器风格,下面的选择器用法也是css选择器的用法
> 使用jquery选择器就算获取不到元素也不会报错,传统dom在获取之前要加上if判断是否存在,需要注意
> $()获取的永远是一个对象,就算不存在该元素,所以jquery通过对象的长度大小.length//转换为dom对象判断,来评判是否存在该元素
#### 基本选择器
- id 标签名 类名 层次选择器(+ ~ > 后代...)
- 表单选择器  :表单标签名字
#### 过滤选择器
    
      基本过滤选择器 :first 选取第一个元素（单个元素）,:last
      :not(selector) 去除所有与给定选择器匹配的元素,
      :even :odd 索引从零开始
      :eq（index） 选取索引等于index的元素,:gt(index)  大于index :lt(index)：小于
      :header：选取所有的标题元素
      :animated：选取当前正在执行动画的所有元素
      :focus：选取当前获得焦点的元素

      属性选择器: element[attr] 选中拥有attr属性的元素,可以多选属性 element[attr][attr0]
      可以利用正则表达式进行判断属性 a[href^="mailto:"] 判断href属性开头含有mailto的元素
      
      内容过滤器  :contains(text) 选取(直接)含有text文本内容的元素,(子元素含有并不算)
      :empty 选取内容为空的元素(没有元素节点 没有文本节点)  
      :has(selector) 选取**含有**指定选择器选定的元素的元素  
      :parent 选取有子元素的元素
      :visible  选取所有可见的元素
      :hidden 

      子元素过滤器  nth-child() 参数可以为数字 even/odd  表达式  索引从1开始
      first-child last-child only-child

      表单元素过滤器 :checked :selected :enabled :disabled

> 性能提示   DOM对象和jquery对象的互换(在jquery对象中调用DOM) 
 


> jQuery提供了一个jQuery.noConflict()方法，把对\$识符的控制权让渡还给其他库 ,想要在让渡之后ready内继续使用符号,jQuery(document).ready(function($) {正常使用符号} ) 
## 事件
### 事件处理
- 在事件处理中常用内容:
       
        当触发任何事件处理程序时，关键字this引用的都是触发相应行为的原生DOM元素。通过$()函数可以将DOM元素作为参数创建jquery对象
        toggleClass("类名")方法,(类名不加点)能够根据相应的类是否存在而添加或删除类
        is() 判断是否为一个选择器 DOM元素...  例如:  .is(':hidden') 判断元素是否是可见的
        .one()只生效操作一次,参数和on函数一样,相当于一次的on函数调用
##### 事件绑定
- .on("click",fn)  fn可以是函数引用或者匿名函数
-  除了on绑定,还可以用事件名函数绑定  例如.click() 键盘事件 .keypress()...
> on()一次调用,如果是元素集合,可以为每个元素绑定相同的事件处理,这是jquery隐式迭代机制,jquery的行为队列机制,可以给一个元素绑定多个相同事件不会被覆盖
>老版本会有bind()查看jquery api
> .on(),中的函数参数,可以是函数引用,函数引用,必须省略函数名称后面的圆括号。圆括号会导致函数被调用，而非被引用。

##### 事件解绑
- 调用.off("事件名")方法移除
- 对.off()的调用更有针对性，以避免把同一个元素,注册的两个单击处理程序全都移除。达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息.
> 例如:  .on('click.collapse',fn);  .off('click.collapse'); collapse为命名空间,对于事件处理系统而言，后缀.collapse是不可见的
- 对.off()的调用更有针对性,还可以在调用on("click",fn引用)时,在fn中进行判断事件对象,这样可以不用命名空间, 注意一个问题,如果重复触发事件,就会重复调用这个函数,比如重复点击.
- 重新绑定事件,只需要再次调用on函数.

##### 页面加载事件
- \$(document).ready()  简写-> $(function(){});
> window.onload和ready()区别：$(document).ready()，会在DOM完全就绪并可以使用时调用，但是关联文件不一定下载完毕,还有ready()可以一直添加不会被覆盖.



### 事件传播（旅程）
- DOM标准规定:首先从上到下(一般到具体元素)事件捕获,再从下到上(具体到一般元素)进行事件冒泡,
>在js编程中默认在冒泡阶段进行处理事件,改变addEventListener(type,fn,false)中的false为true,则是在事件捕获时进行处理事件(从最外层处理一直到最内层)
- jquery始终在冒泡阶段进行注册事件处理,我们总是可以假定最具体的元素会首先获得响应事件的机会。

- 避免事件传播的事件处理

        hover(fn,fn)函数。这个方法可以让我们在鼠标指针进入元素和离开元素时进行操作,可以避免事件传播
        而mouseenter和mouseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。

##### 事件冒泡 --事件捕获
- 冒泡副作用:错误的元素响应mouseover或mouseout事件的情况下,例如外层div最内层a,当最内层a元素鼠标离开时会触发mouseout事件向外层冒泡
- 事件冒泡,从具体元素到一般元素的理解: 具体元素指的是响应事件最(准确具体)的元素,例如a元素嵌套一个i元素图标,那么当不点击图标时,最具体的元素是a而不是 i元素,当li嵌套一个a(块级)时,响应没有最准确的那么选最具体的a元素
- 事件冒泡跟父子元素之间的位置无关,当通过绝对定位把子元素移开,还是会发生冒泡
> mouseover out事件,在鼠标从父元素移入子元素时会触发 父元素out事件,over事件总是从父级元素到自己元素
### 事件对象
- 事件对象是一种DOM结构，它会在元素获得处理事件时,获取触发事件的元素.这个对象中包含着与事件有关的信息,也提供了可以用来影响事件在DOM中传递进程的一些方法 (jquery对对象属性进行封装,使其可以兼容,以下是jquery封装过得,可能和原生DOM不同)
     
      属性: .target 获取触发事件的DOM元素 .type 获取事件类型 .pageX.pageY 获取相对于页面x坐标y坐标 .which 获取鼠标的左中右键 获取键盘事件的按键  .mateKey获取ctrl键

      方法:  preventDefault() 阻止默认行为  stopPropagation()阻止事件冒泡
      
>通过事件对象解决事件冒泡问题
- 事件传播和默认操作是相互独立的两套机制，在二者任何一方发生时，都可以终止另一方。
>如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false，这是对在事件对象上同时调用.stopPropagation()和.preventDefault()的一种简写方式。

##### 事件委托
- 只在DOM中的一个祖先元素上指定一个单击处理程序。由于事件会冒泡，未遭拦截的单击事件最终会到达这个祖先元素,而我们可以在此时再作出相应处理.
- 使用内置的事件委托, on函数接受相应参数,例如: .on('click', 'button', function(){}) :事件处理绑定到父元素上，同时比较event.target和选择符表达式（这里的'button'）。如果匹配执行事件处理.

- 某些情况下祖先元素无法作为事件委托的处理程序,我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动,找到一个可以绑定处理事件的父元素

##### 模拟事件
- 例如用户进入页面时,就触发点击事件,不要去点击它,这时需要模拟事件: trigger("click"),也可以直接使用简化模式,调用.click();
- tigger还可以触发自定义事件
> trigger()方法不仅会触发事件,还会触发默认行为 trigger("focus"),这样除了触发事件,还会是该元素获得focus,单纯的触发事件使用triggerHandler()

## 样式与动画
### css属性操作
- .css()方法,用来获取计算后的样式,设置内联样式.
  
       获取使用:
       单个样式属性   传递一个字符串形式的属性名，获取字符串形式的属性值,
       多个样式属性   可以传入属性名的数组，得到的则是属性和值构成的对象,
       对于属性名的格式,可以解释驼峰命名,也可以解释连字符的命名  
      
       设置使用:
       css()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值，另一种是为它传递一个由属性—值对构成的对象
       例如:  1. $speech.css('fontSize', num + 'px');      2. var Obj ={'background-color' : '#ddd','color' : 'rgb(0,40,244)'};     $(this).css(Obj);

> 浏览器厂商在引入试验性的样式属性时，在属性名前面添加一个前缀.如果想在 JavaScript 中设置这些属性，需要提前检测它们在 DOM 中是否存在,。但在jQuery中，我们可以直接使用标准的属性名，如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性
### 样式变化
- 隐藏/显示元素:  .hide() .show()  ->相当于设置display的值   默认是不带动画效果的.
>.hide()方法会将匹配的元素集合的内联style属性设置为display:none。但他会记住原先的display值,通过.show() 进行恢复(在不破坏布局的情况下恢复),如果破坏布局会改变display属性以维持布局
- 带动画效果: .hide('duration')   duration:毫秒级   动画效果->会同时减少元素的高度(左到右)、宽度(上到下)和不透明度,
> 动画效果有两种预设的速度参数：'slow'和'fast'。也可以自定义指定显示速度. 以下动画效果都可以适用

- 淡入和淡出, fadeIn(),fadeOut()  : 改变透明度和display的值   本来就处于文档流之外(display:none)的元素，比较适合使用淡入和淡出动画。
- 滑入和滑下, slideDown()和.slideUp() : 改变高度和display的值   元素本来就处在文档流中,适合使用滑入滑出
- 复合效果方法,  slideToggle() ,动画和slideDown(),slideUp()一样    toggle() 动画效果和hide(),show()一样    两者都是切换可见性,不需要在判断元素是否可见
### 动画
- .animate()方法，用于创建控制更精细的自定义动画,  .animate()方法有两种形式
  
      第一种接收以下4个参数: 样式属性及值的对象,时长,easing类型(linear),回调函数:
      .animate({property1: 'value1', property2: 'value2'}, duration, easing, function() {})
      第二种形式接受两个参数，一个属性对象和一个选项对象
      .animate({ property1: 'value1', property2: 'value2' }, { duration: 'value', easing: 'value',specialEasing: { property1: 'easing1', property2: 'easing2' }, complete: function() {}, queue: true, step: callback });
- animate()方法最少要有两个参数,属性对象和duration
> .animate()方法针对CSS属性提供了方便简写值：'show'、'hide'和'toggle',例如 : .animate({height: 'toggle'}, 'slow');
- animate()方法中,属性对象中的值如果是 {"height" :"+=value" }表示在原来的基础上再加上value,而不是变化到value
#### 并发(同时发生)   排队效果(一个接一个发生)
-  同一个元素,通过连缀写法应用多重效果时,这些效果轻易地实现排队.
> 需要注意的是有些确实是连缀写了多种效果,但是其中通过遍历更改了元素(例如 next()),这就算不同的元素应用的样式
-  想要同时触发效果,要在一个方法内写多个属性

-  多个元素,应用效果时,这些效果会同时发生,
-  为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数,在效果方法中,它们是方法的最后一个参数。
>$clickedItem.next().slideDown('slow', function() { $clickedItem.slideUp('slow'); }); 顺序为外层先执行,内层的回调函数在执行
##### 越过队列(调整排队效果)
- 第二种形式的.animate()方法中的选项对象中的queue属性,设置为false即可让动画和前一个动画同时开始
- 对于非效果方法,如.css()方法,不会出现在队列中, 他们会立即执行而不是按其所在的顺序
>解决方法1:使用.queue()方法添加到队列中,.queue(function(next) { $switcher.css({backgroundColor:'#f00'});next();}) ,传递一个next回调函数,这个next()方法会让队列在中断地方连续起来,去掉之后,动画就中断,不在执行之后的代码

>解决方法2:利用效果方法中的回调函数,在回调函数中书写.css(), 在外层函数完成时执行css,不需要调用next()

### DOM操作
#### 属性操作
##### HTML 属性操作
- .attr() 设置/获取属性  ,传入一个包含键值对的对象,第一个是属性名，第二个是属性值
> 可以改变多个属性或者获取多个属性,但是这是写死的属性值,如果每个匹配的元素的属性值有变化,这时候可以使用值回调 (调动函数)例如:
- $('div.chapter a').attr({  title: 'Learn more at Wikipedia', id: function(index, oldValue) { return 'wikilink-' + index; }
>这里的index代表迭代次数 , oldvalue代表改变之前的值,这不是用户传递的,而是jquery预设,可以直接使用
- .removeAttr()方法 删除*一个*属性

- 类属性常用函数: .addClass()和.removeClass()   .toggleClass()方法交替添加删除类名
##### DOM 属性
- 在jQuery中,可以通过.prop()方法取得和设置DOM属性;.prop()方法与.attr()方法没有什么不同
- >从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。
- DOM的是 property   Html的是 attributes 两者翻译都是属性,但有差别,一般情况下两者会有相对应的属性 例如:
- > var id = div1.getAttribute("id")    var id = div1.id;
- HTML属性与DOM属性有一点区别。HTML属性是指页面标记中放在引号中的值，而DOM属性则是指通过JavaScript能够存取的值,HTML属性与DOM属性差别最大的地方是表单控件的属性,不要使用attr(),要使用val()获取/设置属性  或者是prop操作DOM属性(这个是要分情况的)
> .val()方法也可以接受一个函数作为其setter参数,与.attr()和.prop()一样 表单中最好都使用本函数

#### 节点操作

- 创建节点 :  使用$("")函数创建节点
- 插入(添加).移动节点: 
   
      内容.insertBefore("目标")在现有元素外部、之前添加内容；
      .prependTo()在现有元素内部、之前添加内容；
      .appendTo()在现有元素内部、之后添加内容；
      .insertAfter()在现有元素外部、之后添加内容。
       
> 使用以上方法移动节点,原位置不会保留节点,那样就是复制节点了
> 在隐式迭代添加多个节点时,插入顺序预定义的,不管是after before,从上到下顺序都是迭代顺序
- 反向插入方法 :内容目标的位置颠倒,名字更换了一下
     
       append()
       prepend()
       before()
       after()
> 反向插入方法,可以接受一个函数作为参数,这个函数会针对每个目标元素调用
- 包裹节点

      被包裹的节点.wrap("节点")  .wrapAll("节点") 区别:后者在多个节点时,只包裹一次(最外面的节点),wrap每个节点都会包装,wrapInner()包裹匹配元素的子元素

- 复制节点

      .clone()方法,默认不复制事件,如果想要复制.clone(true);  

- 删除节点 
> 从DOM文档中移除每个匹配的元素及其后代元素,但是不会删除html中的文件

      remove(),detach()两者区别: 在于使detach时删除,元素再次被使用时其中绑定的事件,附加数据不会被删除,两者的返回值是被删除的元素,可以通过函数再次添加.括号内参数可选,选择器/null 
      empty()清空节点里的内容(文本 元素节点),*注意是节点里的,不是节点本身* 返回一个已经清空的元素
- 替换节点(文本/元素)
  
   
     .html() 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容
     .text() 返回所有文本,包括子元素的文本, 参数可以替换节点文本
     .replaceAll("目标") 替换每个目标元素,如果目标和内容是同一个文档的,那么会发生移动
     .replaceWith("内容")   替换集合中所有匹配的元素,返回被删除元素的集合
   
#### DOM遍历
- find("选择器")  通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代。
- end() 终止在当前链的最新过滤操作，并返回匹配的元素的以前状态.
- each()方法就是一个显式迭代器,。这个方法接受一个回调函数,这个函数会针对匹配的元素集中的每个元素都调用一次
- .filter() 它可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中
-  next()方法 .nextAll() 获得后面所有的元素    对应方法: .prev()和.prevAll() 
- .siblings() 获取兄弟元素，无论这些元素处于当前元素之前还是之后.
-   parent()     , children() :只考虑子元素,不考虑后代元素
-  jQuery提供了.get()方法,要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。简写为[0]

### jquery中的AJAX技术
> 原生js的ajax并没有涉及,可以查阅资料了解
- Ajax只不过是一种无需刷新页面即可从服务器（或客户端）上加载数据的手段。这些数据的格式可以是很多种,例如:HTML JSON XML js       
- 所有Ajax请求在默认情况下都是异步的
##### 加载数据
- HTML文件:  .load()方法,加载远程HTML代码插入DOM中,格式:load(URL,data,callback)
- JSON文件:  $.getJson()方法用于加载json ,这是个全局函数, 可以接受第2个参数，这个参数是当加载完成时调用的函数(用来处理加载过来的数据)
> 尽管JSON格式很简洁，但它却不容许任何错误，否则文件不会加载。而且在多数浏览器中当文件加载失败时我们看不到任何错误信息,脚本只是静默地彻底终止运转。
- js文件(可当做脚本文件): $.getScript()   (脚本文件基本有服务器端写,前端负责取数据直接调用)
> 以这种方式取得的脚本会在当前页面的全局环境下执行。这意味着脚本有权访问在全局环境中定义的函数和变量，当然也包括jQuery自身。常见脚本php node.js... 一般纯j不用作脚本
- XML文件: $.get() 
> 通常，这个函数只是取得由URL指定的文件，然后将纯文本格式的数据提供给回调函数。但是,在根据服务器提供的MIME类型知道响应的是XML的情况下，提供给回调函数的将是XML DOM树。这样可以向操作html一样操作xML文件中数据
##### 向服务器传递数据
- Ajax的价值只有当服务器能够基于浏览器的输入动态形成数据时才能得到充分体现
- 执行GET请求 根据 $.get函数,向服务器传递参数(要查询的数据),得到服务器返回的数据.
> load函数也可以,URL后面添加查询字符串,load()方法在接收到包含数据的对象参数时，会默认使用POST方法
发送请求
- 执行POST请求  $.post()
- 表单提交------序列化表单

##### 请求过程
- jQuery提供了一组函数，通过它们能够为各种与Ajax相关的事件注册回调函数。

            .ajaxStart()和.ajaxStop()方法  只能由$(document)调用 ,无法分辨那个对象发出请求,只要有请求都会触发这两个
            当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数 
            当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数.

            如.ajaxError()，会向它们的回调函数发送一个对XMLHttpRequest对象的
            引用。这样就可以做到区别不同的请求来提供不同的行为
            其他更具体的处理可以通过使用低级的$.ajax()函数来完成。
- 错误处理:    除了使用全局的.ajaxError()方法,还有jQuery的延迟对象系统 
##### ajax中的常见问题
- 通过Ajax生成页面内容时的一个常见问题:事件绑定丢失
> 事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。
> 解决方法: 每次页面内容更新重新绑定事件      使用事件委托
- 安全限制 : 为了防止各种跨站点脚本攻击，一般情况下从提供原始页面的服务器之外的站点请求文档是不可能的。但是，从第三方来源中加载数据往往是很有必要的
>方法: 是通过服务器加载远程数据，然后在客户请求时提供给浏览器.    根据请求注入< script>标签或者$.getScript() 使用< iframe>这个HTML标签来加载远程数据。    从其他服务器取得JSONP文件.
- 使用$.ajaxSetup()函数可以修改调用Ajax方法时每个选项的默认值。这个函数与.\$.ajax()接受相同的选项对象参数，之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖，
- 取得部分HTML片段,要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式

----------
以上为最基础核心,掌握运用
> 开发插件章节  需要后期编码后进行学习 

### 高级DOM遍历 高级事件处理  高级效果
##### 高级遍历
-  Sizzle在jQuery中负责解析我们传入$()函数中的CSS选择符表达式。它决定使用何种原生的DOM方法来构建元素集合，以便通过其他jQuery方法来操作这些元素。
> 使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异
- 选择符优化问题 自定义选择符
> 如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。这时候会影响性能,多使用原生的css选择器
- DOM遍历背后的原理
>向$()函数传入一个选择符表达式。而得到的对象是一个数组结构，其中包含着与该选择符匹配的每个DOM元素的引用。可是我们并不知道的是，这个对象中还隐藏着其他一些属性,这些属性和被选中的对象有关
- addBack  end函数利用了这些属性,使用了DOM元素栈,所以才能完成相应功能,在相应的自定义遍历方法中,为了支持这两个函数,自定义也需要考虑
- DOM 遍历的性能问题 : 多使用连缀,和缓存jquery对象,来最低限度的重复使用选择符和遍历方法

##### 事件处理
- 扩展事件  自定义事件 节流事件

##### 高级动画
> 使用jQuery自定义的:animated选择符, is(':animated')判断是否在动画中
- 中止运行的动画 .stop([clearqueue][jumptoend]) 两个可选参数,默认都为false
> 在1.7之前版本  在动画之前，这些简写的动画方法(slidedown fadein...)会确定最终的值，然后动态变化到该值。导致中断这个动画,下次触发动画时要改变的数值是上次中断时的值. 更好的办法是把最终值保存在一个变量中，使用.animate()显式变化到该值，而不要依赖jQuery确定的值。

- 延迟动画执行 delay() 


- 全局效果属性 :$.fx对象  \

      禁用所有动画效果-> $.fx.off=true;
      定义效果时长 $.fx.speeds= ...  可以改变预设值的效果速度,可以自定义一个速度选项


- 多属性缓动  

     通过动画方法中,specialEasing选项可以为每个要应用动画的属性设置不同的加速度曲线。任何没有包含在这个选项中的属性，都会使用easing选项中指定的缓动函数——如果提供了的话；否则，就要使用默认的swing函数

- 使用延迟对象,对于任何延迟对象，调用它的.promise()方法就可以取得其承诺对象,
- >每个jQuery集合都有一组与之关联的延迟对象，用于跟踪集合中元素要执行的各种操作状态。通过在jQuery对象上调用.promise()方法，可以得到一个队列完成后被解决的承诺对象 .promise().done(showBio); 在队列完成之后调用showBio函数  .always() 在延迟对象完成任务时调用

- .animate()方法还提供了两个回调选项 step  progress，让我们可以检视和修改动画的每一步.  
> jQuery动画系统最底层的方法是\$.Animation()和\$.Tween()函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面

##### 高级DOM操作
- 从服务端取得数据排序问题

-----------
第十三章 高级ajax操作,要等到node.js时开始

本文档参考                   <  jquery 基础教程第四版  2020 6.30 >